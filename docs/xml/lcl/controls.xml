<?xml version="1.0" encoding="UTF-8"?>
<!--

Documentation for LCL (Lazarus Component Library) and LazUtils (Lazarus 
Utilities) are published under the Creative Commons Attribution-ShareAlike 4.0 
International public license.

https://creativecommons.org/licenses/by-sa/4.0/legalcode.txt
https://gitlab.com/freepascal.org/lazarus/lazarus/-/blob/main/docs/cc-by-sa-4-0.txt

Copyright (c) 1997-2025, by the Lazarus Development Team.

-->
<fpdoc-descriptions>
<package name="lcl">
<!--
====================================================================
Controls
====================================================================
-->
<module name="controls">
<short>
Contains types, constants, classes, and routines used to implement visual 
controls.
</short>
<descr>
<p>
<file>controls.pp</file> contains classes, types, constants, and routines 
used to implement visual controls used in the Lazarus Component Library 
(<b>LCL</b>). Most of the classes are base classes, or used in the 
implementation of controls defined in others units.
</p>
<p>
The following components are added to the <b>Common Controls</b> tab in the 
Lazarus IDE component palette:
</p>
<ul>
<li>TImageList</li>
</ul>
<p>
The following components are registered but not displayed on the Lazarus IDE 
component palette:
</p>
<ul>
<li>TCustomControl</li>
<li>TGraphicControl</li>
</ul>
<p>
<file>controls.pp</file> is part of the Lazarus Component Library (<b>LCL</b>).
</p>
</descr>

<!-- unresolved external references -->
<!-- used for FPC 3.2.X type aliases -->
<element name="System.UITypes"/>
<!-- used for pre-FPC 3.2.X -->
<!-- <element name="UITypes"/> -->
<element name="Classes"/>
<element name="SysUtils"/>
<element name="TypInfo"/>
<element name="Types"/>
<element name="Laz_AVL_Tree"/>
<element name="LCLStrConsts"/>
<element name="LCLType"/>
<element name="LCLProc"/>
<element name="Graphics"/>
<element name="LMessages"/>
<element name="LCLIntf"/>
<element name="InterfaceBase"/>
<element name="ImgList"/>
<element name="PropertyStorage"/>
<element name="Menus"/>
<element name="ActnList"/>
<element name="LCLClasses"/>
<element name="LResources"/>
<element name="LCLPlatformDef"/>
<element name="GraphType"/>
<element name="GraphMath"/>
<element name="LazMethodList"/>
<element name="LazLoggerBase"/>
<element name="LazTracer"/>
<element name="LazUtilities"/>

<!-- included from controlconsts.inc -->
<element name="CM_BASE">
<short>
Starting value for control message constants defined in the LCL.
</short>
</element>
<element name="CM_LCLOFFSET">
<short>Control message constant.</short>
</element>
<element name="CM_ACTIVATE">
<short>Control message constant.</short>
</element>
<element name="CM_DEACTIVATE">
<short>Control message constant.</short>
</element>
<element name="CM_GOTFOCUS">
<short>Control message constant.</short>
</element>
<element name="CM_LOSTFOCUS">
<short>Control message constant.</short>
</element>
<element name="CM_CANCELMODE">
<short>Control message constant.</short>
</element>
<element name="CM_DIALOGKEY">
<short>Control message constant.</short>
</element>
<element name="CM_DIALOGCHAR">
<short>Control message constant.</short>
</element>
<element name="CM_FOCUSCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_PARENTFONTCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_PARENTCOLORCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_HITTEST">
<short>Control message constant.</short>
</element>
<element name="CM_VISIBLECHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_ENABLEDCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_COLORCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_FONTCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_CURSORCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_CTL3DCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_PARENTCTL3DCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_TEXTCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_MOUSEENTER">
<short>Control message constant.</short>
</element>
<element name="CM_MOUSELEAVE">
<short>Control message constant.</short>
</element>
<element name="CM_MENUCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_APPKEYDOWN">
<short>Control message constant.</short>
</element>
<element name="CM_APPSYSCOMMAND">
<short>Control message constant.</short>
</element>
<element name="CM_BUTTONPRESSED">
<short>Control message constant.</short>
</element>
<element name="CM_SHOWINGCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_ENTER">
<short>Control message constant.</short>
</element>
<element name="CM_EXIT">
<short>Control message constant.</short>
</element>
<element name="CM_DESIGNHITTEST">
<short>Control message constant.</short>
</element>
<element name="CM_ICONCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_WANTSPECIALKEY">
<short>Control message constant.</short>
</element>
<element name="CM_INVOKEHELP">
<short>Control message constant.</short>
</element>
<element name="CM_WINDOWHOOK">
<short>Control message constant.</short>
</element>
<element name="CM_RELEASE">
<short>Control message constant.</short>
</element>
<element name="CM_SHOWHINTCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_PARENTSHOWHINTCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_SYSCOLORCHANGE">
<short>Control message constant.</short>
</element>
<element name="CM_WININICHANGE">
<short>Control message constant.</short>
</element>
<element name="CM_FONTCHANGE">
<short>Control message constant.</short>
</element>
<element name="CM_TIMECHANGE">
<short>Control message constant.</short>
</element>
<element name="CM_TABSTOPCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_UIACTIVATE">
<short>Control message constant.</short>
</element>
<element name="CM_UIDEACTIVATE">
<short>Control message constant.</short>
</element>
<element name="CM_DOCWINDOWACTIVATE">
<short>Control message constant.</short>
</element>
<element name="CM_CONTROLLISTCHANGE">
<short>Control message constant.</short>
</element>
<element name="CM_GETDATALINK">
<short>Control message constant.</short>
</element>
<element name="CM_CHILDKEY">
<short>Control message constant.</short>
</element>
<element name="CM_DRAG">
<short>Control message constant.</short>
</element>
<element name="CM_HINTSHOW">
<short>Control message constant.</short>
</element>
<element name="CM_DIALOGHANDLE">
<short>Control message constant.</short>
</element>
<element name="CM_ISTOOLCONTROL">
<short>Control message constant.</short>
</element>
<element name="CM_RECREATEWND">
<short>Control message constant.</short>
</element>
<element name="CM_INVALIDATE">
<short>Control message constant.</short>
</element>
<element name="CM_SYSFONTCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_CONTROLCHANGE">
<short>Control message constant.</short>
</element>
<element name="CM_CHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_DOCKCLIENT">
<short>Control message constant.</short>
</element>
<element name="CM_UNDOCKCLIENT">
<short>Control message constant.</short>
</element>
<element name="CM_FLOAT">
<short>Control message constant.</short>
</element>
<element name="CM_BORDERCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_BIDIMODECHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_PARENTBIDIMODECHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_ALLCHILDRENFLIPPED">
<short>Control message constant.</short>
</element>
<element name="CM_ACTIONUPDATE">
<short>Control message constant.</short>
</element>
<element name="CM_ACTIONEXECUTE">
<short>Control message constant.</short>
</element>
<element name="CM_HINTSHOWPAUSE">
<short>Control message constant.</short>
</element>
<element name="CM_DOCKNOTIFICATION">
<short>Control message constant.</short>
</element>
<element name="CM_MOUSEWHEEL">
<short>Control message constant.</short>
</element>
<element name="CM_ISSHORTCUT">
<short>Control message constant.</short>
</element>
<element name="CM_UPDATEACTIONS">
<short>Control message constant.</short>
</element>
<element name="CM_INVALIDATEDOCKHOST">
<short>Control message constant.</short>
</element>
<element name="CM_SETACTIVECONTROL">
<short>Control message constant.</short>
</element>
<element name="CM_POPUPHWNDDESTROY">
<short>Control message constant.</short>
</element>
<element name="CM_CREATEPOPUP">
<short>Control message constant.</short>
</element>
<element name="CM_DESTROYHANDLE">
<short>Control message constant.</short>
</element>
<element name="CM_MOUSEACTIVATE">
<short>Control message constant.</short>
</element>
<element name="CM_CONTROLLISTCHANGING">
<short>Control message constant.</short>
</element>
<element name="CM_BUFFEREDPRINTCLIENT">
<short>Control message constant.</short>
</element>
<element name="CM_UNTHEMECONTROL">
<short>Control message constant.</short>
</element>
<element name="CM_DOUBLEBUFFEREDCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_PARENTDOUBLEBUFFEREDCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_THEMECHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_GESTURE">
<short>Control message constant.</short>
</element>
<element name="CM_CUSTOMGESTURESCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_GESTUREMANAGERCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_STANDARDGESTURESCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_INPUTLANGCHANGE">
<short>Control message constant.</short>
</element>
<element name="CM_TABLETOPTIONSCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_PARENTTABLETOPTIONSCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_MASKHITTEST">
<short>
Control message constant implement by controls with an irregular shape to check 
if a point belongs to a shape.
</short>
</element>
<element name="CM_APPSHOWBTNGLYPHCHANGED">
<short>Control message constant.</short>
</element>
<element name="CM_APPSHOWMENUGLYPHCHANGED">
<short>Control message constant.</short>
</element>

<!-- included from controlconsts.inc -->
<element name="CN_BASE">
<short>Starting value for control notification messages in the LCL.</short>
</element>
<element name="CN_CHARTOITEM">
<short>Control notification message constant.</short>
</element>
<element name="CN_COMMAND">
<short>Control notification message constant.</short>
</element>
<element name="CN_COMPAREITEM">
<short>Control notification message constant.</short>
</element>
<element name="CN_CTLCOLORBTN">
<short>Control notification message constant.</short>
</element>
<element name="CN_CTLCOLORDLG">
<short>Control notification message constant.</short>
</element>
<element name="CN_CTLCOLOREDIT">
<short>Control notification message constant.</short>
</element>
<element name="CN_CTLCOLORLISTBOX">
<short>Control notification message constant.</short>
</element>
<element name="CN_CTLCOLORMSGBOX">
<short>Control notification message constant.</short>
</element>
<element name="CN_CTLCOLORSCROLLBAR">
<short>Control notification message constant.</short>
</element>
<element name="CN_CTLCOLORSTATIC">
<short>Control notification message constant.</short>
</element>
<element name="CN_DELETEITEM">
<short>Control notification message constant.</short>
</element>
<element name="CN_DRAWITEM">
<short>Control notification message constant.</short>
</element>
<element name="CN_HSCROLL">
<short>Control notification message constant.</short>
</element>
<element name="CN_MEASUREITEM">
<short>Control notification message constant.</short>
</element>
<element name="CN_PARENTNOTIFY">
<short>Control notification message constant.</short>
</element>
<element name="CN_VKEYTOITEM">
<short>Control notification message constant.</short>
</element>
<element name="CN_VSCROLL">
<short>Control notification message constant.</short>
</element>
<element name="CN_KEYDOWN">
<short>Control notification message constant.</short>
</element>
<element name="CN_KEYUP">
<short>Control notification message constant.</short>
</element>
<element name="CN_CHAR">
<short>Control notification message constant.</short>
</element>
<element name="CN_SYSKEYUP">
<short>Control notification message constant.</short>
</element>
<element name="CN_SYSKEYDOWN">
<short>Control notification message constant.</short>
</element>
<element name="CN_SYSCHAR">
<short>Control notification message constant.</short>
</element>
<element name="CN_NOTIFY">
<short>Control notification message constant.</short>
</element>

<element name="mrNone">
<short>
Modal dialog exited with the None button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrNone in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrNone">mrNone</link>
-->
</seealso>
</element>
<element name="mrOK">
<short>
Modal dialog exited with the OK button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrOK in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrOK">mrOK</link>
-->
</seealso>
</element>
<element name="mrCancel">
<short>
Modal dialog exited with the Cancel button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrCancel in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrCancel">mrCancel</link>
-->
</seealso>
</element>
<element name="mrAbort">
<short>
Modal dialog aborted.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrAbort in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrAbort">mrAbort</link>
-->
</seealso>
</element>
<element name="mrRetry">
<short>
Modal dialog exited with the Retry button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrRetry in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrRetry">mrRetry</link>
-->
</seealso>
</element>
<element name="mrIgnore">
<short>
Modal dialog exited with the Ignore button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrIgnore in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrIgnore">mrIgnore</link>
-->
</seealso>

</element>
<element name="mrYes">
<short>
Modal dialog exited with the Yes button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrYes in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrYes">mrYes</link>
-->
</seealso>
</element>
<element name="mrNo">
<short>
Modal dialog exited with the No button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrNo in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrNo">mrNo</link>
-->
</seealso>
</element>
<element name="mrAll">
<short>
Modal dialog exited with the All button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrAll in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrAll">mrAll</link>
-->
</seealso>
</element>
<element name="mrNoToAll">
<short>
Modal dialog exited with the NoToAll button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrNoToAll in System.UITypes for FPC 
3.2.0 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrNoToAll">mrNoToAll</link>
-->
</seealso>
</element>
<element name="mrYesToAll">
<short>
Modal dialog exited with the YesToAll button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrYesToAll in System.UITypes for FPC 
3.2.0 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrYesToAll">mrYesToAll</link>
-->
</seealso>
</element>
<element name="mrClose">
<short>
Modal dialog exited with the Close button.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrClose in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrClose">mrClose</link>
-->
</seealso>
</element>

<element name="mrContinue">
<short>
Modal result for the Continue button on a dialog.
</short>
<descr/>
<version>
Added in LCL version 3.0 for FPC compiler version 3.2.3 and higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrContinue">mrContinue</link>
-->
</seealso>
</element>

<element name="mrTryAgain">
<short>
Modal result for the Tray Again button on a dialog.
</short>
<descr/>
<version>
Added in LCL version 3.0 for FPC compiler version 3.2.3 and higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrTryAgain">mrTryAgain</link>
-->
</seealso>
</element>

<element name="mrLast">
<short>
Last (highest) value of modal results.
</short>
<version>
Modified in LCL 3.0 to be an alias to mrLast in System.UITypes for FPC 3.2.0 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mrLast">mrLast</link>
-->
</seealso>
</element>

<!--
<element name="GetModalResultStr">
<short>
Deprecated; Use the ModalResultStr array from the <file>UITypes</file> unit.
</short>
<descr/>
<seealso/>
</element>
<element name="GetModalResultStr.Result"/>
<element name="GetModalResultStr.ModalResult"/>
-->

<!--
<element name="ModalResultStr">
<short>
Gets the string representation for a modal result value.
</short>
<descr>
<p>
<var>ModalResultStr</var> is an indexed <var>ShortString</var> property used 
to get the string representation for the specified TModalResult constant. The 
read access specifier for the property has been deprecated; Use the 
ModalResultStr array from the <file>UITypes</file> unit directly.
</p>
</descr>
<seealso>
<link id="#lcl.uitypes.ModalResultStr">ModalResultStr</link>
<link id="#lcl.uitypes.TModalResult">TModalResult</link>
</seealso>
</element> 
-->

<element name="fsSurface">
<short>
Alias to the fsSurface constant in the <file>GraphType</file> unit.
</short>
</element>

<element name="fsBorder">
<short>
Alias to the fsBorder constant in the <file>GraphType</file> unit.
</short>
</element>

<element name="bvNone">
<short>
Alias to the bvNone constant in the <file>GraphType</file> unit.
</short>
</element>

<element name="bvLowered">
<short>
Alias to the bvLowered constant in the <file>GraphType</file> unit.
</short>
</element>

<element name="bvRaised">
<short>
Alias to the bvRaised constant in the <file>GraphType</file> unit.
</short>
</element>

<element name="bvSpace">
<short>
Alias to the bvSpace constant in the <file>GraphType</file> unit.
</short>
</element>

<element name="ssModifier">
<short>Defines the key used for shortcuts on different platforms.</short>
<descr>
<p>
<var>ssModifier</var> is a constant which defines the modifier for keyboard 
shortcuts, like Ctrl+C (Copy), Ctrl+Z (UnDo), Ctrl+X (Cut), and Ctrl+V 
(paste). Mac and iOS use the Meta key (instead of the Ctrl key) for those 
shortcuts.
</p>
</descr>
<seealso/>
</element>

<element name="GUID_ObjInspInterface">
<short>GUID for the Object Inspector in the Lazarus IDE.</short>
<descr>
Value is '{37417989-8C8F-4A2D-9D26-0FA377E8D8CC}'
</descr>
<seealso/>
</element>

<element name="IObjInspInterface">
<short>Defines an interface used in the Lazarus Object Inspector.</short>
<descr>
<p>
Allows the Lazarus object inspector to query controls which implement the 
interface about the ability to add or delete items in the control.
</p>
</descr>
<seealso>
<link id="#lcl.extctrls.TFlowPanelControl">TFlowPanelControl</link>
<link id="#lcl.extctrls.TFlowPanelControlList">TFlowPanelControlList</link>
</seealso>
</element>

<element name="IObjInspInterface.AllowAdd">
<short>
Returns <b>True</b> an item can be added in a control.
</short>
<descr/>
<seealso/>
</element>
<element name="IObjInspInterface.AllowAdd.Result">
<short>
Returns <b>True</b> if an item can be added to a control.
</short>
</element>

<element name="IObjInspInterface.AllowDelete">
<short>
Returns <b>True</b> if an item can be deleted from a control.
</short>
<descr/>
<seealso/>
</element>
<element name="IObjInspInterface.AllowDelete.Result">
<short>
Returns <b>True</b> an item can be delteted in a control.
</short>
</element>

<element name="TWinControlClass">
<short>
<var>TWinControlClass</var> - class of <var>TWinControl</var>.
</short>
<descr/>
<seealso/>
</element>

<element name="TControlClass">
<short>
<var>TControlClass</var> - class of <var>TControl</var>.
</short>
<descr/>
<seealso/>
</element>

<element name="TCMMouseWheel">
<short>Defines a structure used for mouse wheel control messages.</short>
<descr>
<p>Holds mouse wheel details that include:</p>
<ul>
<li>the Message associated with the wheel</li>
<li>the shift state (i.e. whether Shift, Alt, Control keys have been 
pressed)</li>
<li>the mouse position</li>
<li>the message Result</li>
</ul>
</descr>
<seealso/>
</element>

<element name="TCMMouseWheel.Msg">
<short>
Cardinal value with the CM_MOUSEWHEEL identifier for the mouse wheel message.
</short>
<descr/>
<seealso/>
</element>
<element name="TCMMouseWheel.ShiftState">
<short>State of the modifier for keys and mouse buttons.</short>
<descr/>
<seealso/>
</element>
<element name="TCMMouseWheel.Unused">
<short>Inserted for alignment only.</short>
<descr/>
<seealso/>
</element>
<element name="TCMMouseWheel.WheelData">
<short>
Number of notches or units the mouse wheel was moved. Negative for mouse 
wheel up movements.
</short>
<descr/>
<seealso/>
</element>
<element name="TCMMouseWheel.Pos">
<short>Mouse position as a TSmallPoint value.</short>
</element>
<element name="TCMMouseWheel.XPos">
<short>Mouse X position as a SmallInt value.</short>
</element>
<element name="TCMMouseWheel.YPos">
<short>Mouse Y position as a SmallInt value.</short>
</element>
<element name="TCMMouseWheel.Result">
<short>
Result for the mouse wheel message. Zero (0) indicates the message was 
handled.
</short>
</element>

<element name="TCMHitTest">
<short>Alias for the TLMNCHitTest type.</short>
<descr/>
<seealso>
<link id="#lcl.lmessages.TLMNCHitTest">TLMNCHitTest</link>
</seealso>
</element>

<element name="TCMDesignHitTest">
<short>Alias for the TLMMouse type.</short>
<descr/>
<seealso>
<link id="#lcl.lmessages.TLMMouse">TLMMouse</link>
</seealso>
</element>

<element name="TCMControlChange">
<short>Contains values representing a Control Change Message.</short>
<descr>
<p>
<var>TCMControlChange</var> is a record type which contains values 
representing the arguments and the result for a Control Change Message. 
<var>TCMControlChange</var> is the type passed to the 
<var>CMControlChange</var> method in <var>TCustomFlowPanel</var>.
</p>
</descr>
<seealso>
<link id="#lcl.extctrls.TCustomFlowPanel.CMControlChange">TCustomFlowPanel.CMControlChange</link>
</seealso>
</element>
<element name="TCMControlChange.Msg">
<short>Mouse message constant for the change notification.</short>
</element>
<element name="TCMControlChange.UnusedMsg">
<short>Padding added for alignment on 64-bit platforms.</short>
</element>
<element name="TCMControlChange.Control">
<short>Control to receive the change message.</short>
</element>
<element name="TCMControlChange.Inserting">
<short>Indicates if the control message is an insert operation.</short>
</element>
<element name="TCMControlChange.Result">
<short>Result for the control change message.</short>
</element>

<element name="TCMChanged">
<short>Not used in the current LCL implementation.</short>
</element>
<element name="TCMChanged.Msg"/>
<element name="TCMChanged.Unused"/>
<element name="TCMChanged.Child"/>
<element name="TCMChanged.Result"/>

<element name="TCMControlListChange">
<short>Not used in the current LCL implementation.</short>
</element>
<element name="TCMControlListChange.Msg"/>
<element name="TCMControlListChange.Control"/>
<element name="TCMControlListChange.Inserting"/>
<element name="TCMControlListChange.Result"/>

<element name="TCMDialogChar">
<short>Alias for the TLMKey type.</short>
<seealso>
<link id="#lcl.lmessages.TLMKey">TLMKey</link>
</seealso>
<notes><note>Used in LazReport controls.</note></notes>
</element>

<element name="TCMDialogKey">
<short>Alias for the TLMKey type.</short>
<seealso>
<link id="#lcl.lmessages.TLMKey">TLMKey</link>
</seealso>
<notes><note>Used in the jvcllaz package.</note></notes>
</element>

<element name="TCMEnter">
<short>Alias for the TLMEnter type.</short>
<seealso>
<link id="#lcl.lmessages.TLMEnter">TLMEnter</link>
</seealso>
</element>

<element name="TCMExit">
<short>Alias for the TLMExit type.</short>
<seealso>
<link id="#lcl.lmessages.TLMExit">TLMExit</link>
</seealso>
</element>

<element name="TCMCancelMode">
<short>
Contains information representing a CM_CANCELMODE control message.
</short>
<notes><note>Used in the jvcllaz package.</note></notes>
</element>
<element name="TCMCancelMode.Msg">
<short>
Message constant.
</short>
</element>
<element name="TCMCancelMode.Unused">
<short>
Padding for alignment.
</short>
</element>
<element name="TCMCancelMode.Sender">
<short>
Control which generated the message.
</short>
</element>
<element name="TCMCancelMode.Result">
<short>
0 if the message has not been handled.
</short>
</element>

<element name="TCMChildKey">
<short>Not used in the current LCL implementation.</short>
<descr/>
<seealso/>
</element>
<element name="TCMChildKey.Msg"/>
<element name="TCMChildKey.UnusedMsg"/>
<element name="TCMChildKey.Unused"/>
<element name="TCMChildKey.CharCode"/>
<element name="TCMChildKey.Sender"/>
<element name="TCMChildKey.Result"/>

<element name="TAlign">
<short>Alignment options for a control, within its Parent control.</short>
<descr>
<p>
<var>TAlign</var> is an enumeration type with values that indicate the 
alignment for a control within its Parent. The enumeration includes the 
following values and meanings:
</p>
<dl>
<dt>alNone</dt>
<dd>fixed position and extent</dd>
<dt>alTop</dt>
<dd>stacked at top, full width</dd>
<dt>alBottom</dt>
<dd>stacked at bottom, full width</dd>
<dt>alLeft</dt>
<dd>stacked at left, full height</dd>
<dt>alRight</dt>
<dd>stacked at right, full height</dd>
<dt>alClient</dt>
<dd>filling entire remaining client area</dd>
<dt>alCustom</dt>
<dd>other alignment, in drag-dock: notebook</dd>
</dl>
<p>
At most, one control can have alClient alignment for a given form or 
container.
</p>
<p>
The order of multiple controls with the same (stackable) alignment is 
determined by their Left and/or Top coordinate. The precedence of conflicting 
alignment requests (e.g. one at top, one at right) is resolved.
</p>
</descr>
</element>
<element name="TAlign.alNone">
<short>Control has fixed size and position.</short>
</element>
<element name="TAlign.alTop">
<short>Control stacked at top, full width.</short>
</element>
<element name="TAlign.alBottom">
<short>Control stacked at bottom, full width.</short>
</element>
<element name="TAlign.alLeft">
<short>Control stacked at left, full height.</short>
</element>
<element name="TAlign.alRight">
<short>Control stacked at right, full height.</short>
</element>
<element name="TAlign.alClient">
<short>Control fills remaining client area.</short>
</element>
<element name="TAlign.alCustom">
<short>Control has special alignment.</short>
<descr/>
</element>

<element name="TAlignSet">
<short>Set of alignment options.</short>
<seealso>
<link id="#lcl.controls.TAlign">TAlign</link>
</seealso>
</element>

<element name="TAnchorKind">
<short>The control side to be anchored.</short>
<descr>
<p>
With the TAnchorSideReference value asrCenter, the sides mean horizontal or 
vertical alignment of the control's center.
</p>
</descr>
<version>
Modified in LCL 3.0 to be an alias to the TAnchorKind type in System.UITypes 
for FPC 3.2.3 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation.
<link id="#rtl.system.uitypes.TAnchorKind">TAnchorKind</link>
-->
</seealso>
</element>
<element name="TAnchorKind.akTop">
<short>Top side (or center vertically).</short>
</element>
<element name="TAnchorKind.akLeft">
<short>Left side (or center horizontally).</short>
</element>
<element name="TAnchorKind.akRight">
<short>Right side (or center horizontally).</short>
</element>
<element name="TAnchorKind.akBottom">
<short>Bottom side (or center vertically).</short>
</element>

<element name="TAnchors">
<short>Set type used to store values from the TAnchorKind enumeration.</short>
<descr>
<p>
TAnchors is the type used to implement the Anchors property in TControl and 
descendent classes.
</p>
</descr>
<version>
Modified in LCL 3.0 to be an alias to the TAnchors type in System.UITypes 
for FPC 3.2.3 or higher.
</version>
<seealso>
<link id="TAnchorKind"/>
<link id="TControl.Anchors"/>
<!--
Uncomment when the topic exists in the RTL documentation.
<link id="#rtl.system.uitypes.TAnchors">TAnchors</link>
-->
</seealso>
</element>

<element name="TAnchorSideReference">
<short>
The side of another control, to which this control's side is anchored.
</short>
<descr/>
<version>
Modified in LCL 3.0 to be an alias to the TAnchorSideReference type in 
System.UITypes for FPC 3.2.3 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.TAnchorSideReference">TAnchorSideReference</link>
-->
</seealso>
</element>
<element name="TAnchorSideReference.asrTop">
<short>Anchor to the top side.</short>
</element>
<element name="TAnchorSideReference.asrBottom">
<short>Anchor to the bottom side.</short>
</element>
<element name="TAnchorSideReference.asrCenter">
<short>Anchor to the center of the other control.</short>
</element>

<element name="akLeft">
<short>
Represents the enumeration value akLeft in TAnchorKind.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the System.UITypes constant for FPC 3.2.3 or 
higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.akLeft">akLeft</link>
-->
</seealso>
</element>

<element name="akTop">
<short>
Represents the enumeration value akTop in TAnchorKind.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the System.UITypes constant for FPC 3.2.3 or 
higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.akTop">akTop</link>
-->
</seealso>
</element>

<element name="akRight">
<short>
Represents the enumeration value akRight in TAnchorKind.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the System.UITypes constant for FPC 3.2.3 or 
higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.akRight">akRight</link>
-->
</seealso></element>

<element name="akBottom">
<short>
Represents the enumeration value akRight in TAnchorKind.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the System.UITypes constant for FPC 3.2.3 or 
higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.akBottom">akBottom</link>
-->
</seealso>
</element>

<element name="asrTop">
<short>
Represents the enumeration value asrTop in TAnchorSideReference.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the System.UITypes constant for FPC 3.2.3 or 
higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.asrTop">asrTop</link>
-->
</seealso>
</element>

<element name="asrBottom">
<short>
Represents the enumeration value asrBottom in TAnchorSideReference.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the System.UITypes constant for FPC 3.2.3 or 
higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.asrBottom">asrBottom</link>
-->
</seealso>
</element>

<element name="asrCenter">
<short>
Represents the enumeration value asrCenter in TAnchorSideReference.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the System.UITypes constant for FPC 3.2.3 or 
higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.asrCenter">asrCenter</link>
-->
</seealso>
</element>

<element name="asrLeft">
<short>Anchor to the left side (=asrTop).</short>
<descr/>
<seealso/>
</element>

<element name="asrRight">
<short>Anchor to the right side (=asrBottom).</short>
<descr/>
<seealso/>
</element>

<element name="TCaption">
<short>A string type used for the caption on a control.</short>
<descr>
<p>
<var>TCaption</var> is an alias for the <var>TTranslateString</var> type. It 
allows a string value defined using the type to be recognized in the LCL 
translation system. TCaption is the type used to implement properties like 
TControl.Caption, TControl.Text, TControl.AccessibleName, 
TControl.AccessibleValue, et. al.
</p>
</descr>
</element>

<element name="TCursor">
<short>Defines the range of values used for cursor shapes.</short>
<descr>
<p>
<var>TCursor</var> is an Integer type which defines the range of values used 
for cursor shapes. <var>TCursor</var> includes the following values:
</p>
<p><b>Standard Cursors</b></p>
<dl>
<dt>crDefault</dt>
<dd>TCursor(0) - current cursor unchanged</dd>
<dt>crNone</dt>
<dd>TCursor(-1) - hide cursor</dd>
<dt>crArrow</dt>
<dd>TCursor(-2) - normal cursor</dd>
<dt>crCross</dt>
<dd>TCursor(-3) - graphics cursor, for pixel or rectangle selection</dd>
<dt>crIBeam</dt>
<dd>TCursor(-4) - text cursor, for setting insertion point</dd>
</dl>
<p><b>Sizing Cursors</b></p>
<dl>
<dt>crSize</dt>
<dd>TCursor(-22)</dd>
<dt>crSizeAll</dt>
<dd>TCursor(-22)</dd>
<dt>crSizeNESW</dt>
<dd>TCursor(-6) - diagonal north east - south west</dd>
<dt>crSizeNS</dt>
<dd>TCursor(-7)</dd>
<dt>crSizeNWSE</dt>
<dd>TCursor(-8)</dd>
<dt>crSizeWE</dt>
<dd>TCursor(-9)</dd>
<dt>crSizeNW</dt>
<dd>TCursor(-23)</dd>
<dt>crSizeN</dt>
<dd>TCursor(-24)</dd>
<dt>crSizeNE</dt>
<dd>TCursor(-25)</dd>
<dt>crSizeW</dt>
<dd>TCursor(-26)</dd>
<dt>crSizeE</dt>
<dd>TCursor(-27)</dd>
<dt>crSizeSW</dt>
<dd>TCursor(-28)</dd>
<dt>crSizeS</dt>
<dd>TCursor(-29)</dd>
<dt>crSizeSE</dt>
<dd>TCursor(-30)</dd>
</dl>
<p><b>Drag and Drop Cursors</b></p>
<dl>
<dt>crDrag</dt>
<dd>TCursor(-12) - dragging, drop allowed</dd>
<dt>crNoDrop</dt>
<dd>TCursor(-13) - dragging, drop disallowed/rejected</dd>
<dt>crMultiDrag</dt>
<dd>TCursor(-16) - dragging multiple items</dd>
<dt>crNo</dt>
<dd>TCursor(-18)</dd>
<dt>Splitter Cursors</dt>
<dd></dd>
<dt>crHSplit</dt>
<dd>TCursor(-14)</dd>
<dt>crVSplit</dt>
<dd>TCursor(-15)</dd>
</dl>
<p><b>Other Cursors</b></p>
<dl>
<dt>crUpArrow</dt>
<dd>TCursor(-10)</dd>
<dt>crHourGlass</dt>
<dd>TCursor(-11) - busy</dd>
<dt>crSQLWait</dt>
<dd>TCursor(-17)</dd>
<dt>crAppStart</dt>
<dd>TCursor(-19)</dd>
<dt>crHelp</dt>
<dd>TCursor(-20)</dd>
<dt>crHandPoint</dt>
<dd>TCursor(-21)</dd>
</dl>
</descr>
</element>

<element name="TFormStyle">
<short>Defines special form behavior.</short>
<descr/>
<seealso/>
</element>
<element name="TFormStyle.fsNormal">
<short>An ordinary (overlapping) form.</short>
</element>
<element name="TFormStyle.fsMDIChild">
<short>The form is an MDI child.</short>
</element>
<element name="TFormStyle.fsMDIForm">
<short>The form is an MDI parent form, containing MDI child forms.</short>
</element>
<element name="TFormStyle.fsStayOnTop">
<short>
The form is in the foreground, on top of all other application forms.
</short>
</element>
<element name="TFormStyle.fsSplash">
<short>The form is used as a Splash form.</short>
<descr>
<p>
Signifies that the form cannot become the main form in an application. 
Implies that the form responds to fewer messages; generally, paint messages 
and little else. May affect the border style and even the window class used 
for the form on some widgetsets.
</p>
</descr>
</element>
<element name="TFormStyle.fsSystemStayOnTop">
<short>The form stays system-wide on top.</short>
<descr>
<p>
Used in forms for a modal system dialogs. Prevents another form from having a 
higher Z-order value than the current one. Generally treated the same as 
fsStayOnTop except for macOS Cocoa.
</p>
</descr>
</element>

<element name="TFormBorderStyle">
<short>Represents border styles available for a Form.</short>
<descr/>
<seealso/>
</element>
<element name="TFormBorderStyle.bsNone">
<short>A border is not used or displayed.</short>
</element>
<element name="TFormBorderStyle.bsSingle">
<short>Single line border, the form cannot be resized.</short>
</element>
<element name="TFormBorderStyle.bsSizeable">
<short>The form can be resized (standard).</short>
</element>
<element name="TFormBorderStyle.bsDialog">
<short>The form is a dialog, cannot be resized.</short>
</element>
<element name="TFormBorderStyle.bsToolWindow">
<short>Single line border, small caption, not resizable.</short>
</element>
<element name="TFormBorderStyle.bsSizeToolWin">
<short>Small caption, form can be resized.</short>
</element>

<element name="TBorderStyle">
<short>Possible types of borders (with or without border).</short>
<seealso>
<link id="#lcl.controls.TFormBorderStyle">TFormBorderStyle</link>
</seealso>
</element>

<element name="TControlBorderStyle">
<short>Possible types of control borders (with or without border).</short>
<descr>
<p>
A subset of TFormBorderStyle, listing only the styles available to a control 
that is not a form.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TFormBorderStyle">TFormBorderStyle</link>
</seealso>
</element>

<element name="TControlRoleForForm">
<short>Possible default actions on special keys.</short>
<descr/>
<seealso/>
</element>
<element name="TControlRoleForForm.crffDefault">
<short>This control is notified when the user presses Return.</short>
</element>
<element name="TControlRoleForForm.crffCancel">
<short>This control is notified when the user presses Escape.</short>
</element>

<element name="TControlRolesForForm">
<short>
Set type used to store values from the TControlRoleForForm enumeration.
</short>
<descr>
<p>
TControlRolesForForm is the type returned from the 
TCustomForm.GetRolesForControl method.
</p>
</descr>
<seealso>
<link id="TControlRoleForForm"/>
<link id="#lcl.forms.TCustomForm">TCustomForm</link>
</seealso>
</element>

<element name="TBevelCut">
<short>Alias for the TGraphicsBevelCut type.</short>
<descr>
<p>
<var>TBevelCut</var> is the type used to represent bevel styles passed as 
arguments to methods in widgetset classes.
</p>
</descr>
<seealso>
<link id="#lazutils.graphtype.TGraphicsBevelCut">TGraphicsBevelCut</link>
</seealso>
</element>

<element name="TMouseButton">
<short>
Enumeration with values for logical mouse buttons.
</short>
<descr>
<p>
These are <b>logical</b> buttons; the left and right physical buttons can be 
swapped for left-handed users.
</p>
</descr>
<version>
Modified in LCL version 3.0 to be an alias for the TMouseButton type in 
System.UITypes for FPC 3.2.3 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.TMouseButton">TMouseButton</link> 
-->
</seealso>
</element>
<element name="TMouseButton.mbLeft">
<short>
Represents the left mouse button. It might be physically the right button if 
the system is configured to act like that, for example for a left handled 
person.
</short>
</element>
<element name="TMouseButton.mbRight">
<short>
Represents the right mouse button. It might be physically the left button if 
the system is configured to act like that, for example for a left handled 
person.
</short>
</element>
<element name="TMouseButton.mbMiddle">
<short>Represents the middle mouse button.</short>
</element>
<element name="TMouseButton.mbExtra1">
<short>Represents the first extra mouse button.</short>
</element>
<element name="TMouseButton.mbExtra2">
<short>Represents the second extra mouse button.</short>
</element>

<element name="mbLeft">
<short>
Represents the mbLeft enumeration value in TMouseButton.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the constant in System.UITypes for FPC 3.2.3  
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mbLeft">mbLeft</link> 
-->
</seealso>
</element>

<element name="mbRight">
<short>
Represents the mbRight enumeration value in TMouseButton.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the constant in System.UITypes for FPC 3.2.3  
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mbRight">mbRight</link> 
-->
</seealso>
</element>

<element name="mbMiddle">
<short>
Represents the mbMiddle enumeration value in TMouseButton.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the constant in System.UITypes for FPC 3.2.3 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mbMiddle">mbMiddle</link> 
-->
</seealso>
</element>

<element name="mbExtra1">
<short>
Represents the mbExtra1 enumeration value in TMouseButton.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the constant in System.UITypes for FPC 3.2.3 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mbExtra1">mbExtra1</link> 
-->
</seealso>
</element>

<element name="mbExtra2">
<short>
Represents the mbExtra2 enumeration value in TMouseButton.
</short>
<descr/>
<version>
Added in LCL 3.0 as an alias to the constant in System.UITypes for FPC 3.2.3 
or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documentation. 
<link id="#rtl.system.uitypes.mbExtra2">mbExtra2</link> 
-->
</seealso>
</element>

<element name="fsAllStayOnTop">
<short>
Set of form styles which make a form stay on top.
</short>
<descr/>
<seealso>
<link id="TFormStyle"/>
</seealso>
</element>

<element name="fsAllNonSystemStayOnTop">
<short>
Set of form styles except those which make a form stay on top of all other 
forms of the system.
</short>
<seealso>
<link id="TFormStyle"/>
</seealso>
</element>

<element name="crHigh">
<short>Highest defined cursor constant (0).</short>
</element>
<element name="crDefault">
<short>
Indicates that the default cursor from the system should be utilized.
</short>
</element>
<element name="crNone">
<short>Indicates that the cursor should be invisible.</short>
</element>
<element name="crArrow">
<short>
The Arrow cursor, which is the most common and the default one in most cases.
</short>
</element>
<element name="crCross">
<short>
A cursor utilized for graphics, for pixel or rectangle selection, often in 
the shape of a cross.
</short>
</element>
<element name="crIBeam">
<short>
A text cursor, for setting insertion point. Often used in text editors.
</short>
</element>
<element name="crSize">
<short>
A generic sizing cursor, to indicate that here one may drag to resize 
something. Is the same as crSizeAll.
</short>
</element>
<element name="crSizeNESW">
<short>
A cursor for resizing which runs diagonally from NorthEast to SouthWest (-6).
</short>
</element>
<element name="crSizeNS">
<short>
A cursor for resizing which cursor runs from North to South (-7).
</short>
</element>
<element name="crSizeNWSE">
<short>
A cursor for resizing which cursor runs from NorthWest to SouthEast.
</short>
</element>
<element name="crSizeWE">
<short>
A cursor for resizing which has an arrow with two points, one to the left and 
another to the right, to indicate resizing possibility in both directions.
</short>
</element>
<element name="crSizeNW">
<short>
A cursor for resizing which has an arrow pointing to the left-top corner, to 
indicate resizing possibility in this direction.
</short>
</element>
<element name="crSizeN">
<short>
A cursor for resizing which has an arrow pointing upwards, to indicate 
resizing possibility in this direction.
</short>
</element>
<element name="crSizeNE">
<short>
A cursor for resizing which has an arrow pointing to the right-top corner, to 
indicate resizing possibility in this direction.
</short>
</element>
<element name="crSizeW">
<short>
A cursor for resizing which has an arrow pointing to the left, to indicate 
resizing possibility in this direction.
</short>
</element>
<element name="crSizeE">
<short>
A cursor for resizing which has an arrow pointing to the right, to indicate 
resizing possibility in this direction.
</short>
</element>
<element name="crSizeSW">
<short>
A cursor for resizing which has an arrow pointing to the left-bottom corner, 
to indicate resizing possibility in this direction.
</short>
</element>
<element name="crSizeS">
<short>
A cursor for resizing which has an arrow pointing downwards, to indicate 
resizing possibility in this direction.
</short>
</element>
<element name="crSizeSE">
<short>
A cursor for resizing which has an arrow pointing to the right-bottom corner, 
to indicate resizing possibility in this direction.
</short>
</element>
<element name="crUpArrow">
<short>Up Arrow cursor constant (-10).</short>
</element>
<element name="crHourGlass">
<short>
Busy cursor constant, utilized to indicate that one should wait while an 
action is done.
</short>
</element>
<element name="crDrag">
<short>
A cursor to indicate that one can drop a dragged item in this area.
</short>
</element>
<element name="crNoDrop">
<short>
A cursor to indicate that one cannot drop a dragged item in this area.
</short>
</element>
<element name="crHSplit">
<short>Horizontal Splitter cursor constant (-14).</short>
</element>
<element name="crVSplit">
<short>Vertical Split cursor constant (-15).</short>
</element>
<element name="crMultiDrag">
<short>Multiple Object dragging cursor constant (-16).</short>
</element>
<element name="crSQLWait">
<short>Waiting for SQL cursor constant (-17).</short>
</element>
<element name="crNo">
<short>Shows a negative sign. See also <link id="crNoDrop"/>.
</short>
</element>
<element name="crAppStart">
<short>Application starting cursor.</short>
</element>
<element name="crHelp">
<short>"What's This" Help cursor constant (-20).</short>
</element>
<element name="crHandPoint">
<short>Pointing hand cursor constant (-21).</short>
</element>
<element name="crSizeAll">
<short>All Directions sizing cursor constant (-22).</short>
</element>
<element name="crLow">
<short>Lowest defined cursor constant (-30).</short>
</element>

<element name="TCaptureMouseButtons">
<short>Set type used to store TMouseButton values.</short>
<descr>
<p>
<var>TCaptureMouseButtons</var> is a set type used to store 
<var>TMouseButton</var> enumeration values. TCaptureMouseButtons is the type 
used to implement the <var>CaptureMouseButtons</var> property in 
<var>TControl</var>.
</p>
</descr>
<seealso>
<link id="TMouseButton"/>
<link id="TControl.CaptureMouseButtons"/>
</seealso>
</element>

<element name="TWndMethod">
<short>Method type for WindowProc handlers.</short>
<descr/>
<seealso/>
</element>
<element name="TWndMethod.TheMessage">
<short>
Message with the command constant and key code processed in the handler.
</short>
</element>

<element name="TControlStyleType">
<short>
Enumerated type with values for features or behaviors for a control.
</short>
<descr>
<p>
<var>TControlStyleType</var> is an enumeration type with values that 
represent features or behaviors that can be enabled or disabled in a control. 
Zero or more values from TControlStyleType can be stored in the 
<var>TControlStyle</var> set type used to implement the 
<var>ControlStyle</var> property in <var>TControl</var>.
</p>
<p>
When an enumeration value is present in the set, it indicates that the 
corresponding feature or behavior is enabled for the control. Conversely, 
when the value is omitted from the set the feature or behavior is disabled.
</p>
</descr>
<seealso>
<link id="TControlStyle"/>
<link id="TControl.ControlStyle"/>
</seealso>
</element>
<element name="TControlStyleType.csAcceptsControls">
<short>
Indicates that one can add child controls to a control.
</short>
</element>
<element name="TControlStyleType.csCaptureMouse">
<short>Control focus and style changes when under the mouse cursor.</short>
</element>
<element name="TControlStyleType.csDesignInteractive">
<short>Control handles mouse events at design-time.</short>
</element>
<element name="TControlStyleType.csClickEvents">
<short>Control responds to mouse click events.</short>
</element>
<element name="TControlStyleType.csFramed">
<short>
Control has a 3D frame; used on scroll bars in the current LCL version.
</short>
</element>
<element name="TControlStyleType.csSetCaption">
<short>
Indicates that the Caption for a control is updated when a value is assigned 
to the Name property. As long as Name=Text, changing the Name will set the 
Caption. When, for example, a button's Name and Caption have the value 
'Button1' and the Name is changed to 'Button2' then the Caption is changed as 
well. When Name and Caption differ, this flag has no effect. This flag has no 
effect when loading the control using the LCL component streaming mechanism.
</short>
</element>
<element name="TControlStyleType.csOpaque">
<short>
Control is drawn with a non-transparent background; implementation is 
widgetset-specific.
</short>
</element>
<element name="TControlStyleType.csDoubleClicks">
<short>
Indicates that the control understands mouse double click events.
</short>
</element>
<element name="TControlStyleType.csTripleClicks">
<short>
Indicates that the control understands mouse triple click events.
</short>
</element>
<element name="TControlStyleType.csQuadClicks">
<short>
Indicates that the control understands mouse quadruple click events.
</short>
</element>
<element name="TControlStyleType.csFixedWidth">
<short>Indicates that the control cannot change its width.</short>
</element>
<element name="TControlStyleType.csFixedHeight">
<short>
Indicates that the control cannot change its height (e. g. a combo-box).
</short>
</element>
<element name="TControlStyleType.csNoDesignVisible">
<short>Indicates that the control is invisible in the form designer.</short>
</element>
<element name="TControlStyleType.csReplicatable">
<short>Control can be drawn using the TWinControl.PaintTo method.</short>
</element>
<element name="TControlStyleType.csNoStdEvents">
<short>
Key messages are handler by widgetset classes instead of control events.
</short>
</element>
<element name="TControlStyleType.csDisplayDragImage">
<short>
Display images from the drag imagelist during a drag operation over the 
control.
</short>
</element>
<element name="TControlStyleType.csReflector">
<short>
Control responds to size, focus, and dialog messages and can be used as an 
ActiveX control (Windows).
</short>
</element>
<element name="TControlStyleType.csActionClient">
<short>Control includes support for TBasicAction.</short>
</element>
<element name="TControlStyleType.csMenuEvents">
<short>Control responds to menu and menu item events.</short>
</element>
<element name="TControlStyleType.csNoFocus">
<short>Indicates that the control or form cannot receive focus.</short>
</element>
<element name="TControlStyleType.csNeedsBorderPaint">
<short>
Indicates that the client area for the control needs to be redrawn including 
its borders. LCL controls do not use this value in their control styles 
property. Implemented for JVCL controls and its theme engine.
</short>
</element>
<element name="TControlStyleType.csParentBackground">
<short>
Indicates whether the background for the parent control is used to fill the 
client area in the control. Used for controls which have a window handle for 
the parent control and do not use csOpaque in their control style. On some 
platforms (like WinXP and Windows 7), csParentBackground can be used to 
reduce flicker when the parent control is resized.
</short>
</element>
<element name="TControlStyleType.csDesignNoSmoothResize">
<short>WYSIWYG resizing is not used on the design surface.</short>
</element>
<element name="TControlStyleType.csDesignFixedBounds">
<short>Control cannot be moved or resized on the designer surface.</short>
</element>
<element name="TControlStyleType.csHasDefaultAction">
<short>
Control executes a default action when the Space or Enter key is pressed.
</short>
</element>
<element name="TControlStyleType.csHasCancelAction">
<short>
Control executes an action when the Escape key is pressed or the form/dialog 
is closed using the window decoration.
</short>
</element>
<element name="TControlStyleType.csNoDesignSelectable">
<short>Control cannot be selected at design-time.</short>
</element>
<element name="TControlStyleType.csOwnedChildrenNotSelectable">
<short>
Child controls owned by this control are not selectable in the designer.
</short>
</element>
<element name="TControlStyleType.csAutoSize0x0">
<short>
If the preferred size is 0x0 pixels then the control is auto-sized; the 
default minimum client size will be 1x1 pixels.
</short>
</element>
<element name="TControlStyleType.csAutoSizeKeepChildLeft">
<short>
When AutoSize is <b>True</b>, do not move child controls horizontally.
</short>
</element>
<element name="TControlStyleType.csAutoSizeKeepChildTop">
<short>
When AutoSize is <b>True</b>, do not move child controls vertically.
</short>
</element>
<element name="TControlStyleType.csRequiresKeyboardInput">
<short>
Indicates that a control requires keyboard input to be utilized by the user. 
Used for the Android (and other) platforms to activate the virtual keyboard 
when an active control needs to respond to input values. Used primarily for 
devices that do not have a hardware keyboard.
</short>
</element>

<element name="TControlStyle">
<short>
Set type used to store values from the TControlStyleType enumeration.
</short>
<descr>
<p>
<var>TControlStyle</var> is a set type used to store zero or more values from 
the <var>TControlStyleType</var> enumeration. Values from TControlStyleType 
are included in the set when the corresponding feature or behavior is enabled 
for a control.
</p>
<p>
TControlStyle is the type used to implement the ControlStyle property in 
TControl and descendent classes.
</p>
</descr>
<seealso>
<link id="TControlStyleType"/>
<link id="TControl.ControlStyle"/>
</seealso>
</element>

<element name="csMultiClicks">
<short>
Set of style values which require/provide multiple clicks on a control.
</short>
</element>

<element name="TControlStateType">
<short>State flags of a Control.</short>
<descr>
<p>
TControlStateType is an enumeration type which contains values that represent 
state information for control class instances, including:
</p>
<ul>
<li>csLButtonDown</li>
<li>csClicked</li>
<li>csPalette</li>
<li>csReadingState</li>
<li>csAlignmentNeeded</li>
<li>csFocusing</li>
<li>csCreating</li>
<li>csPaintCopy</li>
<li>csCustomPaint</li>
<li>csDestroyingHandle</li>
<li>csDocking</li>
<li>csVisibleSetInLoading</li>
</ul>
<p>
Values from the TControlStateType enumeration are stored in the TControlState 
type, and used to implement the ControlState property in TControl.
</p>
</descr>
<seealso>
<link id="TControlState"/>
<link id="TControl.ControlState"/>
</seealso>
</element>
<element name="TControlStateType.csLButtonDown">
<short>Indicates the Left mouse button was down for the control.</short>
</element>
<element name="TControlStateType.csClicked">
<short>
Indicates the control was clicked; occurs after button down/up processing.
</short>
</element>
<element name="TControlStateType.csPalette">
<short>Palettes are not currently implemented in LCL.</short>
</element>
<element name="TControlStateType.csReadingState">
<short>Indicates the ReadState method has been called for the control.</short>
</element>
<element name="TControlStateType.csFocusing">
<short>Indicates the focus for the control has been changed.</short>
</element>
<element name="TControlStateType.csCreating">
<short>Introduced for Delphi compatibility; not used in LCL.</short>
</element>
<element name="TControlStateType.csPaintCopy">
<short>Indicates a device context was copied in PaintControls.</short>
</element>
<element name="TControlStateType.csCustomPaint">
<short>
Indicates a custom paint method is used to draw the control; determines the 
handler called to paint the control.
</short>
</element>
<element name="TControlStateType.csDestroyingHandle">
<short>Used to suppress message processing when the control is freed.</short>
</element>
<element name="TControlStateType.csDocking">
<short>Indicates the Dock method has been called for a control.</short>
</element>
<element name="TControlStateType.csVisibleSetInLoading">
<short>
Indicates the control is being loaded using the LCL component streaming 
mechanism.
</short>
</element>

<element name="TControlState">
<short>Set of control states used in a control.</short>
<seealso>
<link id="TControlStateType"/>
</seealso>
</element>

<element name="TControlCanvas">
<short>
Base class which provides a canvas property used in graphic controls.
</short>
<descr>
<p>
<var>TControlCanvas</var> is a <var>TCanvas</var> descendant that implements 
the base class which provides a canvas used in graphic controls. 
TControlCanvas extends the ancestor class by including a property 
representing the <var>TControl</var> associated with the canvas, a window 
handle for the associated control, and the device context for the handle.
</p>
<p>
TControlCanvas is used in the implementation of classes like 
<var>TGraphicControl</var> and <var>TCustomControl</var>, and other visual 
controls.
</p>
</descr>
<seealso>
<link id="#lcl.graphics.TCanvas">TCanvas</link>
<link id="TGraphicControl"/>
<link id="TCustomControl"/>
</seealso>
</element>

<element name="TControlCanvas.FControl"/>
<element name="TControlCanvas.FDeviceContext"/>
<element name="TControlCanvas.FWindowHandle"/>

<element name="TControlCanvas.SetControl">
<short>Sets the value for the Control property.</short>
<descr/>
<seealso>
<link id="TControlCanvas.Control"/>
</seealso>
</element>
<element name="TControlCanvas.SetControl.AControl">
<short>New value for the Control property.</short>
</element>

<element name="TControlCanvas.CreateHandle">
<short>Ensures that a handle exists for the class instance.</short>
<descr>
<p>
Calls the inherited method on entry when a value has not been assigned to the 
Control property.
</p>
<p>
Otherwise, Control is used to check for an existing device context (HDC) for 
the class instance. When assigned, its value is copied into the Handle for 
the control.When not assigned, the HandleNeeded method in TWinControl is 
called to create the window handle and get its device context. If Control is 
not derived from TWinControl, its Parent is used to call the HandleNeeded 
method.
</p>
<p>
This is done to prevent resource leaks that might occur when directly 
accessing he window Handle before it has actually been allocated (recursive 
calls to the method).
</p>
<p>
If the device context remains unassigned, the GetDeviceContext method in 
Control is called to get the device context for the window Handle.
</p>
</descr>
<seealso>
<link id="TControlCanvas.Control"/>
<link id="TWinControl.HandleNeeded"/>
<link id="TWinControl.Handle"/>
<link id="TControl.GetDeviceContext"/>
<link id="#lcl.graphics.TCanvas.CreateHandle">TCanvas.CreateHandle</link>
</seealso>
</element>

<element name="TControlCanvas.GetDefaultColor">
<short>Gets the color value used for clDefault.</short>
<descr>
<p>
<var>GetDefaultColor</var> is used to resolve the default color 
(<var>clDefault</var>) to the TColor value used for the brush or font on the 
canvas. The <var>ADefaultColorType</var> argument indicates which value is 
needed in the return value. See <var>TDefaultColorType</var> for the values 
available in the argument.
</p>
<p>
GetDefaultColor is overridden in <var>TControlCanvas</var> to ensure that the 
<var>Control</var> is used (when assigned) to retrieve the default color by 
calling its GetDefaultColor method. If Control is not assigned, the inherited 
method is called to get the default color value (unresolved in the ancestor 
class).
</p>
</descr>
<seealso>
<link id="TControlCanvas.Control"/>
<link id="#lcl.graphics.TCanvas.GetDefaultColor">TCanvas.GetDefaultColor</link>
<link id="#lcl.controls.TControl.GetDefaultColor">TControl.GetDefaultColor</link>
<link id="#lcl.graphics.TDefaultColorType">TDefaultColorType</link>
</seealso>
</element>
<element name="TControlCanvas.GetDefaultColor.Result">
<short>
TColor value for the specified color type. clDefault when the Control has not 
been assigned for the class instance.
</short>
</element>
<element name="TControlCanvas.GetDefaultColor.ADefaultColorType">
<short>
Identifies whether the font or brush color is resolved in the method.
</short>
</element>

<element name="TControlCanvas.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the overridden constructor for the class instance. 
Create calls the inherited constructor, and sets the default unassigned 
values for the device context, window handle, and control used in the class 
instance. The device context and window handle are maintained in methods 
which use the respective members. Use the <var>Control</var> property to set 
the owner for the class instance.
</p>
</descr>
<seealso>
<link id="TControlCanvas.Control"/>
<link id="TControlCanvas.Destroy"/>
</seealso>
</element>

<element name="TControlCanvas.Destroy">
<short>Destructor for the class instance.</short>
<descr>
<p>
<var>Destroy</var> is the overridden destructor for the class instance. 
Destroy ensures that a device context allocated for the window handle in 
<var>Control</var> is freed prior calling the inherited destructor.
</p>
</descr>
<seealso>
<link id="TControlCanvas.Control"/>
<link id="TControlCanvas.Create"/>
</seealso>
</element>

<element name="TControlCanvas.FreeHandle">
<short>
Frees the Handle for the control canvas, and its device context when assigned.
</short>
<descr>
<p>
<var>FreeHandle</var> is an overridden method in TControlCanvas. It calls the 
inherited method on entry to set the value in <var>Handle</var> to 0 (the 
unassigned value). If a device context (DC) has been allocated for the window 
handle (HWND), the <var>ReleaseDC</var> routine is called to release the 
device context.
</p>
<p>
FreeHandle is called when a new value is assigned to the <var>Control</var> 
property, or when the class instance is freed.
</p>
</descr>
<seealso>
<link id="TControlCanvas.Destroy"/>
<link id="TControlCanvas.Control"/>
<link id="#lcl.graphics.TCanvas.Handle">TCanvas.Handle</link>
<link id="#lcl.graphics.TCanvas.FreeHandle">TCanvas.FreeHandle</link>
<link id="#lcl.lclintf.ReleaseDC">ReleaseDC</link>
</seealso>
</element>

<element name="TControlCanvas.ControlIsPainting">
<short>
Indicates if the Control has called but not completed its Paint method.
</short>
<descr>
<p>
<var>ControlIsPainting</var> is a <var>Boolean</var> function which indicates 
if the <var>Control</var> has called but not completed its <var>Paint</var> 
method. ControlIsPainting returns <b>True</b> when the Control has been 
assigned (contains a non-<b>Nil</b> value) and its 
<var>IsProcessingPaintMsg</var> method returns <b>True</b>.
</p>
<p>
ControlIsPainting is used in the implementation of the <var>CreateHandle</var> 
method.
</p>
</descr>
<seealso>
<link id="TControl.IsProcessingPaintMsg"/>
</seealso>
</element>
<element name="TControlCanvas.ControlIsPainting.Result">
<short><b>True</b> when the Control has been assigned is repainting.</short>
</element>

<element name="TControlCanvas.Control">
<short>The Control object for which the Canvas is used.</short>
<descr>
<p>
<var>Control</var> is a <var>TControl</var> property which represents the 
control associated with the canvas in the class instance. Setting the value 
in Control causes an existing Window handle (and its device context) in the 
class instance to be freed. The handle and its device context are recreated 
(eventually) when the control is displayed.
</p>
</descr>
<seealso>
<link id="TControl"/>
</seealso>
</element>

<element name="PHintInfo">
<short>Pointer to a THintInfo instance.</short>
<descr>
<p>
<var>PHintInfo</var> is a <var>Pointer</var> to a <var>THintInfo</var> 
instance. PHintInfo is the type passed as an argument to the 
<var>TControlShowHintEvent</var> event handler procedure, and the 
<var>DoOnShowHint</var> method in <var>TControl</var>.
</p>
</descr>
<seealso>
<link id="THintInfo"/>
<link id="TControlShowHintEvent"/>
<link id="TControl.DoOnShowHint"/>
</seealso>
</element>

<element name="THintInfo">
<short>
Contains content and state information for Hints displayed for a window or 
control.
</short>
<descr/>
<seealso/>
</element>
<element name="THintInfo.HintControl">
<short>Control for the hint display.</short>
<descr/>
<seealso/>
</element>
<element name="THintInfo.HintWindowClass">
<short>Window class for the hint display.</short>
<descr/>
<seealso/>
</element>
<element name="THintInfo.HintPos">
<short>TPoint with the screen coordinates for the hint display.</short>
<descr/>
<seealso/>
</element>
<element name="THintInfo.HintMaxWidth">
<short>Maximum width for the hint.</short>
<descr/>
<seealso/>
</element>
<element name="THintInfo.HintColor">
<short>Color for the hint window.</short>
<descr/>
<seealso/>
</element>
<element name="THintInfo.CursorRect">
<short>Rectangle with the coordinates and size for the cursor.</short>
<descr/>
<seealso/>
</element>
<element name="THintInfo.CursorPos">
<short>TPoint with the location for the mouse cursor.</short>
<descr/>
<seealso/>
</element>

<element name="THintInfo.ReshowTimeout">
<short>
If set to a value greater than Zero (0), call after value milliseconds 
OnShowHint again.
</short>
<descr>
Used to update the hint text display after the specified delay while it is 
showing.
</descr>
<seealso/>
</element>

<element name="THintInfo.HideTimeout">
<short>Duration in milliseconds for the hint display.</short>
<descr/>
<seealso/>
</element>

<element name="THintInfo.HintStr">
<short>
String value displayed as a hint for the associated control.
</short>
<descr/>
<seealso/>
</element>

<element name="THintInfo.HintData">
<short>
Pointer to the data used to derive the hint text.
</short>
<descr/>
<seealso/>
</element>

<element name="TImageListHelper">
<short>
Helper class for TCustomImageList useful for images on TControl instances.
</short>
<descr>
<p>
<var>TImageListHelper</var> is a helper class for 
<var>TCustomImageList</var>. TImageListHelper extends TCustomImageList to 
provide additional properties and methods that are useful when working with 
<var>TControl</var> class instances.
</p>
<p>
Use the overloaded <var>DrawForControl</var> method to render an image from 
the multiple resolution image list to a control canvas.
</p>
<p>
Use the <var>ResolutionForControl</var> property to access a scaled image 
resolution with images of a specified width used on a control instance.
</p>
</descr>
<seealso>
<link id="TImageListHelper.DrawForControl"/>
<link id="TImageListHelper.ResolutionForControl"/>
<link id="#lcl.imglist.TCustomImageList">TCustomImageList</link>
<link id="TControl"/>
</seealso>
</element>

<element name="TImageListHelper.GetResolutionForControl">
<short>Gets the value for the ResolutionForControl property.</short>
<descr/>
<seealso>
<link id="TImageListHelper.ResolutionForControl"/>
</seealso>
</element>
<element name="TImageListHelper.GetResolutionForControl.Result">
<short>Value for the property.</short>
</element>
<element name="TImageListHelper.GetResolutionForControl.AImageWidth">
<short>ImageWidth desired in the scaled image resolution.</short>
</element>
<element name="TImageListHelper.GetResolutionForControl.AControl">
<short>
Control which provides the PPI display density for scaled images in the 
resolution.
</short>
</element>

<element name="TImageListHelper.DrawForControl">
<short>
Draws an image scaled to the display density (PPI) for the specified control.
</short>
<descr>
<p>
<var>DrawForControl</var> is an overloaded procedure used to draw the 
specified image scaled to the display density (PPI) for the specified 
control. DrawForControl calls the <var>DrawForPPI</var> method in the image 
list to render the selected image using the display density and drawing 
effect required.
</p>
<p>
<var>ACanvas</var> contains the control canvas where the image is drawn. 
<var>AX</var> and <var>AY</var> contains the left and top coordinates on the 
canvas where the image is drawn.
</p>
<p>
<var>AIndex</var> specifies the ordinal position in the scaled image list for 
the image drawn in the method.
</p>
<p>
<var>AImageWidthAt96PPI</var> contains the width for the image at 96 PPI. The 
actual image width is scaled to the display density using scaling factor 
required for the control.
</p>
<p>
<var>AControl</var> contains the <var>TControl</var> instance that provides 
the display density and canvas scaling factor required for the image.
</p>
<p>
When <var>AEnabled</var> is <b>True</b>, the image is drawn using its Enabled 
state. Otherwise, it is rendered using the disabled state.
</p>
<p>
<var>ADrawEffect</var> contains the <var>TGraphicsDrawEffect</var> used when 
rendering the image to the control canvas.
</p>
</descr>
<seealso>
<link id="#lcl.imglist.TCustomImageList.DrawForPPI">TCustomImageList.DrawForPPI</link>
</seealso>
</element>
<element name="TImageListHelper.DrawForControl.ACanvas">
<short>Canvas where the image is drawn.</short>
</element>
<element name="TImageListHelper.DrawForControl.AX">
<short>Horizontal position on the canvas where the image is drawn.</short>
</element>
<element name="TImageListHelper.DrawForControl.AY">
<short>Vertical position on the canvas where the image is drawn.</short>
</element>
<element name="TImageListHelper.DrawForControl.AIndex">
<short>Ordinal position for the image drawn in the method.</short>
</element>
<element name="TImageListHelper.DrawForControl.AImageWidthAt96PPI">
<short>Image width using the standard display density.</short>
</element>
<element name="TImageListHelper.DrawForControl.AControl">
<short>
Control with the display density (Font PPI) and canvas scaling factor used in 
the method.
</short>
</element>
<element name="TImageListHelper.DrawForControl.AEnabled">
<short>
Indicates the image is drawn in the enabled state when <b>True</b>.
</short>
</element>
<element name="TImageListHelper.DrawForControl.ADrawEffect">
<short>Indicates the TGraphicsDrawEffect applied to the image.</short>
</element>

<element name="TImageListHelper.ResolutionForControl">
<short>
Provides access to an image resolution with the specified width scaled to the 
display density for a control.
</short>
<descr>
<p>
<var>ResolutionForControl</var> is a read-only 
<var>TScaledImageListResolution</var> property which provides access to a 
scaled image resolution suitable for the control in <var>AControl</var>. 
<var>AImageWidth</var> contains the image width requested from the 
multi-resolution image list. <var>AControl</var> contains the 
<var>TControl</var> instance which provides the display density (PPI) and the 
scaling factor used to generate the scaled image resolution.
</p>
</descr>
<seealso>
<link id="#lcl.imglist.TScaledImageListResolution">TScaledImageListResolution</link>
<link id="TControl"/>
<link id="TControlCanvas"/>
</seealso>
</element>
<element name="TImageListHelper.ResolutionForControl.AImageWidth">
<short>Image width requested in the image list </short>
</element>
<element name="TImageListHelper.ResolutionForControl.AControl">
<short>
Control which provides the display density and scaling factor for the scaled 
image resolution.
</short>
</element>

<element name="TDragImageListResolution">
<short>
Implements an image list resolution with features used in Drag and Drop 
operations.
</short>
<descr>
<p>
<var>TDragImageListResolution</var> is a 
<var>TCustomImageListResolution</var> descendant which implements an image 
list resolution with features used in Drag and Drop operations. 
TDragImageListResolution is used in the implementation of 
<var>TDragImageList</var>.
</p>
</descr>
<seealso>
<link id="TDragImageList.DraggingResolution"/>
<link id="TDragImageList.Resolution"/>
</seealso>
</element>

<element name="TDragImageListResolution.FDragging"/>
<element name="TDragImageListResolution.FDragHotspot"/>
<element name="TDragImageListResolution.FOldCursor"/>
<element name="TDragImageListResolution.FLastDragPos"/>
<element name="TDragImageListResolution.FLockedWindow"/>

<element name="TDragImageListResolution.GetImageList">
<short>Gets the value for the ImageList property.</short>
<descr/>
<seealso>
<link id="TDragImageListResolution.ImageList"/>
</seealso>
</element>
<element name="TDragImageListResolution.GetImageList.Result">
<short>Value for the property.</short>
</element>

<element name="TDragImageListResolution.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

<element name="TDragImageListResolution.ImageList">
<short>List with images used in Drag and Drop operations.</short>
<descr>
<p>
<var>ImageList</var> is a read-only <var>TDragImageList</var> property which 
provides access to the images used for Drag and Drag operations, and methods 
used to render the images.
</p>
</descr>
<seealso>
<link id="TDragImageList"/>
<link id="TControl.GetDragImages"/>
<link id="TControl.ControlStyle"/>
<link id="TControlStyleType"/>"
</seealso>
</element>

<element name="TDragImageListResolution.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the overridden constructor for 
<var>TDragImageListResolution</var>. Create calls the inherited constructor 
using TheOwner as the owner for the class instance. Create sets the initial 
the values for internal members in the class instance.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TComponent.Create">TComponent.Create</link>
</seealso>
</element>
<element name="TDragImageListResolution.Create.TheOwner">
<short>Owner of the new class instance.</short>
</element>

<element name="TDragImageListResolution.GetHotSpot">
<short>Gets the HotSpot for the image resolution.</short>
<descr>
<p>
<var>GetHotSpot</var> is an overridden <var>TPoint</var> function which gets 
the <var>HotSpot</var> for the image list resolution. GetHotSpot uses the 
value from the <var>DragHotspot</var> property. It contains the screen 
coordinates where the Drag and Drop operation was started. X is the 
horizontal position, and Y is the vertical position in the <var>TPoint</var> 
type.
</p>
</descr>
<seealso>
<link id="TDragImageListResolution.DragHotspot"/>
</seealso>
</element>
<element name="TDragImageListResolution.GetHotSpot.Result">
<short>Value for the HotSpot.</short>
</element>

<element name="TDragImageListResolution.BeginDrag">
<short>
Starts display of images in the resolution for a Drag and Drop operation.
</short>
<descr>
<p>
<var>BeginDrag</var> is a <var>Boolean</var> function used to start display 
of images in the resolution for a Drag and Drop operation. The return value 
is <b>True</b> if the widgetset successfully received the BeginDrag 
notification.
</p>
<remark>
No actions are performed in the method if the widgetset class does note 
successfully start the drag operation.
</remark>
<p>
BeginDrag calls the <var>DragLock</var> method to lock the window handle for 
the control, and to start displaying the drag image for the operation. The 
current screen cursor is captured, and the <var>DragCursor</var> in 
<var>ImageList</var> is displayed for the operation.
</p>
</descr>
<seealso>
<link id="TDragImageListResolution.Dragging"/>
<link id="TDragImageListResolution.EndDrag"/>
<link id="TDragImageListResolution.DragLock"/>
<link id="TDragImageListResolution.ImageList"/>
<link id="TDragImageList.DragCursor"/>
</seealso>
</element>
<element name="TDragImageListResolution.BeginDrag.Result">
<short><b>True</b> if the Drag operation was successfully started.</short>
</element>
<element name="TDragImageListResolution.BeginDrag.Window">
<short>Window handle where images are displayed for the operation.</short>
</element>
<element name="TDragImageListResolution.BeginDrag.X">
<short>Horizontal screen position where the operation was started.</short>
</element>
<element name="TDragImageListResolution.BeginDrag.Y">
<short>Vertical screen position where the operation was started.</short>
</element>

<element name="TDragImageListResolution.DragLock">
<short>
Shows the Drag image and optionally locks the Window handle during the Drag 
operation.
</short>
<descr/>
<seealso/>
</element>
<element name="TDragImageListResolution.DragLock.Result">
<short>
<b>True</b> if the drag operation was started or the drag image position was 
updated.
</short>
</element>
<element name="TDragImageListResolution.DragLock.Window">
<short>
Window handle used as the lock handle when not already assigned.
</short>
</element>
<element name="TDragImageListResolution.DragLock.X">
<short>Horizontal coordinate for the drag image.</short>
</element>
<element name="TDragImageListResolution.DragLock.Y">
<short>Vertical coordinate for the drag image.</short>
</element>

<element name="TDragImageListResolution.DragMove">
<short>Moves the drag image to the specified position.</short>
<descr>
<p>
<var>DragMove</var> is a <var>Boolean</var> function used to move the drag 
image in the resolution to the position specified in the X and Y arguments. 
</p>
<p>
The return value indicates that the Dragging property is already set to 
<b>True</b>, and that the widgetset class was able to perform the move 
operation. An internal member with the last position for the drag image is 
updated when the method is successfully completed.
</p>
<p>
DragMove is called from the corresponding method in TDragImageList.
</p>
</descr>
<seealso>
<link id="TDragImageListResolution.ImageList"/>
<link id="TDragImageList.DraggingResolution"/>
<link id="TDragImageList.DragMove"/>
</seealso>
</element>
<element name="TDragImageListResolution.DragMove.Result">
<short>
<b>True</b> if the drag image is already active and its position is updated 
in the widgetset class.
</short>
</element>
<element name="TDragImageListResolution.DragMove.X">
<short>
New horizontal coordinate for the drag image.
</short>
</element>
<element name="TDragImageListResolution.DragMove.Y">
<short>
New vertical coordinate for the drag image.
</short>
</element>

<element name="TDragImageListResolution.DragUnlock">
<short>
Hides the Drag image and removes the update lock for the Window.
</short>
<descr/>
<seealso/>
</element>

<element name="TDragImageListResolution.EndDrag">
<short>
Removes the drag lock and restores the saved cursor when the drag operation 
has ended.
</short>
<descr>
<p>
<var>EndDrag</var> is a <var>Boolean</var> function used to remove the drag 
image from the image resolution. EndDrag calls the DragUnlock method to hide 
the drag image, and to reset the internal lock window and drag position used 
in the class instance. The corresponding method (EndDrag) in the widgetset 
class is called.
</p>
<p>
Dragging is set to <b>False</b> prior to exit from the method. EndDrag 
restores the previous cursor shape by calling the EndTempCursor method in the 
Screen singleton.
</p>
<p>
No actions are performed in the method if Dragging is set to <b>False</b>.
</p>
<p>
The return value contains the value from the Dragging property on entry into 
the method.
</p>
<p>
EndDrag is called from the EndDrag method in TDragImageList.
</p>
</descr>
<seealso>
<link id="TDragImageListResolution.Dragging"/>
<link id="TDragImageListResolution.DragUnlock"/>
<link id="TDragImageList.EndDrag"/>
</seealso>
</element>
<element name="TDragImageListResolution.EndDrag.Result">
<short>
Value in the Dragging property on entry.
</short>
</element>

<element name="TDragImageListResolution.HideDragImage">
<short>Notifies the widgetset class to hide the drag image.</short>
<descr>
<p>
Hides the drag image in the resolution without unlocking the window. 
No actions are performed in the method if Dragging is set to <b>False</b>.
</p>
<p>
HideDragImage is called from the HideDragImage method in TDragImageList.
</p>
</descr>
<seealso>
<link id="TDragImageListResolution.Dragging"/>
<link id="TDragImageList.HideDragImage"/>
</seealso>
</element>

<element name="TDragImageListResolution.ShowDragImage">
<short>
Notifies the widgetset class to display the drag image for the resolution.
</short>
<descr>
<p>
Calls the ShowDragImage method in the widgetset class to display the drag image 
for the image resolution if its Dragging property is set to <b>True</b>. The 
previous position for the drag image, stored in an internal member, is used to 
send the image position to the widgetset class.
</p>
<p>
No actions are performed in the method if Dragging is set to <b>False</b>.
</p>
<p>
ShowDragImage is called from the ShowDragImage method in TDragImageList, and 
occurs after the active image resolution in the image list has been determined.
</p>
</descr>
<seealso>
<link id="TDragImageListResolution.Dragging"/>
<link id="TDragImageList.ShowDragImage"/>
<link id="#lcl.imglist.TCustomImageList.Resolutions">TCustomImageList.Resolutions</link>
</seealso>
</element>

<element name="TDragImageListResolution.DragHotspot">
<short>Contains the mouse position for the drag image.</short>
<descr>
<p>
<var>DragHotspot</var> is a <var>TPoint</var> property which contains the 
mouse position for the Drag hotspot. It contains the value read and written 
using the DragHotspot property in the TDragImageList for the image 
resolution. It is also updated when the SetDragImage method in TDragImageList 
is called to update the index position for the drag image.
</p>
</descr>
<seealso>
<link id="TDragImageList.DragHotspot"/>
<link id="TDragImageList.SetDragImage"/>
</seealso>
</element>

<element name="TDragImageListResolution.Dragging">
<short>
Indicates that BeginDrag has been called for the image resolution.
</short>
<descr/>
<seealso>
<link id="TDragImageList.Dragging"/>
</seealso>
</element>

<element name="TDragImageList">
<short>A multi-resolution list of Images used during Drag operations.</short>
<descr>
<p>
<var>TDragImageList</var> is a <var>TCustomImageList</var> descendant which 
provides a multi-resolution container for images displayed when a drop-drop 
operation is active. A drag image is shown when a drag operation is active 
and a DragImageList has been supplied.
</p>
<p>
TDragImageList overrides and reimplements methods from the ancestor to 
support the TDragImageListResolution type used in the image Resolution 
property. Additional properties and methods are provided to work with a drag 
image and its hot spot when the operation is started or stopped, and when the 
mouse position is changed.
</p>
<p>
In drag-dock operations, a drag image is not typically displayed since the 
DockRect frame already provides visual feedback.
</p>
<p>
This is a general overview of the usage of this class:
</p>
<ul>
<li>
SetDragImage selects an image from the list, and defines the hotspot within 
this image. Te hotspot typically is the offset of the mouse position to the 
origin of the dragged control.
</li>
<li>
BeginDrag starts dragging, the image is shown at the starting location.
</li>
<li>
DragMove moves the image.
</li>
<li>
EndDrag stops dragging, the image is removed from the screen.
</li>
</ul>
<p>
TDragImageList is the ancestor for the TImageList class defined in the LCL. 
It is also the type returned from the GetDragImages method in TControl.
</p>
</descr>
<seealso>
<link id="TImageList"/>
<link id="TControl.GetDragImages"/>
<link id="#lcl.imglist.TCustomImageList">TCustomImageList</link>
</seealso>
</element>

<element name="TDragImageList.FDragCursor"/>
<element name="TDragImageList.FDragging"/>
<element name="TDragImageList.FDragHotspot"/>
<element name="TDragImageList.FImageIndex"/>

<element name="TDragImageList.FLastDragPos">
<short>Position where the image was last painted.</short>
</element>

<element name="TDragImageList.FLockedWindow">
<short>The window whose updates are locked while dragging.</short>
</element>

<element name="TDragImageList.FOldCursor"/>

<element name="TDragImageList.SetDragCursor">
<short>Sets the value for the DragCursor property.</short>
<descr/>
<seealso>
<link id="TDragImageList.DragCursor"/>
</seealso>
</element>
<element name="TDragImageList.SetDragCursor.AValue">
<short>New value for the DragCursor property.</short>
</element>

<element name="TDragImageList.GetDragHotSpot">
<short>Gets the value for the DragHotSpot property.</short>
<descr/>
<seealso>
<link id="TDragImageList.DragHotSpot"/>
<link id="#lcl.imglist.TCustomImageList.GetHotSpot">TCustomImageList.GetHotSpot</link>
</seealso>
</element>
<element name="TDragImageList.GetDragHotSpot.Result">
<short>Value for the DragHotSpot property.</short>
</element>

<element name="TDragImageList.SetDragHotspot">
<short>Sets the value for the DragHotSpot property.</short>
<descr/>
<seealso>
<link id="TDragImageList.DragHotSpot"/>
</seealso>
</element>
<element name="TDragImageList.SetDragHotspot.ADragHotSpot">
<short>New value for the DragHotSpot property.</short>
</element>

<element name="TDragImageList.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

<element name="TDragImageList.Initialize">
<short>initializes the cursor shape and image index for the list.</short>
<descr>
<p>
Initialize is an overridden method in TDragImageList. It calls the inherited 
method on entry. It sets the default values in DragCursor (crNone) and the 
internal selected image index (0).
</p>
</descr>
<seealso>
<link id="#lcl.imglist.TCustomImageList.Initialize">TCustomImageList.Initialize</link>
</seealso>
</element>

<element name="TDragImageList.BeginDrag">
<short>Start dragging an image; returns <b>True</b> if successful.</short>
<descr>
Locks a window for updates, remembers the current cursor shape, and sets the 
new cursor shape.
</descr>
<seealso/>
</element>
<element name="TDragImageList.BeginDrag.Result">
<short><b>True</b> if successful.</short>
</element>
<element name="TDragImageList.BeginDrag.Window">
<short>The associated window.</short>
</element>
<element name="TDragImageList.BeginDrag.X">
<short>The mouse position.</short>
</element>
<element name="TDragImageList.BeginDrag.Y">
<short>The mouse position.</short>
</element>

<element name="TDragImageList.DragLock">
<short>Show drag image during drag operation.</short>
<descr/>
<seealso/>
</element>
<element name="TDragImageList.DragLock.Result">
<short><b>True</b> if Dragging and image shown.</short>
</element>
<element name="TDragImageList.DragLock.Window">
<short>The locked window.</short>
</element>
<element name="TDragImageList.DragLock.XPos">
<short>The mouse position.</short>
</element>
<element name="TDragImageList.DragLock.YPos">
<short>The mouse position.</short>
</element>

<element name="TDragImageList.DragMove">
<short>Shows the drag image at a new location.</short>
<descr/>
<seealso/>
</element>
<element name="TDragImageList.DragMove.Result">
<short><b>True</b> if Dragging and image moved.</short>
</element>
<element name="TDragImageList.DragMove.X">
<short>The new mouse position.</short>
</element>
<element name="TDragImageList.DragMove.Y">
<short>The new mouse position.</short>
</element>

<element name="TDragImageList.DragUnlock">
<short>Hide the drag image.</short>
<descr/>
<seealso/>
</element>

<element name="TDragImageList.EndDrag">
<short>Finish dragging of the image, restore the old cursor shape.</short>
<descr/>
<seealso/>
</element>
<element name="TDragImageList.EndDrag.Result">
<short><b>True</b> when dragging was started before.</short>
</element>

<element name="TDragImageList.HideDragImage">
<short>Hides the drag image without unlocking the window.</short>
<descr>
<p>
Calls the <var>HideDragImage</var> method in <var>DraggingResolution</var>. 
No actions are performed in the method when an image resolution is not 
available in the DraggingResolution property.
</p>
</descr>
<seealso/>
</element>

<element name="TDragImageList.SetDragImage">
<short>Set index of dragged image and hotspot.</short>
<descr/>
<seealso/>
</element>
<element name="TDragImageList.SetDragImage.Result">
<short>Always <b>True</b>.</short>
</element>
<element name="TDragImageList.SetDragImage.Index">
<short>List index of the image to use.</short>
</element>
<element name="TDragImageList.SetDragImage.HotSpotX">
<short>Offset from mouse position to image position.</short>
</element>
<element name="TDragImageList.SetDragImage.HotSpotY">
<short>Offset from mouse position to image position.</short>
</element>

<element name="TDragImageList.ShowDragImage">
<short>Displays the drag image.</short>
<descr>
<p>
Calls the <var>ShowDragImage</var> method in <var>DraggingResolution</var>. 
No actions are performed in the method when an image resolution is not 
available in the DraggingResolution property.
</p>
</descr>
<seealso/>
</element>

<element name="TDragImageList.DragCursor">
<short>The cursor shape to use while dragging.</short>
<descr/>
<seealso/>
</element>

<element name="TDragImageList.DragHotspot">
<short>
The position of the HotSpot image, i.e. the offset to the mouse position 
while dragging.
</short>
<descr/>
<seealso/>
</element>

<element name="TDragImageList.Dragging">
<short><b>True</b> if dragging in progress.</short>
<descr/>
<seealso/>
</element>

<element name="TDragImageList.DraggingResolution">
<short>
Gets the scaled image resolution with the drag images for the list.
</short>
<descr/>
<seealso/>
</element>

<element name="TDragImageList.Resolution">
<short>Gets the image resolution for the specified image width.</short>
<descr>
<p>
<var>Resolution</var> is a read-only indexed 
<var>TDragImageListResolution</var> property which provides the image 
resolution for images with the width specified in <var>AImageWidth</var>. 
Reading the property value causes the image resolution to be cast to the 
required <var>TDragImageListResolution</var> type.
</p>
</descr>
<seealso/>
</element>
<element name="TDragImageList.Resolution.AImageWidth">
<short>Image width requested in the image resolution.</short>
</element>

<element name="TKeyEvent">
<short>Defines an event handler for key events.</short>
<descr>
<p>
<var>TKeyEvent</var> is an object procedure type which specifies a handler 
for key events.
</p>
<p>
<var>TKeyEvent</var> is the type used to implement the <var>OnKeyDown</var> 
and <var>OnKeyUp</var> event handlers in <var>TWinControl</var>. Applications 
must implement an object procedure using the signature for the event, and 
assign it to the event handler to respond to the notification.
</p>
<p>
See <link id="TKeyPressEvent"/> for the handler used to implement OnKeyPress 
events.
</p>
</descr>
</element>
<seealso>
<link id="TWinControl.OnKeyDown"/>
<link id="TWinControl.OnKeyUp"/>
<link id="TControl.AddHandlerOnKeyDown"/>
<link id="TControl.AddHandlerOnKeyUp"/>
<link id="TKeyPressEvent"/>
</seealso>
<element name="TKeyEvent.Sender">
<short>TObject for the key event.</short>
</element>
<element name="TKeyEvent.Key">
<short>ScanCode for the key in the event.</short>
</element>
<element name="TKeyEvent.Shift">
<short>TShiftState modifier for the specified key.</short>
</element>

<element name="TKeyPressEvent">
<short>Specifies an event handler for key press events.</short>
<descr>
<p>
<var>TKeyPressEvent</var> is an object procedure type that defines an event 
handler for key press events.
</p>
<p>
<var>TKeyPressEvent</var> is the type used to implement the 
<var>OnKeyPress</var> event handler in <var>TWinControl</var>. Applications 
must implement an object procedure using the signature for the event handler, 
and assign it to the property to respond to the event notification.
</p>
</descr>
<seealso>
<link id="TWinControl.OnKeyPress"/>
</seealso>
</element>
<element name="TKeyPressEvent.Sender">
<short>TObject for the event notification.</short>
</element>
<element name="TKeyPressEvent.Key">
<short>Character value for the key press in the event notification.</short>
</element>

<element name="TUTF8KeyPressEvent">
<short>Specifies an event handler for UTF-8-encoded key press events.</short>
<descr>
<p>
<var>TUTF8KeyPressEvent</var> is an object procedure type which specifies an 
event handler for UTF-8-encoded key press events.
</p>
<p>
<var>TUTF8KeyPressEvent</var> is the type used to implement the 
<var>OnUTF8KeyPress</var> event handler in <var>TWinControl</var>. 
Applications must implement an object procedure using the signature for the 
event handler, and assign it to the property to respond to the event 
notification.
</p>
</descr>
<seealso>
<link id="TWinControl.OnUTF8KeyPress"/>
</seealso>
</element>
<element name="TUTF8KeyPressEvent.Sender">
<short>TObject for the event notification.</short>
</element>
<element name="TUTF8KeyPressEvent.UTF8Key">
<short>Value for the UTF-8-encoded character in the key press event.</short>
</element>

<element name="TMouseEvent">
<short>
Specifies an event handler used to respond to mouse button events.
</short>
<descr>
<p>
<var>TMouseEvent</var> is an object procedure type which specifies an event 
handler for mouse button events.
</p>
<p>
<var>TMouseEvent</var> is the type used to implement the 
<var>OnMouseDown</var> and <var>OnMouseUp</var> event handlers in 
<var>TControl</var>. Applications must implement an object procedure using 
the signature for the event handler, and assign it to the property to respond 
to the event notification.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseDown"/>
<link id="TControl.OnMouseUp"/>
</seealso>
</element>
<element name="TMouseEvent.Sender">
<short>TObject for the event notification.</short>
</element>
<element name="TMouseEvent.Button">
<short>Mouse button for the event notification.</short>
</element>
<element name="TMouseEvent.Shift">
<short>Modifier applied to the mouse button.</short>
</element>
<element name="TMouseEvent.X">
<short>Horizontal position for the mouse cursor in the button event.</short>
</element>
<element name="TMouseEvent.Y">
<short>Vertical position for the mouse cursor in the button event.</short>
</element>

<element name="TMouseMoveEvent">
<short>
Specifies an event handler used to respond to mouse movement events.
</short>
<descr/>
<seealso/>
</element>
<element name="TMouseMoveEvent.Sender">
<short>TObject for the event notification.</short>
</element>
<element name="TMouseMoveEvent.Shift">
<short>Key modifier in effect for the event.</short>
</element>
<element name="TMouseMoveEvent.X">
<short>Horizontal mouse coordinates.</short>
</element>
<element name="TMouseMoveEvent.Y">
<short>Vertical mouse coordinates.</short>
</element>

<element name="TMouseWheelEvent">
<short>
Specifies an event handler used to respond to mouse wheel events.
</short>
<descr/>
<seealso/>
</element>
<element name="TMouseWheelEvent.Sender">
<short>The control under the mouse.</short>
</element>
<element name="TMouseWheelEvent.Shift">
<short>State of the modifier keys and mouse buttons.</short>
</element>
<element name="TMouseWheelEvent.WheelDelta">
<short>How many notches the wheel has been turned.</short>
</element>
<element name="TMouseWheelEvent.MousePos">
<short>The mouse position, in client coordinates.</short>
</element>
<element name="TMouseWheelEvent.Handled">
<short>Set Handled to <b>True</b> when the event was handled.</short>
</element>

<element name="TMouseWheelUpDownEvent">
<short>Type of OnMouseWheelUp/Down event handlers.</short>
<descr/>
<seealso/>
</element>
<element name="TMouseWheelUpDownEvent.Sender">
<short>The control under the mouse.</short>
</element>
<element name="TMouseWheelUpDownEvent.Shift">
<short>State of the modifier keys and mouse buttons.</short>
</element>
<element name="TMouseWheelUpDownEvent.MousePos">
<short>The mouse position, in client coordinates.</short>
</element>
<element name="TMouseWheelUpDownEvent.Handled">
<short>Set Handled to <b>True</b> when the event was handled.</short>
</element>

<element name="TGetDockCaptionEvent">
<short>
Specifies an event handler used to get the caption for a docked control.
</short>
<descr>
<p>
<var>TGetDockCaptionEvent</var> is an object procedure type which specifies 
an event handler used to get the caption for a docked control. It allows a 
value other than the Caption for a control to be displayed when a control is 
docked.
</p>
<p>
Use <var>AControl</var> to examine properties for the docked control. Assign 
a value to the <var>ACaption</var> argument to set the docking caption for 
the control.
</p>
<p>
<var>TGetDockCaptionEvent</var> is the type used to implement the 
<var>OnGetDockCaption</var> event handler in <var>TWinControl</var>. 
Applications must implement an object procedure using the signature for the 
type, and assign it to the property to allow responding to the event 
notification.
</p>
</descr>
<seealso>
<link id="TWinControl.OnGetDockCaption"/>
<link id="TWinControl."/>
</seealso>
</element>
<element name="TGetDockCaptionEvent.Sender">
<short>TObject for the event notification.</short>
</element>
<element name="TGetDockCaptionEvent.AControl">
<short>Control with the default caption value.</short>
</element>
<element name="TGetDockCaptionEvent.ACaption">
<short>Caption to use for the docked control.</short>
</element>

<element name="TDragKind">
<short>
Indicates whether the control performs drag-drop or drag-dock operation.
</short>
<descr>
<p>
<var>TDragKind</var> is an enumeration type with values that indicate the 
action performed when the mouse is used to start a drag operation.
</p>
<p>
TDragKind is the type used to implement the Dragkind property in TControl.
</p>
</descr>
<version>
Modified in LCL 3.0 to be ab alias to TDragKind in System.UITypes for FPC 
3.2.3 or higher.
</version>
<seealso>
<link id="TControl.DragKind"/>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.TDragKind">TDragKind</link> 
-->
</seealso>
</element>
<element name="TDragKind.dkDrag">
<short>Drag operation is for drag-and-drop.</short>
</element>
<element name="TDragKind.dkDock">
<short>Drag operation is for drag-and-dock.</short>
</element>

<element name="TDragMode">
<short>
Indicates whether a drag operation can start automatically.
</short>
<descr/>
<version>
Modified in LCL 3.0 to be an alias to TDragMode in System.UITypes for FPC 
3.2.3 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.TDragMode">TDragMode</link> 
-->
</seealso>
</element>
<element name="TDragMode.dmManual">
<short>Dragging can start only by explicit code.</short>
</element>
<element name="TDragMode.dmAutomatic">
<short>
Dragging starts when the left mouse button is pressed on the control.
</short>
</element>

<element name="TDragState">
<short>
Values representing State changes for a drag operation.
</short>
<descr>
These values are sent in drag messages, allowing the control to perform 
special actions when the mouse moves over, enters, or leaves the control.
</descr>
<version>
Modified in LCL 3.0 to be an alias to TDragState in System.UITypes for FPC 
3.2.3 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.TDragState">TDragState</link> 
-->
</seealso>
</element>
<element name="TDragState.dsDragEnter">
<short>Mouse has just entered the control.</short>
</element>
<element name="TDragState.dsDragLeave">
<short>Mouse has just left the control.</short>
</element>
<element name="TDragState.dsDragMove">
<short>Mouse is moving over the control.</short>
</element>

<element name="TDragMessage">
<short>Message types used in DragManager.</short>
<descr>
<p>
All messages are sent to the target control, except dmDragDrop and 
dmDragCancel is sent to the source control.
</p>
<dl>
<dt>dmDragEnter</dt>
<dd>Mouse enters control</dd>
<dt>dmDragLeave</dt>
<dd>Mouse leaves control</dd>
<dt>dmDragMove</dt>
<dd>Mouse moves over control (after dmDragEnter)</dd>
<dt>dmDragDrop</dt>
<dd>Control dropped</dd>
<dt>dmDragCancel</dt>
<dd>Dragging aborted</dd>
<dt>dmFindTarget</dt>
<dd>Find child control under the mouse</dd>
</dl>
</descr>
<version>
Modified in LCL 3.0 to be an alias to TDragMessage in System.UITypes for FPC 
3.2.3 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in RTL documentation. 
<link id="#rtl.system.uitypes.TDragMessage">TDragMessage</link> 
-->
</seealso>
</element>
<element name="TDragMessage.dmDragEnter">
<short>mouse enters control.</short>
</element>
<element name="TDragMessage.dmDragLeave">
<short>mouse leaves control.</short>
</element>
<element name="TDragMessage.dmDragMove">
<short>mouse moves over control (after dmDragEnter).</short>
</element>
<element name="TDragMessage.dmDragDrop">
<short>control dropped.</short>
</element>
<element name="TDragMessage.dmDragCancel">
<short>dragging aborted.</short>
</element>
<element name="TDragMessage.dmFindTarget">
<short>find possible target control under the mouse.</short>
</element>

<element name="TDragOverEvent">
<short>The type of an OnDragOver handler.</short>
<descr>
<p>An OnDragOver event is sent by a control, when an object is dragged over 
it.
The handler can specify whether a drop will be accepted or rejected.</p>
<remark>
<var>Source</var> is polymorphic, can be either the DragObject or the dragged 
control! This depends on DragObject.AutoCreated, for no sane reason.
</remark>
</descr>
<seealso>
<link id="TDockOverEvent"/>
</seealso>
</element>
<element name="TDragOverEvent.Sender">
<short>The possible drop target (control).</short>
</element>
<element name="TDragOverEvent.Source">
<short>The object (TDragObject or TControl) being dragged.</short>
</element>
<element name="TDragOverEvent.X">
<short>X coordinate of the mouse on screen.</short>
</element>
<element name="TDragOverEvent.Y">
<short>Y coordinate of the mouse on screen.</short>
</element>
<element name="TDragOverEvent.State">
<short>
The current DragState (entering, leaving or moving over the target).
</short>
</element>
<element name="TDragOverEvent.Accept">
<short>
Set Accept to <b>False</b> to reject an drop (default is <b>True</b>).
</short>
</element>

<element name="TDragDropEvent">
<short>The type of an OnDragDrop notification handler.</short>
<descr>
An OnDragDrop event is generated by the target control, on the drop of a 
dragged object.
</descr>
<seealso>
<link id="TDockDropEvent"/>
<link id="TEndDragEvent"/>
<link id="TControl.OnDragDrop"/>
</seealso>
</element>
<element name="TDragDropEvent.Sender">
<short>The target control of the drop.</short>
</element>
<element name="TDragDropEvent.Source">
<short>The dragged control.</short>
</element>
<element name="TDragDropEvent.X">
<short>The <b>client</b> coordinates of the drop.</short>
</element>
<element name="TDragDropEvent.Y">
<short>The <b>client</b> coordinates of the drop.</short>
</element>

<element name="TStartDragEvent">
<short>The type of an OnStartDrag handler.</short>
<descr>
<p>
An OnStartDrag event is generated for a control when it is dragged and its 
DragKind is dkDrag. The handler can provide a specific DragDrop object. 
Otherwise, a standard TDragDropObjectEx is automatically created by the 
DragManager.
</p>
</descr>
<seealso>
<link id="TStartDragEvent"/>
</seealso>
</element>
<element name="TStartDragEvent.Sender">
<short>The control to be dragged.</short>
</element>
<element name="TStartDragEvent.DragObject">
<short>
Supply your own DragObject, or leave it <b>Nil</b> for automatic creation.
</short>
</element>

<element name="TEndDragEvent">
<short>The type of an OnEndDrag handler.</short>
<descr>
<p>
An OnEndDrag event is sent for a dragged control, when the drag operation is 
finished. This happens regardless of whether the operation was drag-drop or 
drag-dock, and whether the operation ended with a drop or was cancelled.
</p>
<p>
Check for an unassigned value in Target to distinguish between a drop and a 
cancelled operation (Nil).
</p>
</descr>
<seealso>
<link id="TDragDropEvent"/>
<link id="TDockDropEvent"/>
</seealso>
</element>
<element name="TEndDragEvent.Sender">
<short>The dragged control.</short>
</element>
<element name="TEndDragEvent.Target">
<short>The drop target (control), or <b>Nil</b> if cancelled.</short>
</element>
<element name="TEndDragEvent.X">
<short>
The mouse coordinate, in client coordinates if dropped, else in screen 
coordinates.
</short>
</element>
<element name="TEndDragEvent.Y">
<short>
The mouse coordinate, in client coordinates if dropped, else in screen 
coordinates.
</short>
</element>

<element name="TDragObject">
<short>Base class for managing drag operations and user feedback.</short>
<descr>
<p>
Every dragging operation has an associated DragObject, holding references to 
the source and target controls, and other parameters for the customization of 
the visual user feedback.
</p>
<p>
A default <var>DragObject</var> is created automatically when a dragging 
operation starts, and is destroyed when the operation has ended; you do not 
need to maintain it. But an application can provide a customized 
<var>DragObject</var> in the <link id="TControl.OnStartDrag"/> or <link 
id="TControl.OnStartDock"/> handlers for the source control (the one being 
dragged).
</p>
<remark>
AutoCreated DragObjects imply different behavior in the DragOver and DragDrop 
events, where the Source becomes the dragged control, while the DragObject 
itself is passed as Source.
</remark>
<p>
<var>TDragObject</var> is the ancestor of a whole tree of dragging objects, 
with the main branches supporting either drag-drop or drag-dock operations. 
The type of the operation is determined using the <link 
id="TControl.DragKind"/> property in the source control.
</p>
<remark>
In contrast to the Delphi implementation, Lazarus has moved a couple of 
methods into the drag performers; these methods are no longer available for 
customization.
</remark>
<p>
A Lazarus DragObject mainly supplies the cursor and images, used in visual 
user feedback. Drag-drop operations typically signal acceptance of an 
possible drop by variations of the mouse cursor, and optionally can attach to 
it shapes of the dragged object(s). Drag-dock operations instead show a 
docking rectangle, that snaps to possible target locations when the mouse 
moves over docksites.
</p>
</descr>
<seealso>
<link id="TDragControlObject"/>
<link id="TDragDockObject"/>
</seealso>
</element>

<element name="TDragObject.FAlwaysShowDragImages"/>
<element name="TDragObject.FDragPos"/>
<element name="TDragObject.FControl"/>
<element name="TDragObject.FDragTarget"/>
<element name="TDragObject.FDragTargetPos"/>
<element name="TDragObject.FAutoFree"/>
<element name="TDragObject.FAutoCreated"/>
<element name="TDragObject.FDropped"/>

<element name="TDragObject.EndDrag">
<short>Called when a dragging operation ends.</short>
<descr>
The default implementation calls Control.DoEndDrag, which in turn invokes an 
OnEndDrag handler.
</descr>
</element>
<element name="TDragObject.EndDrag.Target">
<short>
The control onto which the dragged object is dropped (can be <b>Nil</b>).
</short>
</element>
<element name="TDragObject.EndDrag.X">
<short>Horizontal mouse coordinate when the method is called.</short>
</element>
<element name="TDragObject.EndDrag.Y">
<short>Vertical mouse coordinate when the method is called.</short>
</element>

<element name="TDragObject.GetDragImages">
<short>Returns a list of images for dragging.</short>
<descr>
<p>
The returned <link id="TDragImageList"/> provides methods for the selection 
and display of an image shown while dragging. This implementation returns 
<b>Nil</b>, and must be overridden (e.g. in <var>TDragControlObject</var>).
</p>
</descr>
<seealso>
<link id="TDragControlObject"/>
</seealso>
</element>
<element name="TDragObject.GetDragImages.Result">
<short>The ImageList to use, is <b>Nil</b> by default!</short>
</element>

<element name="TDragObject.GetDragCursor">
<short>Returns the dragging cursor type (shape).</short>
<descr>
<p>
In drag-drop operations the cursor signals acceptance or rejection of an 
drop, depending on Accepted.
</p>
</descr>
<seealso/>
</element>
<element name="TDragObject.GetDragCursor.Result">
<short>The cursor to show.</short>
</element>
<element name="TDragObject.GetDragCursor.Accepted">
<short>
Which cursor to return (rejected: crNoDrop or accepted: crDrag).
</short>
</element>
<element name="TDragObject.GetDragCursor.X">
<short>
Horizontal coordinate for the drag cursor.
</short>
</element>
<element name="TDragObject.GetDragCursor.Y">
<short>
Vertical coordinate for the drag cursor.
</short>
</element>

<element name="TDragObject.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the constructor for the class instance. It stores the 
value from the AControl argument to the <var>Control</var> property.
</p>
</descr>
<seealso>
<link id="TDragObject.Control"/>
</seealso>
</element>
<element name="TDragObject.Create.AControl">
<short>The control being dragged.</short>
</element>

<element name="TDragObject.AutoCreate">
<short>
Special constructor which enforces destruction of the object at the end of 
the dragging operation.
</short>
<descr>
<p>
This constructor sets the <var>AutoCreated</var> and <var>AutoFree</var> 
flags. <var>AutoFree</var> is tested by the <var>DragManager</var> at the end 
of the dragging operation.
</p>
</descr>
<seealso>
<link id="TDragObject.AutoCreated"/>
<link id="TDragObject.AutoFree"/>
</seealso>
</element>
<element name="TDragObject.AutoCreate.AControl">
<short>The control being dragged.</short>
</element>

<element name="TDragObject.HideDragImage">
<short>Asks the image list to hide the drag image.</short>
<descr>
<p>
Calls the <var>GetDragImages</var> method to get the 
<var>TDragImageList</var> instance with the images displayed for the Control 
during drag and drop / dock operations.
</p>
<p>
Please note that the image list is always unassigned (<b>Nil</b>) in 
TDragObject; it is provided by an overridden method in descendent classes 
like TDragControlObject.
</p>
</descr>
<seealso>
<link id="TDragObject.Control"/>
<link id="TDragObject.GetDragImages"/>
<link id="TDragObject.ShowDragImage"/>
<link id="TDragImageList"/>
<link id="TDragControlObject"/>
</seealso>
</element>

<element name="TDragObject.ShowDragImage">
<short>Asks the image list to show the drag image.</short>
<descr/>
<seealso>
<link id="TDragObject.HideDragImage"/>
<link id="TDragObject.Control"/>
<link id="TDragImageList"/>
<link id="TDragControlObject"/>
</seealso>
</element>

<element name="TDragObject.AlwaysShowDragImages">
<short>Should the image of dragged objects always be shown?</short>
<descr>
This is another chance for enforcing the display of a drag image, even if a 
drop is acceptable.
</descr>
<seealso/>
</element>

<element name="TDragObject.AutoCreated">
<short>Was the drag object created automatically?</short>
<descr>This property is of little use, more important is the AutoFree 
property.</descr>
</element>

<element name="TDragObject.AutoFree">
<short>
Indicates whether the object shall be destroyed at the end of the dragging 
operation.
</short>
<descr>
This is a Lazarus specific property, introduced to get rid of the special 
Delphi TDrag...Ex classes.
</descr>
</element>

<element name="TDragObject.Control">
<short>The control that is dragged (source).</short>
<descr/>
<seealso/>
</element>

<element name="TDragObject.DragPos">
<short>Current mouse position in screen coordinates.</short>
<seealso>
<link id="TDragObject.DragTargetPos"/>
</seealso>
</element>

<element name="TDragObject.DragTarget">
<short>
The control over which the object currently is dragged (target).
</short>
<descr/>
<seealso/>
</element>

<element name="TDragObject.DragTargetPos">
<short>Mouse position in client coordinates of the DragTarget.</short>
<seealso>
<link id="TDragObject.DragPos"/>
</seealso>
</element>

<element name="TDragObject.Dropped">
<short>Indicates whether the drag object has been dropped yet.</short>
<descr>
Contains <b>False</b> while dragging is in progress, or when dragging has 
been aborted.
</descr>
</element>

<element name="TDragObjectClass">
<short>A <link id="TDragObject"/> class type.</short>
</element>

<element name="TDragObjectEx">
<short>
Extends TDragObject to automatically free itself in the DragManager.
</short>
<descr>
<p>
<var>TDragObjectEx</var> is a <var>TDragObject</var> descendant. It provides 
an overridden constructor which sets the <var>AutoFree</var> property to 
<b>True</b>.
</p>
</descr>
<seealso>
<link id="TDragObject"/>
</seealso>
</element>

<element name="TDragObjectEx.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the overridden constructor for the class instance. 
Create sets the value in <var>AutoFree</var> to <b>True</b>. 
<var>AutoFree</var> is tested by the <var>DragManager</var> at the end of a 
dragging operation.
</p>
</descr>
<seealso>
<link id="TDragObject.AutoFree"/>
</seealso>
</element>
<element name="TDragObjectEx.Create.AControl">
<short>Control for the class instance.</short>
</element>

<element name="TDragControlObject">
<short>A drag object for dragging a control.</short>
<descr>
<p>
While a <var>TDragObject</var> can be used for dragging controls, this class 
<b>knows</b> that it drags a control, and asks it for a <var>DragCursor</var> 
and <var>DragImages</var>.
</p>
</descr>
<seealso>
<link id="TDragObject"/>
</seealso>
</element>

<element name="TDragControlObject.GetDragCursor">
<short>Asks the Control to provide a drag cursor.</short>
<descr>
<p>
Called when a TDragPerformer repositions the mouse pointer during an active 
drag operation.
</p>
</descr>
<seealso>
<link id="TCursor"/>
</seealso>
</element>
<element name="TDragControlObject.GetDragCursor.Result">
<short>
TCursor shape used as the drag cursor. crDrag when Accepted. crNoDrop when 
not Accepted.
</short>
</element>
<element name="TDragControlObject.GetDragCursor.Accepted">
<short>
<b>True</b> when the dragged object can be dropped at the specified position.
</short>
</element>
<element name="TDragControlObject.GetDragCursor.X">
<short>
Horizontal coordinate for the mouse pointer.
</short>
</element>
<element name="TDragControlObject.GetDragCursor.Y">
<short>
Vertical coordinate for the mouse pointer.
</short>
</element>

<element name="TDragControlObject.GetDragImages">
<short>Asks the Control to provide an ImageList.</short>
</element>
<element name="TDragControlObject.GetDragImages.Result">
<short>The Image list to be used in dragging this control.</short>
</element>
<element name="TDragControlObjectEx" link="#lcl.controls.TDragControlObject"/>

<element name="TDragControlObjectEx.Create">
<short>
Constructor for the class instance.
</short>
</element>
<element name="TDragControlObjectEx.Create.AControl">
<short>The control to drag.</short>
</element>

<element name="TDockOrientation">
<short>
Orientation of DockZones and docked controls, similar to <link id="TAlign"/>
</short>
<descr>
<p>
This is a Delphi relic, bound to TDockTree and not very useful in application 
code. All <var>DockZones</var> in a <var>DockTree</var> have an orientation, 
horizontal or vertical, indicating how controls are arranged in the dock 
zone. When a control is docked into a zone, it obtains the orientation of 
that zone.
</p>
<remark>
The orientation for the control can be stored as the opposite for the dock 
zone, depending on the DockManager used.
</remark>
</descr>
<seealso/>
</element>
<element name="TDockOrientation.doNoOrient">
<short>no orientation applies (like alNone).</short>
</element>
<element name="TDockOrientation.doHorizontal">
<short>siblings are arranged horizontally, children top-to-bottom.</short>
</element>
<element name="TDockOrientation.doVertical">
<short>siblings are arranged vertically, children left-to-right.</short>
</element>
<element name="TDockOrientation.doPages">
<short>children are pages in a tabbed control.</short>
</element>

<element name="TDockDropEvent">
<short>The type of an OnDockDrop handler.</short>
<descr>
<p>
An OnDockDrop event is sent by the drop target (dock site) on the drop of a 
dragged object.
</p>
</descr>
<seealso>
<link id="TDragDropEvent"/>
</seealso>
</element>
<element name="TDockDropEvent.Sender">
<short>The drop target (docksite control).</short>
</element>
<element name="TDockDropEvent.Source">
<short>
The DragDock object, containing information about the dragged object.
</short>
</element>
<element name="TDockDropEvent.X" link="#lcl.controls.TDragOverEvent.X"/>
<element name="TDockDropEvent.Y" link="#lcl.controls.TDragOverEvent.Y"/>

<element name="TDockOverEvent">
<short>The type of an OnDockOver handler.</short>
<descr>
<p>
An OnDockOver event is sent by a dock site, when an object is dragged over 
it. The handler can specify whether a drop will be accepted or rejected.
</p>
</descr>
<seealso>
<link id="TDragOverEvent"/>
</seealso>
</element>
<element name="TDockOverEvent.Sender">
<short>The possible drop target.</short>
</element>
<element name="TDockOverEvent.Source" link="#lcl.controls.TDockDropEvent.Source"/>
<element name="TDockOverEvent.X" link="#lcl.controls.TDragOverEvent.X"/>
<element name="TDockOverEvent.Y" link="#lcl.controls.TDragOverEvent.Y"/>
<element name="TDockOverEvent.State" link="#lcl.controls.TDragOverEvent.State"/>
<element name="TDockOverEvent.Accept" link="#lcl.controls.TDragOverEvent.Accept"/>

<element name="TUnDockEvent">
<short>The type used for OnUnDock event handler.</short>
<descr>
<p>
An UnDock event is sent by a dock site, and occurs before a control is 
undocked. The handler can reject undocking, by setting Allow to <b>False</b>.
</p>
</descr>
<seealso/>
</element>
<element name="TUnDockEvent.Sender">
<short>The docksite from which the object is undocked.</short>
</element>
<element name="TUnDockEvent.Client">
<short>The control to be undocked.</short>
</element>
<element name="TUnDockEvent.NewTarget">
<short>
The new docksite for Client, <b>Nil</b> when undocked into floating state.
</short>
</element>
<element name="TUnDockEvent.Allow">
<short>Set Allow to <b>False</b> to reject undocking.</short>
</element>

<element name="TStartDockEvent">
<short>The type of an OnStartDock handler.</short>
<descr>
<p>
An OnStartDock event is sent by a control when it shall be dragged and its 
DragKind is dkDock. The handler can provide a specific DragDock object, else 
a standard TDragDockObjectEx is automatically created by the DragManager.
</p>
</descr>
<seealso>
<link id="TStartDragEvent"/>
</seealso>
</element>
<element name="TStartDockEvent.Sender">
<short>The control being dragged.</short>
</element>

<element name="TStartDockEvent.DragObject">
<short>
Supply your own TDragDockObject, or leave it <b>Nil</b> to request automatic 
creation.
</short>
</element>

<element name="TGetSiteInfoEvent">
<short>An OnGetSiteInfo handler returns information about a docksite.</short>
<descr>
<p>
An OnGetSiteInfo event is sent by the DragManager to all docksites. The 
handler can adjust the snapping rectangle (InfluenceRect), and can reject an 
drop.
</p>
</descr>
<seealso/>
</element>
<element name="TGetSiteInfoEvent.Sender">
<short>The dock site near the mouse pointer.</short>
</element>
<element name="TGetSiteInfoEvent.DockClient">
<short>The dragged control.</short>
</element>
<element name="TGetSiteInfoEvent.InfluenceRect">
<short>
The screen rectangle where a drop or mouse move is directed to this docksite.
</short>
</element>
<element name="TGetSiteInfoEvent.MousePos">
<short>The current position of the mouse.</short>
</element>
<element name="TGetSiteInfoEvent.CanDock">
<short>Set CanDock to <b>False</b> to reject docking.</short>
</element>

<element name="TDrawDockImageEvent">
<short>
Event handler used to draw the docking image in a drag and dock operation.
</short>
<descr>
<p>
<var>TDrawDockImageEvent</var> is an object procedure type which specifies an 
event handler used to draw the docking image for TDragDockObject instances. 
<var>TDrawDockImageEvent</var> is the type used to implement the 
<var>OnDrawDockImage</var> variable in the <file>Controls</file> unit.
</p>
</descr>
<seealso>
<link id="OnDrawDockImage"/>
</seealso>
</element>
<element name="TDrawDockImageEvent.Sender">
<short>
Object (TDragDockObject) for the event notification.
</short>
</element>
<element name="TDrawDockImageEvent.AOldRect">
<short>
Rectangle with area cleared in the handler routine.
</short>
</element>
<element name="TDrawDockImageEvent.ANewRect">
<short>
Rectangle with area drawn in the handler routine.
</short>
</element>
<element name="TDrawDockImageEvent.AOperation">
<short>
Operation performed for the notification. Valid values are: disShow, disMove, disHide.
</short>
</element>

<element name="OnDrawDockImage">
<short>Routine used to draw dock images in drag/dock operations </short>
<descr>
<p>
<var>OnDrawDockImage</var> is a <var>TDrawDockImageEvent</var> variable which 
contains the default routine used to draw the docking image in a drag/dock 
operation. It is used in <var>TDragDockObject</var> methods which draw 
docking images likes <var>HideDockImage</var>, <var>ShowDockImage</var>, and 
<var>MoveDockInage</var>.
</p>
</descr>
<seealso>
<link id="TDragDockObject.ShowDockImage"/>
<link id="TDragDockObject.HideDockImage"/>
<link id="TDragDockObject.MoveDockImage"/>
</seealso>
</element>

<element name="TDragDockObject">
<short>A drag object for drag-dock.</short>
<descr>
<p>
This object type serves two main purposes: it allows one to distinguish 
between drag-drop and drag-dock operations, and it implements docking 
specific information and behavior.
</p>
<p>
The primary use is for tree docking, as assumed by methods in 
<var>TControl</var> and <var>TWinControl</var>.
</p>
</descr>
<seealso>
<link id="TDragObject"/>
</seealso>
</element>

<element name="TDragDockObject.FDockOffset"/>
<element name="TDragDockObject.FDockRect"/>
<element name="TDragDockObject.FDropAlign"/>
<element name="TDragDockObject.FDropOnControl"/>
<element name="TDragDockObject.FEraseDockRect"/>
<element name="TDragDockObject.FFloating"/>
<element name="TDragDockObject.FIncreaseDockArea"/>

<element name="TDragDockObject.AdjustDockRect">
<short>
Adjust the DockRect relative to the dragging hotspot (DockOffset).
</short>
<descr>
<remark>
The parameter type is bad, should be <b>var</b>. Ignore it please.
</remark>
<p>
The default implementation adjusts the stored FDockRect, by DockOffset.
This adjustment will make the DockRect appear right over the control, when 
dragging starts, regardless of where the user clicked onto the control.
</p>
<p>
You will rarely need to override this method, since the DockRect is adjusted 
by every target site's DockManager later.
</p>
</descr>
<seealso/>
</element>
<element name="TDragDockObject.AdjustDockRect.ARect">
<short>Not used; please ignore it.</short>
</element>

<element name="TDragDockObject.GetDragCursor">
<short>Gets the drag cursor shape for the class instance.</short>
<descr/>
<seealso>
<link id="TDragObject.GetDragCursor"/>
</seealso>
</element>
<element name="TDragDockObject.GetDragCursor.Result">
<short>
TCursor shape used as the drag cursor. crDrag when Accepted. crNoDrop when 
not Accepted.
</short>
</element>
<element name="TDragDockObject.GetDragCursor.Accepted">
<short>
<b>True</b> when the dragged object can be docked at the specified position.
</short>
</element>
<element name="TDragDockObject.GetDragCursor.X">
<short>
Horizontal coordinate for the mouse pointer.
</short>
</element>
<element name="TDragDockObject.GetDragCursor.Y">
<short>
Vertical coordinate for the mouse pointer.
</short>
</element>

<element name="TDragDockObject.EndDrag">
<short>Finish docking.</short>
<descr>Invokes Control.DoEndDock.</descr>
<seealso>
<link id="TControl.DoEndDock"/>
</seealso>
</element>
<element name="TDragDockObject.EndDrag.Target">
<short>The target docksite, or <b>Nil</b> to make the Control float.</short>
</element>
<element name="TDragDockObject.EndDrag.X">
<short>
Horizontal coordinate for the mouse pointer.
</short>
</element>
<element name="TDragDockObject.EndDrag.Y">
<short>
Vertical coordinate for the mouse pointer.
</short>
</element>

<element name="TDragDockObject.InitDock">
<short>Initializes the dragging coordinates.</short>
<descr>
<p>
Determines the hotspot offset for adjusting the floating DockRect. Since the 
undocked extent of the control doesn't change while dragging, we fix the 
hotspot offset here.
</p>
<p>
Usage:
</p>
<code>OffsetRect(DockRect, FDockOffset);</code>
</descr>
</element>
<element name="TDragDockObject.InitDock.APosition">
<short/>
</element>

<element name="TDragDockObject.ShowDockImage">
<short>
Shows the DockRect, and remembers the coordinates in EraseDockRect.
</short>
<descr/>
<seealso/>
</element>

<element name="TDragDockObject.HideDockImage">
<short>
Hides the DockRect, and invalidates EraseDockRect to prevent further erases.
</short>
<descr/>
<seealso/>
</element>

<element name="TDragDockObject.MoveDockImage">
<short>Moves an already visible DockRect.</short>
<descr>
<p>
Checks the DockRect for changes against EraseDockRect, to prevent flicker. 
Remembers the drawn frame coordinates in EraseDockRect.
</p>
</descr>
</element>

<element name="TDragDockObject.HasOnDrawImage">
<short>Checks for an assigned OnDrawDockImage event handler.</short>
<descr>
<p>
<var>HasOnDrawImage</var> is a <var>Boolean</var> function used to determine 
if an event handler has been assigned to the <var>OnDrawDockImage</var> 
property. The return value is <b>True</b> if a routine has been assigned to 
the property. If an event handler has not been supplied, the 
<var>HintDockImage</var> routine is assigned to the event handler, and the 
return value is set to <b>True</b>.
</p>
<p>
For platforms where the Alpha blending is not enabled for Forms, the return 
value is always <b>False</b> (determined by calling 
<var>GetSystemMetrics</var> for the <var>SM_LCLHasFormAlphaBlend</var> metric 
in the widgetset class).
</p>
<p>
<var>HasOnDrawImage</var> is used in methods like <var>ShowDockImage</var>, 
<var>HideDockImage</var>, and <var>MoveDockImage</var>.
</p>
</descr>
<seealso>
<link id="TDragDockObject.ShowDockImage"/>
<link id="TDragDockObject.HideDockImage"/>
<link id="TDragDockObject.MoveDockImage"/>
</seealso>
</element>
<element name="TDragDockObject.HasOnDrawImage.Result">
<short>
<b>True</b> when an event handler has been assigned to OnDrawDockImage.
</short>
</element>

<element name="TDragDockObject.DockOffset">
<short>The hotspot offset of the dragged DockRect.</short>
<descr/>
<seealso/>
</element>

<element name="TDragDockObject.DockRect">
<short>Screen coordinates for a possible drop location.</short>
<descr>
<p>
<var>DockRect</var> gives feedback to the user where the dragged control may 
be dropped. When no docksite signals acceptance, the DockRect uses the 
floating state of the dragged control. When a drop will dock the control, the 
DockRect signifies the approximate position for the docked control.
</p>
</descr>
<seealso/>
</element>

<element name="TDragDockObject.DropAlign">
<short>
How the dragged control will be docked, relative to the target control.
</short>
<descr>
<p>
When the target is a DockTree, DropAlign indicates the placement of the 
control relative to DropOnControl. Other docking methods require a 
specialized (derived) DragDockObject.
</p>
</descr>
<seealso/>
</element>

<element name="TDragDockObject.DropOnControl">
<short>
The already docked control, relative to which the dragged control will be 
docked. <b>Nil</b> for an empty docksite.
</short>
<descr/>
<seealso/>
</element>

<element name="TDragDockObject.Floating">
<short>The final state of the dragged control (after drop).</short>
<descr>
<p>
<b>True</b> when the dragged control becomes or stays floating.
</p>
</descr>
<seealso/>
</element>

<element name="TDragDockObject.IncreaseDockArea">
<short>
Indicates whether the dock site is enlarged after a Control has been docked.
</short>
<descr>
<p>
The property value is assigned when the ManualDock method is called for the 
Control. It is set to the inverse of the KeepDockSiteSize argument passed to 
the ManualDock or ManualFloat methods in Control. The value is not, however, 
subsequently used in the current LCL implementation.
</p>
</descr>
<seealso/>
</element>

<element name="TDragDockObject.EraseDockRect">
<short>
Area to be erased when refreshing the display for the docking rectangle.
</short>
<descr>
<p>
<var>EraseDockRect</var> is a <var>TRect</var> property that represents the 
area to be erased when redrawing the docking rectangle. The value in 
EraseDockRect is assigned in InitDock, and updated to contain the value from 
DockRect when the docking rectangle has been altered in methods like 
ShowDockImage, HideDockImage, and MoveDockImage.
</p>
<p>
EraseDockRect is passed as an argument to OnDrawDockImage, and to the 
underlying widgetset class.
</p>
</descr>
<seealso>
<link id="TDragDockObject.DockRect"/>
<link id="TDragDockObject.InitDock"/>
<link id="TDragDockObject.ShowDockImage"/>
<link id="TDragDockObject.HideDockImage"/>
<link id="TDragDockObject.MoveDockImage"/>
</seealso>
</element>

<element name="TDragDockObjectEx">
<short>
A drag object for docking that is automatically destroyed after use.
</short>
</element>

<element name="TDragDockObjectEx.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
Create is the overridden constructor for the class instance.
It calls the inherited constructor on entry to assign the value in AControl 
to the Control property. It sets the default value for the AutoFree property 
to <b>True</b>.
</p>
</descr>
<seealso/>
</element>
<element name="TDragDockObjectEx.Create.AControl">
<short>Control for the drag and drop / dock operation.</short>
</element>

<element name="TDragManager">
<short>
The abstract base class used to manage dragging of controls (for drop or dock 
operations).
</short>
<descr>
<p>
TDragManager specifies an object-oriented version of the Delphi drag manager. 
It is implemented by the TDragManagerDefault descendant.
</p>
<remark>
The registered dock sites should be stored in a persistent list, not in a 
DragManager instance.
</remark>
</descr>
<seealso/>
</element>

<element name="TDragManager.FDragImmediate"/>
<element name="TDragManager.FDragThreshold"/>

<element name="TDragManager.KeyUp">
<short>Handler for keyboard key released.</short>
<descr>
<p>
When the Ctrl key is released, a drop is enabled again.
</p>
</descr>
<seealso/>
</element>
<element name="TDragManager.KeyUp.Key">
<short>
Virtual key code for the key up event.
</short>
</element>
<element name="TDragManager.KeyUp.Shift">
<short>
Shift, Ctrl, or Alt modifier for the key up event.
</short>
</element>

<element name="TDragManager.KeyDown">
<short>Handler for keyboard key pressed.</short>
<descr>
<p>
When (and while) the Ctrl key is pressed, dropping is disabled. The Esc key 
aborts the current dragging operation immediately.
</p>
</descr>
<seealso/>
</element>
<element name="TDragManager.KeyDown.Key">
<short>
Virtual key code for the key down event.
</short>
</element>
<element name="TDragManager.KeyDown.Shift">
<short>
Shift, Ctrl, or Alt modifier for the key up event.
</short>
</element>

<element name="TDragManager.CaptureChanged">
<short>
Aborts the dragging operation when the capture control has changed.
</short>
<descr>
<p>
<var>CaptureChanged</var> is an abstract virtual method in 
<var>TDragManager</var>, and must be implemented in a descendent class. In the 
default drag manager implementation, the DragMode and DragKind properties for 
child controls are checked to determine if one of them has the mouse capture. 
If none of them are active, the Parent control calls DragStop.
</p>
<p>
CaptureChanged is called from the CaptureChanged method in TControl when 
the LM_CaptureChanged message is received by the control and the drag manager 
is active.
</p>
</descr>
<seealso>
<link id="TDragManager.IsDragging"/>
<link id="TControl.CaptureChanged"/>
<link id="TControl.LMCaptureChanged"/>
</seealso>
</element>
<element name="TDragManager.CaptureChanged.OldCaptureControl">
<short>
Control which has the mouse capture change message is handled for the control.
</short>
</element>

<element name="TDragManager.MouseMove">
<short>
Generates visual feedback for mouse movement in a drag operation.
</short>
<descr/>
<seealso/>
</element>
<element name="TDragManager.MouseMove.Shift">
<short>
Ctrl, Alt, Shift modifier for the mouse movement.
</short>
</element>
<element name="TDragManager.MouseMove.X">
<short>
Horizontal coordinate for the mouse pointer.
</short>
</element>
<element name="TDragManager.MouseMove.Y">
<short>
Horizontal coordinate for the mouse pointer.
</short>
</element>

<element name="TDragManager.MouseUp">
<short>
Ends a drag operation when a mouse up event has occurred.
</short>
<descr>
<p>
<var>MouseUp</var> is an abstract virtual method in <var>TDragManager</var>. 
It must be implemented in a descendent class to perform actions needed for 
the notification.
</p>
</descr>
<seealso/>
</element>
<element name="TDragManager.MouseUp.Button">
<short>
Mouse button for the notification.
</short>
</element>
<element name="TDragManager.MouseUp.Shift">
<short>
Ctrl, Shift, or Alt modifier for the notification.
</short>
</element>
<element name="TDragManager.MouseUp.X">
<short>
Horizontal pointer position when the mouse event was detected.
</short>
</element>
<element name="TDragManager.MouseUp.Y">
<short>
Vertical pointer position when the mouse event was detected.
</short>
</element>

<element name="TDragManager.MouseDown">
<short>
Performs actions when the drag manager needs to respond to a mouse button 
down event.
</short>
<descr>
<p>
<var>MouseDown</var> is an abstract virtual method in 
<var>TDragManager</var>. It must be overridden in a descendent class to 
perform actions need for the drag manager implementation.
</p>
<p>
In the LCL, the drag managers are implementation classes like 
TDragManagerDefault. This derived classes ignores the button down event in 
the drag manager to prevent a premature end to a drag operation. The button 
down event has already been initiated in the message processing loop in 
TControl. MouseUp handles ending the drag operation.
</p>
</descr>
<seealso/>
</element>
<element name="TDragManager.MouseDown.Button">
<short>
Mouse button for the mouse button down event.
</short>
</element>
<element name="TDragManager.MouseDown.Shift">
<short>
Shift, Ctrl, or Alt modifier for the mouse button down event.
</short>
</element>
<element name="TDragManager.MouseDown.X">
<short>
Horizontal coordinate for the mouse pointer when the button down event 
occurred.
</short>
</element>
<element name="TDragManager.MouseDown.Y">
<short>
Vertical coordinate for the mouse pointer when the button down event 
occurred.
</short>
</element>

<element name="TDragManager.Create">
<short>
Initializes the drag parameters to Delphi-compatible values.
</short>
<descr>
<p>
The Delphi VCL sets DragImmediate to <b>True</b> and DragThreshold to 5.
</p>
<remark>
A docking operation never should start immediately.
</remark>
</descr>
</element>
<element name="TDragManager.Create.TheOwner">
<short>
Owner of the class instance.
</short>
</element>

<element name="TDragManager.IsDragging">
<short>Check if dragging is in progress.</short>
<descr/>
<seealso/>
</element>
<element name="TDragManager.IsDragging.Result">
<short><b>True</b> if dragging.</short>
</element>

<element name="TDragManager.Dragging">
<short>
Indicates whether the specified control is the active drag object in the drag 
manager.
</short>
<descr>
<p>
<var>Dragging</var> is an abstract virtual method in <var>TDragmanager</var>. 
It must be implemented in a descendent class to perform actions needed in 
the method.
</p>
<p>
Use IsDragging to determine whether a drag performer is active in the drag 
manager for a(ny) control.
</p>
</descr>
<seealso>
<link id="TDragManager.IsDragging"/>
</seealso>
</element>
<element name="TDragManager.Dragging.Result">
<short>
<b>True</b> if the specified control is being dragged.
</short>
</element>
<element name="TDragManager.Dragging.AControl">
<short>
Control compared to the drag object to get the return value.
</short>
</element>

<element name="TDragManager.RegisterDockSite">
<short>Adds the control to the list of registered docking sites.</short>
<descr>
<remark>
This should become a class method, maintaining the list of registered docking 
sites outside any DragManager instance.
</remark>
</descr>
<seealso/>
</element>
<element name="TDragManager.RegisterDockSite.Site">
<short>The DockSite to register.</short>
</element>
<element name="TDragManager.RegisterDockSite.DoRegister">
<short><b>True</b> for adding, <b>False</b> for removing the site.</short>
</element>

<element name="TDragManager.DragStart">
<short>Starts a drag operation for a control.</short>
<descr>
<p>
A DragObject must be created, depending on the Control.DragKind. The mouse 
has to be captured, and visual feedback must be initialized.
</p>
</descr>
<seealso/>
</element>
<element name="TDragManager.DragStart.AControl">
<short>The control that initiates the drag operation.</short>
</element>
<element name="TDragManager.DragStart.AImmediate">
<short>
 <b>False</b> when dragging should start only when the mouse is moved 
(delayed).
</short>
</element>
<element name="TDragManager.DragStart.AThreshold">
<short>How much the mouse must move before delayed dragging starts.</short>
</element>

<element name="TDragManager.DragMove">
<short>Updates the visual dragging feedback.</short>
<descr/>
<seealso/>
</element>
<element name="TDragManager.DragMove.APosition">
<short>Mouse position in <b>screen</b> coordinates.</short>
</element>

<element name="TDragManager.DragStop">
<short>Ends dragging.</short>
<descr>
<p>The visual feedback is reset.</p>
<p>
All related controls are notified of the outcome of the operation (drop, 
dock, abort).
</p>
<p>Finally all temporary objects are destroyed.</p>
</descr>
<seealso/>
</element>
<element name="TDragManager.DragStop.ADrop">
<short> <b>False</b> when dragging was aborted.</short>
</element>

<element name="TDragManager.CanStartDragging">
<short>
Indicates if the mouse coordinates are within the drag threshold for the 
specified control.
</short>
<descr>
<p>
<var>CanStartDragging</var> is an abstract virtual <var>Boolean</var> 
function used to determine if the mouse has been moved beyond the threshold 
that initiates a drag operation. The result is <b>True</b> when the mouse 
coordinates in X and Y are located within the client rectangle and within the 
threshold for the specified control in <var>Site</var>.
</p>
<p>
CanStartDragging must be implemented in a descendent class, like the 
<var>TDragManagerDefault</var> class in the implementation for the unit.
</p>
</descr>
<seealso>
</seealso>
</element>
<element name="TDragManager.CanStartDragging.Result">
<short/>
</element>
<element name="TDragManager.CanStartDragging.Site">
<short/>
</element>
<element name="TDragManager.CanStartDragging.AThreshold">
<short/>
</element>
<element name="TDragManager.CanStartDragging.X">
<short/>
</element>
<element name="TDragManager.CanStartDragging.Y">
<short/>
</element>

<element name="TDragManager.DragImmediate">
<short>Start dragging immediately on MouseDown.</short>
<descr>This is the default value for e.g. BeginDrag.</descr>
<seealso/>
</element>

<element name="TDragManager.DragThreshold">
<short>
The threshold for mouse movement before delayed dragging starts (default is 5 
pixels).
</short>
<seealso/>
</element>

<element name="DragManager">
<short>The current DragManager (always TDragManagerDefault).</short>
<descr>
<remark>
A <var>DragManager</var> must be implemented in the <file>Controls</file> 
unit; it requires access to private members in the classes declared in the 
unit.
</remark>
</descr>
<seealso>
<link id="TDragManager"/>
</seealso>
</element>

<element name="TDockManager">
<short>The layout manager for a docksite.</short>
<descr>
<p>
<var>TDockManager</var> is an abstract class for managing the controls on a 
dock site. Every docksite can have a DockManager, which arranges the docked 
controls. See <link id="TDockTree">TDockTree</link> for more info.
</p>
</descr>
<seealso>
<link id="TDockTree"/>
</seealso>
</element>

<element name="TDockManager.Create">
<short>Creates an DockManager for ADockSite.</short>
</element>
<element name="TDockManager.Create.ADockSite">
<short>This is the TWinControl acting as the docksite.</short>
</element>

<element name="TDockManager.BeginUpdate">
<short>Starts updating the DockSite layout.</short>
<descr/>
<seealso/>
</element>

<element name="TDockManager.EndUpdate">
<short>Finishes updating the DockSite layout.</short>
<descr/>
<seealso/>
</element>

<element name="TDockManager.GetControlBounds">
<short>Returns the zone bounds of a docked control.</short>
<descr>
<p>
The TDockTree manager returns the bounds of the dockzone, including the dock 
header.
</p>
<p>
When the Control is not docked, an empty Rect(0,0,0,0) is returned.
</p>
</descr>
<seealso/>
</element>
<element name="TDockManager.GetControlBounds.Control">
<short>The docked control.</short>
</element>
<element name="TDockManager.GetControlBounds.AControlBounds">
<short>The enclosing rectangle, in client coordinates of the docksite.</short>
</element>

<element name="TDockManager.GetDockEdge">
<short>Determine the DropAlign.</short>
<descr>
<p>
ADockObject contains valid DragTarget, DragPos and DragTargetPos relative 
dock site. DockRect is undetermined.
</p>
<p>
DropOnControl may be <b>Nil</b> if nothing has been docked yet, or no target 
control exists at the mouse coordinates.
</p>
<p>
Returns <b>True</b> if ADockObject.DropAlign has been determined. If 
<b>False</b>, the DropAlign has to be determined by default procedures.
</p>
</descr>
</element>
<element name="TDockManager.GetDockEdge.Result">
<short><b>True</b> if the DropAlign was determined.</short>
</element>
<element name="TDockManager.GetDockEdge.ADockObject">
<short>
The DragDockObject holding all information about the drag-dock operation.
</short>
</element>

<element name="TDockManager.InsertControl">
<short>
Position <var>DropCtl</var> relative <var>Control</var>, using the alignment 
specified by <var>InsertAt</var>.
</short>
<descr>
<p>
InsertControl determines the placement of the just docked control, forcing a 
repaint of the container control if necessary.
</p>
<remark>
When SetReplacingControl has been called with a non-<b>Nil</b> Control before, 
the dropped control only should replace that control.
</remark>
<p>
An overloaded version passes the DragDockObject to the dockmanager, allowing 
to pass more information about the drop. It allows one to implement other 
than tree-style docksites.
</p>
</descr>
<seealso>
<link id="TDockManager.RemoveControl"/>
</seealso>
</element>
<element name="TDockManager.InsertControl.Control">
<short>The control relative to which insert.</short>
</element>
<element name="TDockManager.InsertControl.InsertAt">
<short>How to insert relative to Control.</short>
</element>
<element name="TDockManager.InsertControl.DropCtl">
<short>The control to insert.</short>
</element>
<element name="TDockManager.InsertControl.ADockObject">
<short>
The DragDockObject holding all information about the drag-dock operation.
</short>
</element>

<element name="TDockManager.LoadFromStream">
<short>Restores the layout of the docksite from the specified stream.</short>
<descr>
<p>
The controls to be docked can be retrieved by using 
<var>ReloadDockedControl</var> in the docksite. This method returns only 
existing controls of the given name, owned by the owner of the docksite, by 
default.
</p>
</descr>
<seealso>
<link id="TWinControl.ReloadDockedControl"/>
<link id="TDockManager.SaveToStream"/>
</seealso>
</element>
<element name="TDockManager.LoadFromStream.Stream">
<short>The stream with the layout information.</short>
</element>

<element name="TDockManager.MessageHandler">
<short>Handles the messages sent to a docksite.</short>
<descr>
<p>
This handler must handle all mouse messages, related to the client area of 
the docksite that is not covered by docked controls (dock headers, et. al.).
</p>
<p>
Handling mouse messages while dragging is not required. Painting of the 
docksite has to be implemented in PaintSite.
</p>
</descr>
<seealso>
<link id="TDockManager.PaintSite"/>
</seealso>
</element>
<element name="TDockManager.MessageHandler.Sender">
<short/>
</element>
<element name="TDockManager.MessageHandler.Message">
<short>The message to be processed.</short>
</element>

<element name="TDockManager.PaintSite">
<short>Handles special painting of the docksite.</short>
<descr>
<p>
While the docked controls paint themselves, the eventual dockheaders and 
other decorations have to be painted by the DockManager.
</p>
</descr>
<seealso/>
</element>
<element name="TDockManager.PaintSite.DC">
<short>The device context, used to paint.</short>
</element>

<element name="TDockManager.PositionDockRect">
<short>
Determines the DockRect while dragging a control over the docksite.
</short>
<descr>
<p>
This method updates DockRect to provide visual feedback when a control is 
dragged over the docksite. The initial DragDockObject.DockRect spans the 
entire DockSite.
</p>
<p>
The Delphi-compatible version only can use the parameters determined by the 
default processing in the docksite.
</p>
<p>
The Lazarus version can update the DockObject with better-suited parameters. 
A DockManager here can implement any algorithm for the placement of a dropped 
control. The default implementation calls the Delphi compatible version. When 
you override the Lazarus version, you may have to determine the dock sibling 
and DropAlign again, when the default determination (in TControl and 
TWinControl) is inappropriate.
</p>
</descr>
<seealso>
<link id="TDragDockObject"/>
</seealso>
</element>
<element name="TDockManager.PositionDockRect.Client">
<short>The dropped control.</short>
</element>
<element name="TDockManager.PositionDockRect.DropCtl">
<short>
The control relative to which Client shall be docked; <b>Nil</b> for docking 
into the docksite.
</short>
</element>
<element name="TDockManager.PositionDockRect.DropAlign">
<short>How to dock, relative to DropCtl.</short>
</element>
<element name="TDockManager.PositionDockRect.DockRect">
<short>
The screen rectangle of the docksite, to be adjusted by this method.
</short>
</element>
<element name="TDockManager.PositionDockRect.ADockObject">
<short>
The DragDockObject holding all information about the drag-dock operation.
</short>
</element>

<element name="TDockManager.RemoveControl">
<short>Removes the undocked control from the docksite layout.</short>
<descr>
<p>
When <var>SetReplacingControl</var> has been called with a non-<b>Nil</b> 
argument before, the layout of the docksite should not be changed. Instead, 
the next inserted control should take the place and role of this control.
</p>
</descr>
<seealso/>
</element>
<element name="TDockManager.RemoveControl.Control">
<short>Control to remove.</short>
</element>

<element name="TDockManager.ResetBounds">
<short>
Refreshes the layout for the dock site.
</short>
<descr>
<p>
This method typically notifies the DockManager when the DockSite calls its 
Resize method. When the extent of the docksite has changed, the DockManager 
should reposition and resize all docked controls accordingly.
</p>
<p>
The layout always should be refreshed when <var>Force</var> is <b>True</b>. 
This is required when e.g. the visibility of docked controls has changed, but 
not the size of the docksite.
</p>
</descr>
<seealso/>
</element>
<element name="TDockManager.ResetBounds.Force">
<short>When <b>True</b>, always update the layout.</short>
</element>

<element name="TDockManager.SaveToStream">
<short>Saves the docksite layout to <var>Stream</var>.</short>
<descr/>
<seealso>
<link id="TDockManager.LoadFromStream"/>
</seealso>
</element>
<element name="TDockManager.SaveToStream.Stream">
<short>Write the layout information into this stream.</short>
</element>

<element name="TDockManager.SetReplacingControl">
<short>Specifies the control to be replaced subsequently.</short>
<descr>
<p>
This method is called by <var>ReplaceDockedControl</var>, to announce a 
pending replacement of <var>Control</var> by another control. The next 
<var>RemoveControl</var> should be ignored, and <var>InsertControl</var> 
should only exchange the controls, without reorganizing the layout of the 
docksite. When <var>Control</var> is <b>Nil</b>, this call signals the end of 
the exchange [obsolete].
</p>
<remark>
The name "SetReplacingControl" is a misnomer, it should read 
"SetControlToBeReplaced".
</remark>
<p>
The intended purpose of this method is the replacement of a docked control by 
a Notebook, preserving the DockZone. This operation should be handled by an 
DockManager internally, and calls to this method should be ignored.
</p>
</descr>
<seealso>
<link id="TDockManager.InsertControl"/>
<link id="TDockManager.RemoveControl"/>
</seealso>
</element>
<element name="TDockManager.SetReplacingControl.Control">
<short>The control to be replaced later.</short>
</element>

<element name="TDockManager.AutoFreeByControl">
<short>
Returns <b>True</b> if the DockManager should be destroyed together with the 
docksite.
</short>
<descr>
<p>
This is a Lazarus-specific extension of the Delphi TDockManager. It allows 
multiple docksites to share the same DockManager instance.
</p>
</descr>
</element>
<element name="TDockManager.AutoFreeByControl.Result">
<short>
<b>True</b> if the DockManager should be destroyed together with the docksite.
</short>
</element>

<element name="TDockManager.IsEnabledControl">
<short>
Determines whether the specified control is a windowed control using the 
current dock manager.
</short>
<descr>
When the return value is <b>True</b>, the Control can be docked using the 
dock manager.
</descr>
<seealso/>
</element>
<element name="TDockManager.IsEnabledControl.Result">
<short><b>True</b> when Control can be docked using the dock manager.</short>
</element>
<element name="TDockManager.IsEnabledControl.Control">
<short>Control examined in the method.</short>
</element>

<element name="TDockManager.CanBeDoubleDocked">
<short/>
<descr>
<p>
<var>CanBeDoubleDocked</var> is a <var>Boolean</var> function.
CanBeDoubleDocked always returns <b>True</b> in TDockManager.
</p>
</descr>
<seealso/>
</element>
<element name="TDockManager.CanBeDoubleDocked.Result">
<short>
Always returns <b>True</b> in TDockManager. Can be overridden in descendent 
classes.
</short>
</element>

<element name="TDockManagerClass">
<short>
The DockManager class type, for use when a DockManager is automatically 
created.
</short>
<seealso>
<link id="TWinControl.CreateDockManager"/>
<link id="DefaultDockManagerClass"/>
</seealso>
</element>

<element name="TConstraintSize">
<short>Range for control size constraints.</short>
<descr/>
<seealso/>
</element>

<element name="TSizeConstraintsOption">
<short>Enumerated type with options used in TSizeConstraints.</short>
<descr>
Not used in the current LCL Implementation.
</descr>
<seealso/>
</element>
<element name="TSizeConstraintsOption.scoAdviceWidthAsMin">
<short/>
</element>
<element name="TSizeConstraintsOption.scoAdviceWidthAsMax">
<short/>
</element>
<element name="TSizeConstraintsOption.scoAdviceHeightAsMin">
<short/>
</element>
<element name="TSizeConstraintsOption.scoAdviceHeightAsMax">
<short/>
</element>

<element name="TSizeConstraintsOptions">
<short>
Set type used to store values from the TSizeConstraintsOption enumeration.
</short>
<descr>
<p>
<var>TSizeConstraintsOptions</var> is a set type used to store zero or more 
values from the <var>TSizeConstraintsOption</var> enumeration. 
TSizeConstraintsOptions is the type used to implement the Options property in 
TSizeConstraints.
</p>
</descr>
<seealso>
<link id="TSizeConstraintsOption"/>
<link id="TSizeConstraints.Options"/>
</seealso>
</element>

<element name="TSizeConstraints">
<short>
Holds minimum and maximum values for the width or height of a control.
</short>
<descr>
<p>
<var>TSizeConstraints</var> is a <var>TPersistent</var> descendant which 
contains size constraints used to control the minimum or maximum width or 
height for an associated control. TSizeConstraints is the type used to 
implement the Constraints property in TControl and descendent classes.
</p>
<p>
The initial values for properties are retrieved from the widgetset class 
instance for the Control when its handle has been allocated. Values in 
TSizeConstraints properties are used when the Control is resized or its layout 
is adjusted, and prevent the control from being resized to Width or Height 
values that are in excess of the specified minimum or maximum values. If 
properties are modified in TSizeConstraints, the associated control is updated 
to apply the new size constraints (when needed).
</p>
</descr>
<seealso>
<link id="TSizeConstraints.EffectiveMaxHeight"/>
<link id="TSizeConstraints.EffectiveMaxWidth"/>
<link id="TSizeConstraints.EffectiveMinHeight"/>
<link id="TSizeConstraints.EffectiveMinWidth"/>
<link id="TSizeConstraints.MinMaxHeight"/>
<link id="TSizeConstraints.MinMaxWidth"/>
<link id="TControl.Constraints"/>
<link id="TControl.AdjustSize"/>
<link id="TControl.AutoAdjustLayout"/>
</seealso>
</element>

<element name="TSizeConstraints.FControl"/>
<element name="TSizeConstraints.FMaxHeight"/>
<element name="TSizeConstraints.FMaxInterfaceHeight"/>
<element name="TSizeConstraints.FMaxInterfaceWidth"/>
<element name="TSizeConstraints.FMaxWidth"/>
<element name="TSizeConstraints.FMinHeight"/>
<element name="TSizeConstraints.FMinInterfaceHeight"/>
<element name="TSizeConstraints.FMinInterfaceWidth"/>
<element name="TSizeConstraints.FMinWidth"/>
<element name="TSizeConstraints.FOnChange"/>
<element name="TSizeConstraints.FOptions"/>

<element name="TSizeConstraints.SetOptions">
<short>Sets the value for the Options property.</short>
<descr/>
<seealso/>
</element>
<element name="TSizeConstraints.SetOptions.AValue">
<short>New value for the Options property.</short>
</element>

<element name="TSizeConstraints.Change">
<short>
Adjusts the size for the associated Control, and signals the OnChange handler 
when assigned.
</short>
<descr>
<p>
Change causes the AdjustSize method to be called in the associated Control. 
It signals the OnChange event handler (when assigned) using the 
TSizeConstraints instance as the Sender argument in the notification.
</p>
<p>
Change is called when a new value is assigned to the MaxWidth, MinWidth, 
MaxHeight, or MinHeight properties. It is called when AssignTo is used to store 
property values from the class instance to another persistent object. It is 
also called when the AutoAdjustLayout is used to scale values in MaxWidth, 
MinWidth, MaxHeight, or MinHeight properties by a specified size factor.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Control"/>
<link id="TSizeConstraints.OnChange"/>
<link id="TSizeConstraints.AssignTo"/>
<link id="TSizeConstraints.AutoAdjustLayout"/>
<link id="TControl.AdjustSize"/>
</seealso>
</element>

<element name="TSizeConstraints.AssignTo">
<short>
Copies property values to the specified persistent object.
</short>
<descr>
<p>
<var>AssignTo</var> is an overridden method in <var>TSizeConstraints</var> used 
to implement object persistence. It ensures that properties specific to 
TSizeConstraints are stored to the persistent object in the <var>Dest</var> 
parameter, and includes the MaxHeight, MaxWidth, MinHeight, and MinWidth 
properties. The Change method is called to adjust the size for the associated 
Control, and to signal the OnChange event handler when assigned.
</p>
<p>
No actions are performed in the method if the properties in the class instance
have the same values as their counterparts in the Dest argument.
</p>
<p>
If Dest is not derived from TSizeConstraints, the inherited AssignTo method is 
called.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Change"/>
<link id="TSizeConstraints.OnChange"/>
<link id="TControl.AdjustSize"/>
<link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
</seealso>
</element>
<element name="TSizeConstraints.AssignTo.Dest">
<short>
Persistent object where property values are stored.
</short>
</element>

<element name="TSizeConstraints.SetMaxHeight">
<short>Sets the value for the MaxHeight property.</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
</seealso>
</element>
<element name="TSizeConstraints.SetMaxHeight.Value">
<short>New value for the MaxHeight property.</short>
</element>

<element name="TSizeConstraints.SetMaxWidth">
<short>Sets the value for the MaxWidth property.</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MaxWidth"/>
</seealso>
</element>
<element name="TSizeConstraints.SetMaxWidth.Value">
<short>New value for the MaxWidth property.</short>
</element>

<element name="TSizeConstraints.SetMinHeight">
<short>Sets the value for the MinHeight property.</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MinHeight"/>
</seealso>
</element>
<element name="TSizeConstraints.SetMinHeight.Value">
<short>New value for the MinHeight property.</short>
</element>

<element name="TSizeConstraints.SetMinWidth">
<short>Sets the value for the MinWidth property.</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MinWidth"/>
</seealso>
</element>
<element name="TSizeConstraints.SetMinWidth.Value">
<short>New value for the MinWidth property.</short>
</element>

<element name="TSizeConstraints.Create">
<short>
Constructor for the class instance.
</short>
<descr>
<p>
<var>Create</var> is the constructor for the class instance, and calls the 
inherited constructor on entry. Create sets the default values for properties 
including:
</p>
<ul>
<li>MaxHeight (0)</li>
<li>MaxWidth (0)</li>
<li>MinHeight (0)</li>
<li>MinWidth (0)</li>
</ul>
<p>
It also sets the value in the Control property to the associated control 
specified in the AControl argument.
</p>
<p>
Create calls the UpdateInterfaceConstraints method to ensure that size 
constraints from the Control are applied to the widgetset class instance when 
Control is a TWinControl instance and its handle has been allocated.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Control"/>
<link id="TSizeConstraints.UpdateInterfaceConstraints"/>
</seealso>
</element>
<element name="TSizeConstraints.Create.AControl">
<short>
TControl instance where the size constraints are implemented.
</short>
</element>

<element name="TSizeConstraints.UpdateInterfaceConstraints">
<short>
Applies size constraints from the specified Control to the widgetset class 
instance.
</short>
<descr>
<p>
No actions are performed in the method if Control is not derived from 
TWinControl, or its handle has not been allocated. UpdateInterfaceConstraints 
is called from the Create constructor after setting default property values, 
and assigning the associated Control for the class instance.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Control"/>
<link id="TSizeConstraints.Create"/>
</seealso>
</element>

<element name="TSizeConstraints.SetInterfaceConstraints">
<short>
Used by the LCL interface to set the widgetset constraints in the class 
instance.
</short>
<descr>
<p>
Should only be used by custom components, not by applications.
</p>
</descr>
<seealso/>
</element>
<element name="TSizeConstraints.SetInterfaceConstraints.MinW">
<short>
Minimum width provided by the widgetset class instance.
</short>
</element>
<element name="TSizeConstraints.SetInterfaceConstraints.MinH">
<short>
Minimum height provided by the widgetset class instance.
</short>
</element>
<element name="TSizeConstraints.SetInterfaceConstraints.MaxW">
<short>
Maximum width provided by the widgetset class instance.
</short>
</element>
<element name="TSizeConstraints.SetInterfaceConstraints.MaxH">
<short>
Maximum height provided by the widgetset class instance.
</short>
</element>

<element name="TSizeConstraints.EffectiveMinWidth">
<short>
Determines the minimum applicable width given the local and interface 
constraints.
</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MinMaxWidth"/>
<link id="TSizeConstraints.SetInterfaceConstraints"/>
</seealso>
</element>
<element name="TSizeConstraints.EffectiveMinWidth.Result">
<short>Zero means no size constraint is defined.</short>
</element>

<element name="TSizeConstraints.EffectiveMinHeight">
<short>
Determines the minimum applicable height given the local and interface 
constraints.
</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MinMaxHeight"/>
<link id="TSizeConstraints.SetInterfaceConstraints"/>
</seealso>
</element>
<element name="TSizeConstraints.EffectiveMinHeight.Result">
<short>Zero means no size constraint is defined.</short>
</element>

<element name="TSizeConstraints.EffectiveMaxWidth">
<short>
Determines the maximum applicable width given the local and interface 
constraints.
</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MinMaxWidth"/>
<link id="TSizeConstraints.SetInterfaceConstraints"/>
</seealso>
</element>
<element name="TSizeConstraints.EffectiveMaxWidth.Result">
<short>Zero means no size constraint is defined.</short>
</element>

<element name="TSizeConstraints.EffectiveMaxHeight">
<short>
Determines the maximum applicable height given the local and interface 
constraints.
</short>
<descr/>
<seealso>
<link id="TSizeConstraints.MinMaxHeight"/>
<link id="TSizeConstraints.SetInterfaceConstraints"/>
</seealso>
</element>
<element name="TSizeConstraints.EffectiveMaxHeight.Result">
<short>Zero means no size constraint is defined.</short>
</element>

<element name="TSizeConstraints.MinMaxWidth">
<short>
Determines the constrained Width and transfers it to the widget.
</short>
<descr/>
<seealso/>
</element>
<element name="TSizeConstraints.MinMaxWidth.Result">
<short>The actual constrained width.</short>
</element>
<element name="TSizeConstraints.MinMaxWidth.Width">
<short>The suggested width.</short>
</element>

<element name="TSizeConstraints.MinMaxHeight">
<short>
Determines the constrained Height and transfers it to the widget.
</short>
<descr/>
<seealso/>
</element>
<element name="TSizeConstraints.MinMaxHeight.Result">
<short>The actual constrained height.</short>
</element>
<element name="TSizeConstraints.MinMaxHeight.Height">
<short>The suggested height.</short>
</element>

<element name="TSizeConstraints.AutoAdjustLayout">
<short>
Adjusts width and height values in the class using the specified scaling 
factors.
</short>
<descr>
<p>
<var>AutoAdjustLayout</var> ensures that assigned (non-zero) values in 
MinHeight, MaxHeight, MinWidth, and MaxWidth are scaled by the corresponding 
scaling factor. If any of the property values are scaled, the Change method is 
called to notify the associated Control that it should adjust it size. The 
OnChange event is signalled (when assigned).
</p>
<p>
AutoAdjustLayout is called from the DoAutoAdjustLayout method in Control, and 
occurs after values in BorderSpacing have been scaled. It occurs before the new 
height and width for the Control are calculated and applied to its BaseBounds.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Control"/>
<link id="TSizeConstraints.Change"/>
<link id="TControl.DoConstraintsChange"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TControl.BorderSpacing"/>
<link id="TControl.AdjustSize"/>
<link id="TControl.BaseBounds"/>
</seealso>
</element>
<element name="TSizeConstraints.AutoAdjustLayout.AXProportion">
<short>Scaling factor applied to width values.</short>
</element>
<element name="TSizeConstraints.AutoAdjustLayout.AYProportion">
<short>Scaling factor applied to height values.</short>
</element>

<element name="TSizeConstraints.MaxInterfaceHeight">
<short>The maximum height allowed by the widget.</short>
<descr/>
<seealso/>
</element>

<element name="TSizeConstraints.MaxInterfaceWidth">
<short>The maximum width allowed by the widget.</short>
<descr/>
<seealso/>
</element>

<element name="TSizeConstraints.MinInterfaceHeight">
<short>The minimum height allowed by the widget.</short>
<descr/>
<seealso/>
</element>

<element name="TSizeConstraints.MinInterfaceWidth">
<short>The minimum width allowed by the widget.</short>
<descr/>
<seealso/>
</element>

<element name="TSizeConstraints.Control">
<short>
The associated Control to which these constraints apply.
</short>
<descr>
<p>
<var>Control</var> contains the value passed as an argument to the Create 
constructor. It represents the control which is notified and updated when 
values in the MaxHeight, MaxWidth, MinHeight, or MinWidth properties are 
changed. Control is used in the Change method to apply the new size 
constraints. It also allows access to properties in both the control and its 
widget instance - like the handle and component state.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.Create"/>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Change"/>
<link id="TControl.Constraints"/>
<link id="TControl.DoConstraintsChange"/>
</seealso>
</element>

<element name="TSizeConstraints.Options">
<short>
Options used to determine the size constraints.
</short>
<descr>
<p>
<var>Options</var> is a <var>TSizeConstraintsOptions</var> property which 
contains zero (0) or more values from the <var>TSizeConstraintsOption</var> 
enumeration. The default value for the property is an empty set (<b>[]</b>). 
Values in Options are <b>not</b> used in the current LCL implementation.
</p>
</descr>
<seealso>
<link id="TSizeConstraintsOption"/>
<link id="TSizeConstraintsOptions"/>
</seealso>
</element>

<element name="TSizeConstraints.OnChange">
<short>
Event handler signalled when a value in the class instance has been changed.
</short>
<descr>
<p>
<var>OnChange</var> is a <var>TNotifyEvent</var> property with the even handler 
signalled when one of the values in MaxHeight, MaxWidth, MinHeight, or MinWidth 
has been changed. OnChange is signalled (when assigned) from the Change method 
using the current class instance as the Sender for the notification. OnChange 
occurs after the modified constraints have been applied to the associated 
Control and its size has been adjusted.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Change"/>
<link id="TSizeConstraints.Control"/>
<link id="TControl.Constraints"/>
<link id="TControl.DoConstraintsChange"/>
<link id="TControl.AdjustSize"/>
</seealso>
</element>

<element name="TSizeConstraints.MaxHeight">
<short>
The maximum height for the associated Control.
</short>
<descr>
<p>
<var>MaxHeight</var> is a <var>TConstraintSize</var> property which contains 
the maximum height in pixels allowed for the associated Control. The default 
value for the property is 0 (zero) and indicates that the size constraint has 
not been assigned and is not enforced.
</p>
<p>
Changing the value for the property causes assigned (non-zero) values in 
MaxHeight and MinHeight to be normalized; the smaller of the two values becomes 
the MinHeight, and the larger of the two values becomes the MaxHeight. The 
Change method is called to apply the new size constraints to Control, and to 
signal the OnChange event handler (when assigned).
</p>
<p>
Use MinHeight to set minimum height for the associated Control.
</p>
<p>
Use MaxWidth and MinWidth to set the constrained width for the associated 
Control.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Change"/>
<link id="TSizeConstraints.OnChange"/>
<link id="TSizeConstraints.Control"/>
</seealso>
</element>

<element name="TSizeConstraints.MaxWidth">
<short>
The maximum width for the associated Control.
</short>
<descr>
<p>
<var>MaxWidth</var> is a <var>TConstraintSize</var> property which contains 
the maximum width in pixels allowed for the associated Control. The default 
value for the property is 0 (zero) and indicates that the size constraint has 
not been assigned and is not enforced.
</p>
<p>
Changing the value for the property causes assigned (non-zero) values in 
MaxWidth and MinWidth to be normalized; the smaller of the two values becomes 
the MinWidth, and the larger of the two values becomes the MaxWidth. The 
Change method is called to apply the new size constraints to Control, and to 
signal the OnChange event handler (when assigned).
</p>
<p>
Use MinWidth to set minimum width for the associated Control.
</p>
<p>
Use MaxHeight and MinHeight to set the constrained height for the associated 
Control.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Change"/>
<link id="TSizeConstraints.OnChange"/>
<link id="TSizeConstraints.Control"/>
</seealso>
</element>

<element name="TSizeConstraints.MinHeight">
<short>
The minimum height for the associated Control.
</short>
<descr>
<p>
<var>MinHeight</var> is a <var>TConstraintSize</var> property which contains 
the minimum height in pixels allowed for the associated Control. The default 
value for the property is 0 (zero) and indicates that the size constraint has 
not been assigned and is not enforced.
</p>
<p>
Changing the value for the property causes assigned (non-zero) values in 
MaxHeight and MinHeight to be normalized; the smaller of the two values becomes 
the MinHeight, and the larger of the two values becomes the MaxHeight. The 
Change method is called to apply the new size constraints to Control, and to 
signal the OnChange event handler (when assigned).
</p>
<p>
Use MaxHeight to set minimum height for the associated Control.
</p>
<p>
Use MaxWidth and MinWidth to set the constrained width for the associated 
Control.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.MinWidth"/>
<link id="TSizeConstraints.Change"/>
<link id="TSizeConstraints.OnChange"/>
<link id="TSizeConstraints.Control"/>
</seealso>
</element>

<element name="TSizeConstraints.MinWidth">
<short>
The minimum width for the associated Control.
</short>
<descr>
<p>
<var>MixWidth</var> is a <var>TConstraintSize</var> property which contains 
the minimum width in pixels allowed for the associated Control. The default 
value for the property is 0 (zero) and indicates that the size constraint has 
not been assigned and is not enforced.
</p>
<p>
Changing the value for the property causes assigned (non-zero) values in 
MaxWidth and MinWidth to be normalized; the smaller of the two values becomes 
the MinWidth, and the larger of the two values becomes the MaxWidth. The 
Change method is called to apply the new size constraints to Control, and to 
signal the OnChange event handler (when assigned).
</p>
<p>
Use MaxWidth to set maximum width for the associated Control.
</p>
<p>
Use MaxHeight and MinHeight to set the constrained height for the associated 
Control.
</p>
</descr>
<seealso>
<link id="TSizeConstraints.MaxHeight"/>
<link id="TSizeConstraints.MinHeight"/>
<link id="TSizeConstraints.MaxWidth"/>
<link id="TSizeConstraints.Change"/>
<link id="TSizeConstraints.OnChange"/>
<link id="TSizeConstraints.Control"/>
</seealso>
</element>

<element name="TConstrainedResizeEvent">
<short>
Specifies an event handler signalled to resize a control to the specified 
size constraints.
</short>
<descr>
<p>
<var>TConstrainedResizeEvent</var> is an object procedure type that specifies 
an event handler signalled to resize a control to the specified size 
constraints. The handler routine can update the values in the MinWidth, 
MinHeight, MaxWidth, and MaxHeight arguments if needed.
</p>
<p>
TConstrainedResizeEvent is the type used to implement the 
<var>OnConstrainedResize</var> event in <var>TControl</var>.
</p>
</descr>
<seealso>
<link id="TControl.OnConstrainedResize"/>
<link id="TControl.ConstrainedResize"/>
</seealso>
</element>
<element name="TConstrainedResizeEvent.Sender">
<short>TObject for the event notification.</short>
</element>
<element name="TConstrainedResizeEvent.MinWidth">
<short>
Variable argument with the minimum width for the resize event.
</short>
</element>
<element name="TConstrainedResizeEvent.MinHeight">
<short>
Variable argument with the minimum hright for the resize event.
</short>
</element>
<element name="TConstrainedResizeEvent.MaxWidth">
<short>
Variable argument with the maximum width for the resize event.
</short>
</element>
<element name="TConstrainedResizeEvent.MaxHeight">
<short>
Variable argument with the maximum height for the resize event.
</short>
</element>

<element name="TSpacingSize">
<short>Alias to the Integer type.</short>
<descr>
<p>
<var>TSpacingSize</var> is an alias for the <var>Integer</var> type. 
TSpacingSize is used for values that represent spacing around or between 
controls. TSpacingSize is the type used to implement properties in 
<var>TControlBorderSpacingDefault</var> and <var>TControlBorderSpacing</var>.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacingDefault"/>
<link id="TControlBorderSpacing"/>
<link id="TControl.AnchorAsAlign"/>
<link id="TControl.AnchorClient"/>
<link id="TControl.AnchorParallel"/>
<link id="TControl.AnchorToCompanion"/>
<link id="TControl.AnchorToNeighbour"/>
</seealso>
</element>

<element name="TControlCellAlign">
<short>Modes for aligning a control in a table cell.</short>
<descr/>
<seealso/>
</element>
<element name="TControlCellAlign.ccaFill">
<short>Causes the cell to fill the available space for the cell.</short>
</element>
<element name="TControlCellAlign.ccaLeftTop">
<short>Cell is aligned to the Left and Top coordinates.</short>
</element>
<element name="TControlCellAlign.ccaRightBottom">
<short>Cell is aligned to the Right and Bottom coordinates.</short>
</element>
<element name="TControlCellAlign.ccaCenter">
<short>Cell is aligned to the center of the its width and height.</short>
</element>

<element name="TControlCellAligns">
<short>
Set type used to store values from the TControlCellAlign enumeration.
</short>
<descr/>
<seealso>
<link id="TControlCellAlign"/>
</seealso>
</element>

<element name="TControlBorderSpacingDefault">
<short>Defines the default values for TControlBorderSpacing.</short>
<descr>
<p>
<var>TControlBorderSpacingDefault</var> is a record type which defines the 
default values for properties in a <var>TControlBorderSpacing</var> instance. 
Used to differentiate default values in derived <var>TControl</var> classes.
</p>
</descr>
<seealso>
<link id="TControl.BorderSpacing"/>
<link id="TControlBorderSpacing"/>
</seealso>
</element>
<element name="TControlBorderSpacingDefault.Left"/>
<element name="TControlBorderSpacingDefault.Top"/>
<element name="TControlBorderSpacingDefault.Right"/>
<element name="TControlBorderSpacingDefault.Bottom"/>
<element name="TControlBorderSpacingDefault.Around"/>

<element name="PControlBorderSpacingDefault">
<short>Pointer to a TControlBorderSpacingDefault type.</short>
<descr/>
<seealso/>
</element>

<element name="TControlBorderSpacing">
<short>Describes the (minimum) spacing around a control.</short>
<descr>
<p>
<var>TControlBorderSpacing</var> defines the number of pixels reserved as 
spacing on the various borders for a control. TControlBorderSpacing is the type 
used to implement the <var>BorderSpacing</var> property in <var>TControl</var>.
</p>
<dl>
<dt>
Left, Top, Right, Bottom: Integer;
</dt>
<dd>
Defines the space available to the auto-sized control. For example: Control A 
lies left of control B. A has borderspacing Right=10 and B has borderspacing 
Left=5. Then A and B will have a minimum space of 10 between.
</dd>
<dt>
Around: Integer;
</dt>
<dd>
Same as Left, Top, Right and Bottom but specified all at once. This will be 
added to the effective Left, Top, Right and Bottom. Example: Left=3 and 
Around=5 results in a minimum spacing to the left of 8.
</dd>
<dt>
InnerBorder: Integer;
</dt>
<dd>
This is added to the preferred size. For example: A buttons widget returns 
75x25 on GetPreferredSize. CalculatePreferredSize adds 2 times the 
InnerBorder to the width and height.
</dd>
<dt>
CellAlignHorizontal, CellAlignVertical: TControlCellAlign;
</dt>
<dd>
Used, for example, when the Parent ChildSizing.Layout defines a table layout.
</dd>
</dl>
<p>
See <link id="TWinControl.ChildSizing"/> and <link id="TControlChildSizing"/> 
for information about spacing around and between child controls on a control 
instance.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Bottom"/>
<link id="TControlBorderSpacing.InnerBorder"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.Right"/>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.CellAlignHorizontal"/>
<link id="TControlBorderSpacing.CellAlignVertical"/>
<link id="TControl.BorderSpacing"/>
<link id="TWinControl.ChildSizing"/>
</seealso>
</element>

<element name="TControlBorderSpacing.FAround"/>
<element name="TControlBorderSpacing.FBottom"/>
<element name="TControlBorderSpacing.FCellAlignHorizontal"/>
<element name="TControlBorderSpacing.FCellAlignVertical"/>
<element name="TControlBorderSpacing.FControl"/>
<element name="TControlBorderSpacing.FInnerBorder"/>
<element name="TControlBorderSpacing.FLeft"/>
<element name="TControlBorderSpacing.FOnChange"/>
<element name="TControlBorderSpacing.FRight"/>
<element name="TControlBorderSpacing.FTop"/>
<element name="TControlBorderSpacing.FDefault"/>

<element name="TControlBorderSpacing.GetAroundBottom">
<short>Gets the value for the AroundBottom property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.AroundBottom"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetAroundBottom.Result">
<short>Value for the property.</short>
</element>

<element name="TControlBorderSpacing.GetAroundLeft">
<short>Gets the value for the AroundLeft property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.AroundLeft"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetAroundLeft.Result">
<short>Value for the property.</short>
</element>

<element name="TControlBorderSpacing.GetAroundRight">
<short>Gets the value for the AroundRight property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.AroundRight"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetAroundRight.Result">
<short>Value for the property.</short>
</element>

<element name="TControlBorderSpacing.GetAroundTop">
<short>Gets the value for the AroundTop property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.AroundRight"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetAroundTop.Result">
<short>Value for the property.</short>
</element>

<element name="TControlBorderSpacing.GetControlRight">
<short>Gets the value for the ControlRight property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.ControlRight"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetControlRight.Result">
<short>Value for the property.</short>
</element>

<element name="TControlBorderSpacing.GetControlTop">
<short>Gets the value for the ControlTop property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.ControlTop"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetControlTop.Result">
<short>Value for the property.</short>
</element>

<element name="TControlBorderSpacing.GetControlWidth">
<short>Gets the value for the ControlWidth property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.ControlWidth"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetControlWidth.Result">
<short>Value for the property.</short>
</element>

<element name="TControlBorderSpacing.IsAroundStored">
<short>
Implements the storage specifier for the Around property.
</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.AroundLeft"/>
<link id="TControlBorderSpacing.AroundRight"/>
<link id="TControlBorderSpacing.AroundTop"/>
<link id="TControlBorderSpacing.AroundBottom"/>
</seealso>
</element>
<element name="TControlBorderSpacing.IsAroundStored.Result">
<short>
Returns <b>True</b> if border spacing value in Around has been assigned 
and contains a non-zero value, or when the value is different than the 
default value passed to the constructor.
</short>
</element>

<element name="TControlBorderSpacing.IsBottomStored">
<short>Implements the storage specifier for the Bottom property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Bottom"/>
</seealso>
</element>
<element name="TControlBorderSpacing.IsBottomStored.Result"/>

<element name="TControlBorderSpacing.IsInnerBorderStored">
<short>Implements the storage specifier for the InnerBorder property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.InnerBorder"/>
</seealso>
</element>
<element name="TControlBorderSpacing.IsInnerBorderStored.Result"/>

<element name="TControlBorderSpacing.IsLeftStored">
<short>Implements the storage specifier for the Left property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Left"/>
</seealso>
</element>
<element name="TControlBorderSpacing.IsLeftStored.Result"/>

<element name="TControlBorderSpacing.IsRightStored">
<short>Implements the storage specifier for the Right property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Right"/>
</seealso>
</element>
<element name="TControlBorderSpacing.IsRightStored.Result"/>

<element name="TControlBorderSpacing.IsTopStored">
<short>Implements the storage specifier for the Top property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Top"/>
</seealso>
</element>
<element name="TControlBorderSpacing.IsTopStored.Result"/>

<element name="TControlBorderSpacing.SetAround">
<short>Sets the value for the Around property.</short>
<descr/>
<seealso>
<llink id="TControlBorderSpacing.Around"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetAround.AValue">
<short>New value for the Around property.</short>
</element>

<element name="TControlBorderSpacing.SetBottom">
<short>Sets the value for the Bottom property.</short>
<descr/>
<seealso>
<llink id="TControlBorderSpacing.Bottom"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetBottom.AValue">
<short>New value for the Bottom property.</short>
</element>

<element name="TControlBorderSpacing.SetCellAlignHorizontal">
<short>Sets the value for the CellAlignHorizontal property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.CellAlignHorizontal"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetCellAlignHorizontal.AValue">
<short>New value for the CellAlignHorizontal property.</short>
</element>

<element name="TControlBorderSpacing.SetCellAlignVertical">
<short>Sets the value for the SetCellAlignVertical property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.CellAlignVertical"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetCellAlignVertical.AValue">
<short>New value for the SetCellAlignVertical property.</short>
</element>

<element name="TControlBorderSpacing.SetInnerBorder">
<short>Sets the value for the InnerBorder property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.InnerBorder"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetInnerBorder.AValue">
<short>New value for the InnerBorder property.</short>
</element>

<element name="TControlBorderSpacing.SetLeft">
<short>Sets the value for the Left property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Left"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetLeft.AValue">
<short>New value for the Left property.</short>
</element>

<element name="TControlBorderSpacing.SetRight">
<short>Sets the value for the Right property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Right"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetRight.AValue">
<short>New value for the Right property.</short>
</element>

<element name="TControlBorderSpacing.SetSpace">
<short>Sets the value for the indexed Space property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Space"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetSpace.Kind">
<short>Identifies the ordinal position in the indexed property.</short>
</element>
<element name="TControlBorderSpacing.SetSpace.AValue">
<short>New value for the indexed Space property.</short>
</element>

<element name="TControlBorderSpacing.SetTop">
<short>Sets the value for the Top property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Top"/>
</seealso>
</element>
<element name="TControlBorderSpacing.SetTop.AValue">
<short>New value for the Top property.</short>
</element>

<element name="TControlBorderSpacing.Change">
<short>Invalidates the control and signals the OnChange event handler.</short>
<descr/>
<seealso/>
</element>
<element name="TControlBorderSpacing.Change.InnerSpaceChanged">
<short>Currently ignored (distinction no longer required).</short>
</element>

<element name="TControlBorderSpacing.GetOwner">
<short>
Gets the class where the border spacing values are used.
</short>
<descr>
<p>
<var>GetOwner</var> is an overridden method in TControlBorderSpacing used to 
get the persistent object where the class instance is used. It reimplements the 
dynamic method introduced in the TPersistent ancestor to return the value in 
the Control property. To access properties /methods / events specific to a 
TPersistent descendant, the return value must be cast to the required class 
type.
</p>
</descr>
<version>
Added in LCL version 3.2.
</version>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Create"/>
<link id="#rtl.classes.TPersistent">TPersistent</link>
</seealso>
</element>
<element name="TControlBorderSpacing.GetOwner.Result">
<short>
TPersistent object where the class instance is used.
</short>
</element>

<element name="TControlBorderSpacing.Create">
<short>Constructor for the class instance.</short>
<descr/>
<seealso/>
</element>
<element name="TControlBorderSpacing.Create.OwnerControl">
<short>The associated control which owns the class instance.</short>
</element>
<element name="TControlBorderSpacing.Create.ADefault">
<short>
Pointer to a record with default settings; can be <b>Nil</b> for all zero 
defaults.
</short>
</element>

<element name="TControlBorderSpacing.Assign">
<short>
Copies property values from the specified persistent object.
</short>
<descr/>
<seealso>
<link id="#rtl.classes.TPersistent">TPersistent</link>
</seealso>
</element>
<element name="TControlBorderSpacing.Assign.Source">
<short>Persistent object with the values copied in the method.</short>
</element>

<element name="TControlBorderSpacing.AssignTo">
<short>
Copies property value from the class instance to the specified persistent 
object.
</short>
<descr/>
<seealso>
<link id="#rtl.classes.TPersistent">TPersistent</link>
</seealso>
</element>
<element name="TControlBorderSpacing.AssignTo.Dest">
<short>Persistent object where property values are stored.</short>
</element>

<element name="TControlBorderSpacing.IsEqual">
<short>
<b>True</b> when the specified spacing is the same as the current settings in 
the class instance.
</short>
<descr/>
<seealso/>
</element>
<element name="TControlBorderSpacing.IsEqual.Result">
<short>
<b>True</b> when the specified spacing is the same as the current settings in 
the class instance.
</short>
</element>
<element name="TControlBorderSpacing.IsEqual.Spacing">
<short>
TControlBorderSpacing instance with values compared to the current class 
instance.
</short>
</element>

<element name="TControlBorderSpacing.GetSpaceAround">
<short>Returns the bounds with added Around space.</short>
<descr/>
<seealso/>
</element>
<element name="TControlBorderSpacing.GetSpaceAround.SpaceAround">
<short>
Output parameter; the initial contents are ignored.
</short>
</element>

<element name="TControlBorderSpacing.GetSideSpace">
<short>
The space on a control side including Around space.
</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Space"/>
<link id="TControlBorderSpacing.GetSideSpace"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetSideSpace.Result">
<short>The space value.</short>
</element>
<element name="TControlBorderSpacing.GetSideSpace.Kind">
<short>The requested edge.</short>
</element>

<element name="TControlBorderSpacing.GetSpace">
<short>Gets the value for the indexed Space property.</short>
<descr/>
<seealso>
<link id="TControlBorderSpacing.Space"/>
</seealso>
</element>
<element name="TControlBorderSpacing.GetSpace.Result">
<short>Value for the indexed Space property.</short>
</element>
<element name="TControlBorderSpacing.GetSpace.Kind">
<short>Ordinal position for the value in the indexed property.</short>
</element>

<!-- TODO: Review. This feels wrong for some reason. -->
<element name="TControlBorderSpacing.AutoAdjustLayout">
<short>
Automatically adjusts the size of the control using the specified proportions.
</short>
<descr>
<p>
<var>AutoAdjustLayout</var> is a procedure used to automatically adjust the 
size of the control using the specified proportions.
</p>
<p>
<var>AXProportion</var> and <var>AYProportion</var> are <var>Double</var> 
values which contain the scaling factor applied to width and height values in 
corresponding properties. For example, 1.25 indicates an increase to 125% of 
the original value, and 0.5 indicates a 50% decrease in the original value.
</p>
<p>
<var>AutoAdjustLayout</var> scales the value in width and height for 
properties, including:
</p>
<ul>
<li>Around</li>
<li>InnerBorder</li>
<li>Left</li>
<li>Top</li>
<li>Right</li>
<li>Bottom</li>
</ul>
<p>
When property values are altered in the scaling operation, the 
<var>InvalidatePreferredSize</var> method is called to recalculate the 
dimensions for the control. The <var>Change</var> method is called when 
value(s) in <var>InnerBorder</var> have been altered.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.InnerBorder"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.Right"/>
<link id="TControlBorderSpacing.Bottom"/>
</seealso>
</element>
<element name="TControlBorderSpacing.AutoAdjustLayout.AXPxproportion">
<short>Scaling factor applied to width values.</short>
</element>
<element name="TControlBorderSpacing.AutoAdjustLayout.AYProportion">
<short>Scaling factor applied to height values.</short>
</element>

<element name="TControlBorderSpacing.Control">
<short>
The control where the border spacing values are applied.
</short>
<descr/>
<seealso/>
</element>

<element name="TControlBorderSpacing.Space">
<short>
Provides indexed access to the border spacing value for a given anchor side.
</short>
<descr>
<p>
<var>Space</var> is an indexed <var>Integer</var> property which provides 
access to the border spacing used for a specified <var>TAnchorKind</var> value.
</p>
<p>
For example:
</p>
<code>AControl.BorderSpacing.Space[akTop] := 6;</code>
<p>
Which is equivalent to:
</p>
<code>AControl.BorderSpacing.Top := 6;</code>
</descr>
<seealso>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.Right"/>
<link id="TControlBorderSpacing.Bottom"/>
<link id="TControl.BorderSpacing"/>
<link id="TAnchorKind"/>
</seealso>
</element>
<element name="TControlBorderSpacing.Space.Kind">
<short>
The side with border spacing accessed in the property.
</short>
</element>

<element name="TControlBorderSpacing.AroundLeft">
<short>
Total border spacing reserved using the Around and Left properties.
</short>
<descr>
<p>
<var>AroundLeft</var> is a read-only <var>Integer</var> property which 
indicates the spacing used around and on the left-hand side of the control.
</p>
<p>
AroundLeft is calculated as the sum of the values in the <var>Around</var> 
and <var>Left</var> properties. Updates must be performed to the Around and 
Left properties.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.AroundRight"/>
</seealso>
</element>

<element name="TControlBorderSpacing.AroundTop">
<short>
Total border spacing reserved using the Around and Top properties.
</short>
<descr>
<p>
<var>AroundTop</var> is a read-only <var>Integer</var> property which 
indicates the spacing used around and on the top side of the control.
</p>
<p>
AroundTop is calculated as the sum of the values in the <var>Around</var> 
and <var>Top</var> properties. Updates must be performed to the Around and 
Top properties.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.AroundBottom"/>
</seealso>
</element>

<element name="TControlBorderSpacing.AroundRight">
<short>
Total border spacing reserved using the Around and Right properties.
</short>
<descr>
<p>
<var>AroundRight</var> is a read-only <var>Integer</var> property which 
indicates the spacing used around and on the right-hand edge of the control.
</p>
<p>
AroundRight is calculated as the sum of the values in the <var>Around</var> 
and <var>Right</var> properties. Updates must be performed to the Around and 
Right properties.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Right"/>
<link id="TControlBorderSpacing.AroundLeft"/>
</seealso>
</element>

<element name="TControlBorderSpacing.AroundBottom">
<short>
Total border spacing reserved using the Around and Bottom properties.
</short>
<descr>
<p>
<var>AroundBottom</var> is a read-only <var>Integer</var> property which 
indicates the spacing used around and on the bottom side of the control.
</p>
<p>
AroundBottom is calculated as the sum of the values in the <var>Around</var> 
and <var>Bottom</var> properties. Updates must be performed to the Around and 
Bottom properties.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Bottom"/>
<link id="TControlBorderSpacing.AroundTop"/>
</seealso>
</element>

<element name="TControlBorderSpacing.ControlLeft">
<short>
Position for the left-hand edge of the associated Control after it has been 
adjusted for border spacing.
</short>
<descr>
<p>
<var>ControlLeft</var> is a read-only <var>Integer</var> property. Its value is 
calculated as the difference between the <var>Left</var> property in the 
<var>Control</var> and the values in the <var>Around</var> and <var>Left</var> 
properties for the class instance. 
</p>
<p>
For example:
</p>
<code>Control.Left - Around - Left</code>
<p>
If a <var>TControl</var> instance is not available in <var>Control</var>, the 
value for the property is <b>0</b> (<b>zero</b>).
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.ControlWidth"/>
<link id="TControl.Left"/>
</seealso>
</element>

<element name="TControlBorderSpacing.ControlTop">
<short>
Position for the top edge of the associated Control after it has been 
adjusted for border spacing.
</short>
<descr>
<p>
<var>ControlTop</var> is a read-only <var>Integer</var> property. Its value is 
calculated as the difference between the <var>Top</var> property in the 
<var>Control</var> and the values in the <var>Around</var> and <var>Top</var> 
properties.
</p>
<p>
For example:
</p>
<code>Control.Top - Around - Top</code>
<p>
If a <var>TControl</var> instance is not available in <var>Control</var>, the 
value for the property is <b>0</b> (<b>zero</b>).
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.ControlHeight"/>
<link id="TControl.Top"/>
</seealso>
</element>

<element name="TControlBorderSpacing.ControlWidth">
<short>
Total width for the control including border spacing values in Around, Left, 
and Right.
</short>
<descr>
<p>
<var>ControlWidth</var> is a read-only <var>Integer</var> property that 
contains the total width for the control including spacing values in the 
<var>Around</var>, <var>Left</var>, and <var>Right</var> properties. The 
property value is calculated using the following formula:
</p>
<code>Control.Width + (2 * Around) + Left + Right</code>
<p>
If a <var>TControl</var> instance is not available in <var>Control</var>, the 
value for the property is <b>0</b> (<b>zero</b>).
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.Right"/>
<link id="TControlBorderSpacing.ControlHeight"/>
<link id="TControl.Width"/>
</seealso>
</element>

<element name="TControlBorderSpacing.ControlHeight">
<short>
Total height for the control including border spacing values in Around, Top, 
and Bottom.
</short>
<descr>
<p>
<var>ControlHeight</var> is a read-only <var>Integer</var> property with the 
total height for the associated <var>Control</var> including border spacing 
values. The property value is calculated using the following formula:
</p>
<code>Control.Height + (2 * Around) + Top + Bottom</code>
<p>
If a <var>TControl</var> instance is not available in <var>Control</var>, the 
value for the property is <b>0</b> (<b>zero</b>).
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.Bottom"/>
<link id="TControlBorderSpacing.ControlWidth"/>
<link id="TControl.Height"/>
</seealso>
</element>

<element name="TControlBorderSpacing.ControlRight">
<short>
Position for the right-hand edge of the associated Control after it has been 
adjusted for border spacing.
</short>
<descr>
<p>
<var>ControlRight</var> is a read-only <var>Integer</var> property. Its value 
is calculated as the sum of the <var>Left</var> property in the 
<var>Control</var>, its <var>Width</var>, and the values in the 
<var>Around</var> and <var>Right</var> properties for the class instance. 
</p>
<p>
For example:
</p>
<code>Control.Left + Control.Width + Around + Right</code>
<p>
If a <var>TControl</var> instance is not available in <var>Control</var>, the 
value for the property is <b>0</b> (<b>zero</b>).
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Right"/>
<link id="TControlBorderSpacing.ControlLeft"/>
<link id="TControl.Left"/>
<link id="TControl.Width"/>
</seealso>
</element>

<element name="TControlBorderSpacing.ControlBottom">
<short>
Position for the bottom of the associated Control including assigned border 
spacing.
</short>
<descr>
<p>
<var>ControlBottom</var> is a read-only <var>Integer</var> property. Its value 
is calculated as the sum of the <var>Top</var> property in the 
<var>Control</var> and its <var>Height</var> with the values in the 
<var>Around</var> and <var>Bottom</var> properties.
</p>
<p>
For example:
</p>
<code>Control.Top + Control.Height + Around + Bottom</code>
<p>
If a <var>TControl</var> instance is not available in <var>Control</var>, the 
value for the property is <b>0</b> (<b>zero</b>).
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Bottom"/>
<link id="TControlBorderSpacing.ControlWidth"/>
<link id="TControl.Top"/>
<link id="TControl.Height"/>
</seealso>
</element>

<element name="TControlBorderSpacing.OnChange">
<short>
Event handler signalled when border spacing value(s) have been changed.
</short>
<descr>
<p>
<var>OnChange</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled when one of the properties in the class instance has been 
changed. OnChange is signalled (when assigned) from the Change method. It 
occurs after the border spacing values have been applied to the associated 
Control, and its size has been adjusted.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.Control"/>
<link id="TControl.DoBorderSpacingChange"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControlBorderSpacing.Left">
<short>
The border space on the left edge of the associated control.
</short>
<descr>
<p>
<var>Left</var> is a <var>TSpacingSize</var> property which indicates the 
number of pixels used as border spacing for the associated <var>Control</var>. 
It specifies the minimum distance between either the left edge of the parent 
control or the right edge of an adjacent sibling control.
</p>
<p>
Changing the value for the property causes the <var>Change</var> method to be 
called to notify and apply modifications to the associated Control, and to 
signal the <var>OnChange</var> event handler (when assigned).
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder may be scaled by X 
and Y scaling factors when the AutoAdjustLayout method is called.
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder are used in Control 
methods which anchor or adjust the layout and size for the control instance on 
its parent control.
</p>
<p>
Use Right to specify the border spacing on the right-hand edge of the 
associated Control.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.AutoAdjustLayout"/>
<link id="TWinControl.AlignControls"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.CalculatePreferredSize"/>
<link id="TControl.Parent"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TControl.AnchorToNeighbour"/>
<link id="TControl.AnchorAsAlign"/>
<link id="TSpacingSize"/>
</seealso>
</element>

<element name="TControlBorderSpacing.Top">
<short>
The border space on the top edge of the associated control.
</short>
<descr>
<p>
<var>Top</var> is a <var>TSpacingSize</var> property which indicates the number 
of pixels used as border spacing for the associated <var>Control</var>. It 
specifies the minimum distance between either the top edge of the parent 
control or the bottom edge of an adjacent sibling control.
</p>
<p>
Changing the value for the property causes the <var>Change</var> method to be 
called to notify and apply modifications to the associated Control, and to 
signal the <var>OnChange</var> event handler (when assigned).
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder may be scaled by X 
and Y scaling factors when the AutoAdjustLayout method is called.
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder are used in Control 
methods which anchor or adjust the layout and size for the control instance on 
its parent control.
</p>
<p>
Use Bottom to specify the border spacing on the bottom edge of the 
associated Control.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Bottom"/>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.AutoAdjustLayout"/>
<link id="TWinControl.AlignControls"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.CalculatePreferredSize"/>
<link id="TControl.Parent"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TControl.AnchorToNeighbour"/>
<link id="TControl.AnchorAsAlign"/>
<link id="TSpacingSize"/>
</seealso>
</element>

<element name="TControlBorderSpacing.Right">
<short>
The border space on the right edge of the associated control.
</short>
<descr>
<p>
<var>Right</var> is a <var>TSpacingSize</var> property which indicates the 
number of pixels used as border spacing for the associated <var>Control</var>. 
It specifies the minimum distance between either the right edge of the parent 
control or the left edge of an adjacent sibling control.
</p>
<p>
Changing the value for the property causes the <var>Change</var> method to be 
called to notify and apply modifications to the associated Control, and to 
signal the <var>OnChange</var> event handler (when assigned).
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder may be scaled by X 
and Y scaling factors when the AutoAdjustLayout method is called.
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder are used in Control 
methods which anchor or adjust the layout and size for the control instance on 
its parent control.
</p>
<p>
Use Left to specify the border spacing on the left-hand edge of the associated 
Control.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.AutoAdjustLayout"/>
<link id="TWinControl.AlignControls"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.CalculatePreferredSize"/>
<link id="TControl.Parent"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TControl.AnchorToNeighbour"/>
<link id="TControl.AnchorAsAlign"/>
<link id="TSpacingSize"/>
</seealso>
</element>

<element name="TControlBorderSpacing.Bottom">
<short>
The border space on the bottom edge of the associated control.
</short>
<descr>
<p>
<var>Bottom</var> is a <var>TSpacingSize</var> property which indicates the 
number of pixels used as border spacing for the associated <var>Control</var>. 
It specifies the minimum distance between either the bottom edge of the parent 
control or the top edge of an adjacent sibling control.
</p>
<p>
Changing the value for the property causes the <var>Change</var> method to be 
called to notify and apply modifications to the associated Control, and to 
signal the <var>OnChange</var> event handler (when assigned).
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder may be scaled by X 
and Y scaling factors when the AutoAdjustLayout method is called.
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder are used in Control 
methods which anchor or adjust the layout and size for the control instance on 
its parent control.
</p>
<p>
Use Bottom to specify the border spacing on the bottom edge of the 
associated Control.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Around"/>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.AutoAdjustLayout"/>
<link id="TWinControl.AlignControls"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.CalculatePreferredSize"/>
<link id="TControl.Parent"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TControl.AnchorToNeighbour"/>
<link id="TControl.AnchorAsAlign"/>
<link id="TSpacingSize"/>
</seealso>
</element>

<element name="TControlBorderSpacing.Around">
<short>
The border space on each of the edges for the associated control.
</short>
<descr>
<p>
<var>Around</var> is a is a <var>TSpacingSize</var> property which indicates 
the number of pixels used as border spacing for the associated 
<var>Control</var>. It specifies the minimum distance between an edge on the 
parent control or an adjacent edge on a sibling control.
</p>
<p>
Changing the value for the property causes the <var>Change</var> method to be 
called to notify and apply modifications to the associated Control, and to 
signal the <var>OnChange</var> event handler (when assigned).
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder may be scaled by X 
and Y scaling factors when the AutoAdjustLayout method is called.
</p>
<p>
Values in Left, Right, Top, Bottom, Around, and InnerBorder are used in Control 
methods which anchor or adjust the layout and size for the control instance on 
its parent control. Around is applied independent of values in the Left, Right, 
Top, or Bottom properties; the effective border spacing is always a sum of the 
value in Around and the corresponding property for a given edge.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Top"/>
<link id="TControlBorderSpacing.Left"/>
<link id="TControlBorderSpacing.Right"/>
<link id="TControlBorderSpacing.Bottom"/>
<link id="TControlBorderSpacing.AutoAdjustLayout"/>
<link id="TWinControl.AlignControls"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.CalculatePreferredSize"/>
<link id="TControl.Parent"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TControl.AnchorToNeighbour"/>
<link id="TControl.AnchorAsAlign"/>
<link id="TSpacingSize"/>
</seealso>
</element>

<element name="TControlBorderSpacing.InnerBorder">
<short>
Space added to the <link id="TControl.GetPreferredSize">preferred 
size</link> for the widget.
</short>
<descr>
<p>
When <link id="TControl.GetPreferredSize">calculating the preferred 
size</link> of the associated Control, the LCL checks the widget first.
</p>
<p>
If the widget has a preferred size, such as a TButton widget, then the 
InnerBorder value is added to increase the Height or Width of the control at 
both of the opposing borders; Top and Bottom for preferred height, Left and 
Right for preferred width.
</p>
<p>
If the widget does not return a preferred size, the InnerBorder has no effect.
</p>
<p>
Changing the value for the property causes the Change method to be called to 
recalculate the preferred size for the associated Control, and to signal the 
OnChange event handler (when assigned).
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.OnChange"/>
<link id="TWinControl.CalculatePreferredSize"/>
</seealso>
</element>

<element name="TControlBorderSpacing.CellAlignHorizontal">
<short>
The horizontal alignment of the associated Control when the control ChildSizing 
uses a tabular layout.
</short>
<descr>
<p>
<var>CellAlignHorizontal</var> is a <var>TControlCellAlign</var> property which 
controls the horizontal alignment and sizing of the control when its Parent 
uses a tabular layout for child controls. The default value for the property is 
<var>caFill</var> and causes the control to be resized to horizontally fill the 
cell where the control is displayed.
</p>
<p>
See <link id="TControlCellAlign">TControlCellAlign</link>  for more information 
about the values in the enumeration and their meanings.
</p>
<p>
Changing the value for the property causes the Change method to be called to 
recalculate the preferred size for the associated Control, and to signal the 
OnChange event handler (when assigned).
</p>
<p>
The value in CellAlignHorizontal is used when the AlignControls method in the 
associated Control is called.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.CellAlignVertical"/>
<link id="TControlCellAlign"/>
<link id="TWinControl.ChildSizing"/>
<link id="TWinControl.AlignControls"/>
</seealso>
</element>

<element name="TControlBorderSpacing.CellAlignVertical">
<short>
The vertical alignment of the associated Control when the control ChildSizing 
uses a tabular layout.
</short>
<descr>
<p>
<var>CellAlignVertical</var> is a <var>TControlCellAlign</var> property which 
controls the vertical alignment and sizing of the control when its Parent 
uses a tabular layout for child controls. The default value for the property is 
<var>caFill</var> and causes the control to be resized to vertically fill the 
cell where the control is displayed.
</p>
<p>
See <link id="TControlCellAlign">TControlCellAlign</link> for more information 
about the values in the enumeration and their meanings.
</p>
<p>
Changing the value for the property causes the Change method to be called to 
recalculate the preferred size for the associated Control, and to signal the 
OnChange event handler (when assigned).
</p>
<p>
The value in CellAlignVertical is used when the AlignControls method in the 
associated Control is called.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing.Control"/>
<link id="TControlBorderSpacing.Change"/>
<link id="TControlBorderSpacing.CellAlignHorizontal"/>
<link id="TControlCellAlign"/>
<link id="TWinControl.ChildSizing"/>
<link id="TWinControl.AlignControls"/>
</seealso>
</element>

<element name="TAnchorSideChangeOperation">
<short>Operations in <link id="TControl.ForeignAnchorSideChanged"/></short>
<descr/>
<seealso/>
</element>
<element name="TAnchorSideChangeOperation.ascoAdd">
<short>AnchorSide added.</short>
</element>
<element name="TAnchorSideChangeOperation.ascoRemove">
<short>AnchorSide removed.</short>
</element>
<element name="TAnchorSideChangeOperation.ascoChangeSide">
<short>AnchorSide changed.</short>
</element>

<element name="TAnchorSide">
<short>
Specifies how the side of a control is anchored to other controls.
</short>
<descr>
<p>
Class holding the reference sides of the anchors of a TControl. Every 
TControl has four AnchorSides: AnchorSide[akLeft], AnchorSide[akRight], 
AnchorSide[akTop] and AnchorSide[akBottom]. Normally if Anchors contain 
akLeft, and the Parent is resized, the LCL tries to keep the distance between 
the left side of the control and the right side of its parent client area. 
With AnchorSide[akLeft] you can define a different reference side. The kept 
distance is defined by the BorderSpacing. For example:
</p>
<code>
+-----+  +-----+
|  B  |  |  C  |
|     |  +-----+
+-----+
</code>
<p>
If you want to have the top of B the same as the top of C use
</p>
<code>
  B.AnchorSide[akTop].Side:=asrTop;
  B.AnchorSide[akTop].Control:=C;
</code>
<p>
If you want to keep a distance of 10 pixels between B and C use
</p>
<code>
  B.BorderSpacing.Right:=10;
  B.AnchorSide[akRight].Side:=asrLeft;
  B.AnchorSide[akRight].Control:=C;
</code>
<p>
Do not setup in both directions, because this will create a circle, and 
circles are not allowed.
</p>
<p>
Another example:
</p>
<code>
+-------+
|       | +---+
|   B   | | A |
|       | +---+
+-------+
</code>
<p>
Centering A relative to B:
</p>
<code>
  A.AnchorSide[akTop].Side:=asrCenter;
  A.AnchorSide[akTop].Control:=B;
</code>
<p>
Or use this equivalent:
</p>
<code>
  A.AnchorSide[akBottom].Side:=asrCenter;
  A.AnchorSide[akBottom].Control:=B;
</code>
</descr>
<seealso/>
</element>

<element name="TAnchorSide.FControl"/>
<element name="TAnchorSide.FKind"/>
<element name="TAnchorSide.FOwner"/>
<element name="TAnchorSide.FSide"/>

<element name="TAnchorSide.IsSideStored">
<short>
Determines if the Control uses an anchor on the side specified in Kind.
</short>
<descr>
<p>
Not used in the current LCL implementation.
</p>
</descr>
<seealso>
<link id="DefaultSideForAnchorKind"/>
<link id="TAnchorKind"/>
<link id="TAnchorSideReference"/>
</seealso>
</element>
<element name="TAnchorSide.IsSideStored.Result">
<short>
Returns <b>True</b> if Control is assigned and the Side property contains a 
value other than the one in DefaultSideForAnchorKind.
</short>
</element>

<element name="TAnchorSide.SetControl">
<short>Sets the value for the Control property.</short>
<descr/>
<seealso>
<link id="TAnchorSide.Control"/>
</seealso>
</element>
<element name="TAnchorSide.SetControl.AValue">
<short>New value for the Control property.</short>
</element>

<element name="TAnchorSide.SetSide">
<short>Sets the value for the Side property.</short>
<descr/>
<seealso>
<link id="TAnchorSide.Side"/>
</seealso>
</element>
<element name="TAnchorSide.SetSide.AValue">
<short>New value for the Side property.</short>
</element>

<element name="TAnchorSide.GetOwner">
<short>Gets the owner of the persistent object.</short>
<descr/>
<seealso>
<link id="#rtl.classes.TPersistent">TPersistent</link>
</seealso>
</element>
<element name="TAnchorSide.GetOwner.Result">
<short>Owner of the persistent object.</short>
</element>

<element name="TAnchorSide.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the constructor for the class instance.
</p>
<p>
Create calls the inherited constructor, and sets the values in the 
<var>Owner</var>, <var>Kind</var>, and <var>Side</var> properties. The 
default value for Side is <var>asrTop</var>.
</p>
</descr>
<seealso></seealso>
</element>
<element name="TAnchorSide.Create.TheOwner">
<short>Owner of the class instance.</short>
</element>
<element name="TAnchorSide.Create.TheKind">
<short>TAnchorKind value for the Kind property.</short>
</element>

<element name="TAnchorSide.Destroy">
<short>Destructor for the class instance.</short>
<descr/>
<seealso/>
</element>

<element name="TAnchorSide.GetSidePosition">
<short>
Get information about the target control, side and side position.
</short>
<descr/>
<seealso/>
</element>
<element name="TAnchorSide.GetSidePosition.ReferenceControl">
<short>The control we are anchored to.</short>
</element>
<element name="TAnchorSide.GetSidePosition.ReferenceSide">
<short>The side we are anchored to.</short>
</element>
<element name="TAnchorSide.GetSidePosition.Position">
<short>Position of the side to anchor to.</short>
</element>

<element name="TAnchorSide.CheckSidePosition">
<short>
Checks for anchor cycles and invalid targets, and returns information about 
the target side.
</short>
<descr/>
<errors>
Can raise an exception with the message: <b>'TAnchorSide.CheckSidePosition 
invalid Side'.</b>
</errors>
<seealso/>
</element>
<element name="TAnchorSide.CheckSidePosition.Result">
<short> <b>False</b> when errors have been found.</short>
</element>
<element name="TAnchorSide.CheckSidePosition.NewControl">
<short/>
</element>
<element name="TAnchorSide.CheckSidePosition.NewSide">
<short/>
</element>
<element name="TAnchorSide.CheckSidePosition.ReferenceControl">
<short>The control we are anchored to.</short>
</element>
<element name="TAnchorSide.CheckSidePosition.ReferenceSide">
<short>The side we are anchored to.</short>
</element>
<element name="TAnchorSide.CheckSidePosition.Position">
<short>Position of the side to anchor to.</short>
</element>

<element name="TAnchorSide.Assign">
<short>
Copies properties from the specified persistent object into the current class 
instance.
</short>
<descr>
<p>
<var>Assign</var> is an overridden method in <var>TAnchorSide</var> used to 
copy property values from the persistent object in <var>Source</var> into the 
current class instance. When Source is derived from <var>TAnchorSide</var>, 
the following properties are copied:
</p>
<ul>
<li>Side</li>
<li>Control</li>
</ul>
<p>
If Source is not derived from TAnchorSide, the inherited method is called 
using Source as an argument.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TPersistent">TPersistent</link>
</seealso>
</element>
<element name="TAnchorSide.Assign.Source">
<short>Persistent object with the properties copied in the method.</short>
</element>

<element name="TAnchorSide.IsAnchoredToParent">
<short>
<b>True</b> when we are anchored to our parent, at least on the ParentSide.
</short>
<descr/>
<seealso/>
</element>
<element name="TAnchorSide.IsAnchoredToParent.Result">
<short/>
</element>
<element name="TAnchorSide.IsAnchoredToParent.ParentSide">
<short/>
</element>

<element name="TAnchorSide.FixCenterAnchoring">
<short>Remove conflicting anchors.</short>
<descr>
<p>
With <var>asrCenter</var>, both sides are controlled by one anchor. Disable 
opposite anchor and all aligning.
</p>
</descr>
<seealso/>
</element>

<element name="TAnchorSide.Owner">
<short>The control being anchored.</short>
<descr>
<p>
For example:
</p>
<code>AButton1.AnchorSide[akBottom].Owner = AButton1</code>
</descr>
<seealso/>
</element>

<element name="TAnchorSide.Kind">
<short>The control side being anchored.</short>
<descr>
<p>
Every control has four AnchorSide elements, one for each side. For example:
</p>
<code>AButton1.AnchorSide[akLeft].Kind := akLeft.</code>
</descr>
<seealso/>
</element>

<element name="TAnchorSide.Control">
<short>The target control of the anchor.</short>
<descr>
<p>
For example: if the right side of a Button1 is anchored to the left side of 
Edit1, then:
</p>
<code>Button1.AnchorSide[akRight].Control // contains Edit1</code>
<p>and</p>
<code>Button1.AnchorSide[akRight].Side // contains asrLeft</code>
</descr>
<seealso/>
</element>

<element name="TAnchorSide.Side">
<short>The side of the target Control, to which we anchor.</short>
<descr>
<p>
For example, if the right side of a Button1 is anchored to the left side of 
Edit1, then:
</p>
<code>Button1.AnchorSide[akRight].Control=Edit1</code>
<p>and</p>
<code>Button1.AnchorSide[akRight].Side=asrLeft</code>
</descr>
<seealso/>
</element>

<element name="TControlActionLink">
<short>Links an Action to a control.</short>
<descr>
<p>
An ActionLink is created when an Action is assigned to the control.
TControl.Action effectively becomes TControl.ActionLink.Action.
</p>
<p>
An ActionLink propagates changes in Action properties to the client control. 
It's assumed that properties of the <b>same value</b> (in the Control and 
Action) are linked to the Action, and follow changes to the Action properties.
</p>
<p>
Linked control properties are (by default):
</p>
<ul>
<li>Caption</li>
<li>Enabled</li>
<li>Hint</li>
<li>
HelpContext, HelpKeyword, HelpType: these are linked only if all three 
property values match.
</li>
<li>Visible</li>
<li>OnClick is linked to Action.Execute</li>
</ul>
<p>
The control can update itself, when it receives a Change notification from 
the ActionLink <link id="TControl.ActionChange"/>.
</p>
</descr>
<seealso/>
</element>

<element name="TControlActionLink.FClient">
<short>The client control that is linked to the action.</short>
<descr>It can be assumed that FClient is not <b>Nil</b>.</descr>
</element>

<element name="TControlActionLink.AssignClient">
<short>Called during construction, sets FClient to the given control.</short>
<seealso>
<link id="#rtl.classes.TBasicActionLink">TBasicActionLink</link>
</seealso>
</element>
<element name="TControlActionLink.AssignClient.AClient">
<short>The control linked to the action.</short>
</element>

<element name="TControlActionLink.SetCaption">
<short>
Sets the client Caption when it is linked to the Action for the control.
</short>
<descr/>
<seealso>
<link id="#lcl.actnlist.TActionLink.SetCaption">TActionLink.SetCaption</link>
</seealso>
</element>
<element name="TControlActionLink.SetCaption.Value">
<short>
New value for the Caption property in the client control.
</short>
</element>

<element name="TControlActionLink.SetEnabled">
<short>
Sets the client Enabled property when it is linked to the action.
</short>
<descr/>
<seealso>
<link id="#lcl.actnlist.TActionLink.SetEnabled">TActionLink.SetEnabled</link>
</seealso>
</element>
<element name="TControlActionLink.SetEnabled.Value">
<short>
New value for the Enabled property in the client control.
</short>
</element>

<element name="TControlActionLink.SetHint">
<short>
Sets client Hint when it is linked to the action.
</short>
<descr/>
<seealso>
<link id="#lcl.actnlist.TActionLink.SetHint">TActionLink.SetHint</link>
</seealso>
</element>
<element name="TControlActionLink.SetHint.Value">
<short>
New value for the Hint property in the client control.
</short>
</element>

<element name="TControlActionLink.SetHelpContext">
<short>
Sets the HelpContext, if the old Help properties match (IsHelpLinked).
</short>
<descr/>
<seealso/>
</element>
<element name="TControlActionLink.SetHelpContext.Value">
<short>
New value for the HelpContext property in the client control.
</short>
</element>

<element name="TControlActionLink.SetHelpKeyword">
<short>
Sets the HelpKeyword, if the old Help properties match (IsHelpLinked).
</short>
<descr/>
<seealso/>
</element>
<element name="TControlActionLink.SetHelpKeyword.Value">
<short>
New value for the HelpKeyword property in the client control.
</short>
</element>

<element name="TControlActionLink.SetHelpType">
<short>
Sets the HelpType, if the old Help properties match (IsHelpLinked).
</short>
<descr/>
<seealso/>
</element>
<element name="TControlActionLink.SetHelpType.Value">
<short>
New value for the HelpType property in the client control.
</short>
</element>

<element name="TControlActionLink.SetVisible">
<short>
Sets the Visible property in the client, if the old values match.
</short>
<descr/>
<seealso/>
</element>
<element name="TControlActionLink.SetVisible.Value">
<short>
New value for the Visible property in the client control.
</short>
</element>

<element name="TControlActionLink.SetOnExecute">
<short>Set OnClick handler for the client, if the old values match.</short>
<descr>
<p>
Formerly, this method changed the OnClick event handler for the client 
control. That action no longer need because TControl.Click now calls the 
OnExecute handler in the action.
</p>
<p>
In the current LCL version, this method is a NOP.
</p>
</descr>
<seealso/>
</element>
<element name="TControlActionLink.SetOnExecute.Value">
<short>
New value for the OnClick event handler in the client control.
</short>
</element>

<element name="TControlActionLink.IsOnExecuteLinked">
<short>
<b>True</b> if the OnClick handler in the client is the same routine assigned 
to the OnExecute handler in the action.
</short>
<descr/>
<seealso/>
</element>
<element name="TControlActionLink.IsOnExecuteLinked.Result">
<short>
<b>True</b> if the OnClick handler in the client is the same routine assigned 
to the OnExecute handler in the action.
</short>
</element>

<element name="TControlActionLink.DoShowHint">
<short>
Formats the hint string for the client control when it includes a ShortCut or accelerator key.
</short>
<descr/>
<p>
<var>DoShowHint</var> is a <var>Boolean</var> function used to build a hint 
string for the client control when it includes a shortcut or accelerator key. 
In short, a HintStr like:
</p>
<code>'&amp;Save your work.'</code>
<p>
Is formatted as:
</p>
<code>'Save your work. (Ctrl+S)'</code>
<p>
No actions are performed in the method if the Action is not derived from 
TCustomAction, HintShortCuts has not been enabled in the Application, or the 
action has the value scNone in its ShortCut property.
</p>
<p>
DoShowHint signals the OnHint event handler in the action (when assigned) to 
get custom hint text. HintStr is replaced with the combined value for the 
hint text and the ShortCut for the Action. ShortCutToText is called to 
convert the TShortCut value to its string representation like 'Ctrl+S'.
</p>
<p>
The return value is always <b>True</b>.
</p>
<seealso>
<link id="#lcl.actnlist.TCustomAction.DoHint">TCustomAction.DoHint</link>
<link id="#lcl.actnlist.TCustomAction.OnHint">TCustomAction.OnHint</link>
<link id="#lcl.actnlist.TCustomAction.ShortCut">TCustomAction.ShortCut</link>
<link id="#lcl.forms.TApplication.HintShortCuts">TApplication.HintShortCuts</link>
</seealso>
</element>
<element name="TControlActionLink.DoShowHint.Result">
<short>Always <b>True</b>.</short>
</element>
<element name="TControlActionLink.DoShowHint.HintStr">
<short>The hint text for the client control.</short>
</element>

<element name="TControlActionLink.IsCaptionLinked" link="#lcl.actnlist.TActionLink.IsCaptionLinked"/>
<element name="TControlActionLink.IsCaptionLinked.Result"/>

<element name="TControlActionLink.IsEnabledLinked" link="#lcl.actnlist.TActionLink.IsEnabledLinked"/>
<element name="TControlActionLink.IsEnabledLinked.Result"/>

<element name="TControlActionLink.IsHelpLinked">
<short>
Help properties are assumed linked only when all these properties match.
</short>
<descr>Compares the HelpContext, HelpKeyword and HelpType properties.</descr>
<seealso>
<link id="#lcl.actnlist.TActionLink.IsHelpLinked">TActionLink.IsHelpLinked</link>
</seealso>
</element>
<element name="TControlActionLink.IsHelpLinked.Result">
<short>
<b>True</b> only if all three Control properties match the Action properties.
</short>
</element>

<element name="TControlActionLink.IsHintLinked" link="#lcl.actnlist.TActionLink.IsHintLinked"/>
<element name="TControlActionLink.IsHintLinked.Result"/>

<element name="TControlActionLink.IsVisibleLinked" link="#lcl.actnlist.TActionLink.IsVisibleLinked"/>
<element name="TControlActionLink.IsVisibleLinked.Result"/>

<element name="TControlActionLinkClass">
<short>
Class type used to create new instances of TControlActionLink.
</short>
<descr/>
<seealso>
<link id="TControlActionLink"/>
</seealso>
</element>

<element name="ELayoutException">
<short>
Exception raised when a loop is detected when adjusting the size for controls.
</short>
<descr>
<p>
<var>ELayoutException</var> is an <var>Exception</var> descendant that 
implements the exception raised when a loop is detected when adjusting the 
size for controls, or when an invalid value is assigned to the control width 
or height.
</p>
</descr>
<seealso>
<link id="TControl.AdjustSize"/>
<link id="TControl.EnableAutoSizing"/>
<link id="TControl.ChangeBounds"/>
<link id="TControl.Width"/>
<link id="TControl.Height"/>
</seealso>
</element>

<element name="TControlAutoSizePhase">
<short>Represents AutoSizing phases for controls.</short>
<descr>
<p>
<var>TControlAutoSizePhase</var> is an enumerated type with values that 
represent phases or steps in the auto-sizing process for controls. Values 
from TControlAutoSizePhase are stored in the 
<var>TControlAutoSizePhases</var> set type.
</p>
</descr>
<seealso>
<link id="TControlAutoSizePhases"/>
<link id="TControl.AutoSizePhases"/>
<link id="TWinControl.AutoSizePhases"/>
</seealso>
</element>
<element name="TControlAutoSizePhase.caspNone">
<short/>
</element>
<element name="TControlAutoSizePhase.caspChangingProperties">
<short>
Indicates propertied have been locked while auto-sizing is active. 
</short>
</element>
<element name="TControlAutoSizePhase.caspCreatingHandles">
<short>Create/Destroy handles.</short>
</element>
<element name="TControlAutoSizePhase.caspComputingBounds">
<short>
Indicates that auto-sizing for a control and its child controls is being 
performed.
</short>
</element>
<element name="TControlAutoSizePhase.caspRealizingBounds">
<short>
Indicates that the wcfRealizingBounds flag is present in the control flags.
</short>
</element>
<element name="TControlAutoSizePhase.caspShowing">
<short>Makes a handle visible.</short>
</element>

<element name="TControlAutoSizePhases">
<short>
Set type used to store values from the TControlAutoSizePhase enumeration.
</short>
<descr/>
<seealso>
<link id="TControlAutoSizePhase"/>
<link id="TControl.AutoSizePhases"/>
<link id="TWinControl.AutoSizePhases"/>
<link id="TWinControl.DoAutoSize"/>
<link id="TWinControl.UpdateShowing"/>
<link id="TWinControl.WMMove"/>
<link id="TWinControl.WMSize"/>
</seealso>
</element>

<element name="TTabOrder">
<short>
Range type used to represent the tab order for windowed controls.
</short>
<descr/>
<version>
Modified in LCL 3.0 to be an alias to TTabOrder in System.UITypes for FPC 
3.2.3 or higher.
</version>
<seealso>
<!--
Uncomment when the topic exists in the RTL documenetation. 
<link id="#rtl.system.uitypes.TTabOrder">TTabOrder</link>
-->
</seealso>
</element>

<element name="TControlShowHintEvent">
<short>Type used to implement an OnShowHint event handler.</short>
<descr/>
<seealso/>
</element>
<element name="TControlShowHintEvent.Sender">
<short>TObject for the event notification.</short>
</element>
<element name="TControlShowHintEvent.HintInfo">
<short>Hint information used to derive hint value.</short>
</element>

<element name="TContextPopupEvent">
<short>Handler type for OnContextPopup.</short>
<descr/>
<seealso/>
</element>
<element name="TContextPopupEvent.Sender">
<short>The clicked control.</short>
</element>
<element name="TContextPopupEvent.MousePos">
<short>
Mouse position in client coordinates; (-1,-1) if the event was not generated 
by a mouse click.
</short>
</element>
<element name="TContextPopupEvent.Handled">
<short>
Set Handled to <b>True</b> when everything was handled; <b>False</b> shows 
the associated PopupMenu, by default.
</short>
</element>

<element name="TControlFlag">
<short>
Flags values used mostly for pending actions in a control.
</short>
<descr/>
<seealso/>
</element>
<element name="TControlFlag.cfLoading">
<short>
Set by TControl.ReadState, and unset by TControl.Loaded when all controls for 
the form have finished loading.
</short>
</element>
<element name="TControlFlag.cfAutoSizeNeeded">
<short>Set when AutoSize was delayed.</short>
</element>
<element name="TControlFlag.cfLeftLoaded">
<short>Set when Left was set during loading.</short>
</element>
<element name="TControlFlag.cfTopLoaded">
<short>Set when Top was set during loading.</short>
</element>
<element name="TControlFlag.cfWidthLoaded">
<short>Set when Width was set during loading.</short>
</element>
<element name="TControlFlag.cfHeightLoaded">
<short>Set when Height was set during loading.</short>
</element>
<element name="TControlFlag.cfClientWidthLoaded">
<short>Set when ClientWidth was set during loading.</short>
</element>
<element name="TControlFlag.cfClientHeightLoaded">
<short>Set when ClientHeight was set during loading.</short>
</element>
<element name="TControlFlag.cfBoundsRectForNewParentValid">
<short>Set when BoundsRectForNewParent has been initialized.</short>
</element>
<element name="TControlFlag.cfBaseBoundsValid">
<short>
Indicates if the rectangle in the base bounds for a control is valid.
</short>
</element>
<element name="TControlFlag.cfPreferredSizeValid">
<short>
Set when PreferredSize has been calculated (CalculatePreferredSize).
</short>
</element>
<element name="TControlFlag.cfPreferredMinSizeValid">
<short>
Set when PreferredSize has been calculated (CalculatePreferredSize) for the 
minimum height and width for a control.
</short>
</element>
<element name="TControlFlag.cfOnChangeBoundsNeeded">
<short>
Set when the BoundsRect for a control has been changed and the host has not 
been updated.
</short>
</element>
<element name="TControlFlag.cfProcessingWMPaint">
<short>Set (in WndProc) while processing an LM_PAINT message.</short>
</element>
<element name="TControlFlag.cfKillChangeBounds">
<short>
Set when a control is auto-sized. Used to prevent recursive calls when a 
control, its Parent, or its Children are auto-sized.
</short>
</element>
<element name="TControlFlag.cfKillInvalidatePreferredSize">
<short>
Set when a control is auto-sized. Used to prevent recursive calls when a 
control, its Parent, or its Children call their InvalidatePreferredSize 
methods.
</short>
</element>
<element name="TControlFlag.cfKillAdjustSize">
<short>
Set when a control is auto-sized. Used to prevent recursive calls when a 
control, its Parent, or its Children call their AdjustSize methods.
</short>
</element>

<element name="TControlFlags">
<short>
Set type used to store values from the TControlFlag enumeration.
</short>
<descr/>
<seealso>
<link id="TControlFlag"/>
</seealso>
</element>

<element name="TControlHandlerType">
<short>Notification handler types.</short>
<descr>
<p>
Notification handlers only receive a Sender argument, and must know 
themselves why they have been invoked.
</p>
</descr>
<seealso/>
</element>
<element name="TControlHandlerType.chtOnResize">
<short>Notification request for OnResize.</short>
</element>
<element name="TControlHandlerType.chtOnChangeBounds">
<short>Notification request for OnChangeBounds.</short>
</element>
<element name="TControlHandlerType.chtOnVisibleChanging">
<short>Notification request for OnVisibleChanging.</short>
</element>
<element name="TControlHandlerType.chtOnVisibleChanged">
<short>Notification request for OnVisibleChanged.</short>
</element>
<element name="TControlHandlerType.chtOnEnabledChanging">
<short>Notification request for OnEnabledChanging.</short>
</element>
<element name="TControlHandlerType.chtOnEnabledChanged">
<short>Notification request for OnEnabledChanged.</short>
</element>
<element name="TControlHandlerType.chtOnKeyDown">
<short>Notification request for OnKeyDown.</short>
</element>

<element name="TLayoutAdjustmentPolicy">
<short>
Indicates the policy for the LCL to execute automatic adjustments in the form 
layout.
</short>
<descr/>
<seealso/>
</element>
<element name="TLayoutAdjustmentPolicy.lapDefault">
<short>Widgetset dependent.</short>
</element>
<element name="TLayoutAdjustmentPolicy.lapFixedLayout">
<short>A fixed absolute layout on all platforms.</short>
</element>
<element name="TLayoutAdjustmentPolicy.lapAutoAdjustWithoutHorizontalScrolling">
<short>
Smartphone platforms use this one; the x axis is stretched to fill the screen 
and the y axis is scaled to fit the DPI.
</short>
</element>
<element name="TLayoutAdjustmentPolicy.lapAutoAdjustForDPI">
<short>For desktops using High DPI, scale x and y to fit the DPI.</short>
</element>

<element name="TLazAccessibilityRole">
<short>
Indicates the role which a accessible object takes in the user interface.
</short>
<descr/>
<seealso>
<link id="TLazAccessibleObject"/>
</seealso>
</element>
<element name="TLazAccessibilityRole.larIgnore">
<short>
Something to be ignored. For example a blank space between other objects.
</short>
</element>
<element name="TLazAccessibilityRole.larAnimation">
<short>An object that displays an animation.</short>
</element>
<element name="TLazAccessibilityRole.larButton">
<short>A button.</short>
</element>
<element name="TLazAccessibilityRole.larCell">
<short>A cell in a table.</short>
</element>
<element name="TLazAccessibilityRole.larChart">
<short>An object that displays a graphical representation of data.</short>
</element>
<element name="TLazAccessibilityRole.larCheckBox">
<short>
An object that can be checked or unchecked, or sometimes in an indeterminate 
state.
</short>
</element>
<element name="TLazAccessibilityRole.larClock">
<short>A clock displaying time.</short>
</element>
<element name="TLazAccessibilityRole.larColorPicker">
<short>A control which allows selecting a color.</short>
</element>
<element name="TLazAccessibilityRole.larColumn">
<short>A generic column in a table.</short>
</element>
<element name="TLazAccessibilityRole.larComboBox">
<short>A list of choices that the user can select from.</short>
</element>
<element name="TLazAccessibilityRole.larDateField">
<short>
A controls which displays and possibly allows one to choose a date.
</short>
</element>
<element name="TLazAccessibilityRole.larGrid">
<short>A grid control which displays cells.</short>
</element>
<element name="TLazAccessibilityRole.larGroup">
<short>A control which groups others, such as a TGroupBox.</short>
</element>
<element name="TLazAccessibilityRole.larImage">
<short>A graphic or picture or an icon.</short>
</element>
<element name="TLazAccessibilityRole.larLabel">
<short>A text label as usually placed near other widgets.</short>
</element>
<element name="TLazAccessibilityRole.larListBox">
<short>
A list of items, from which the user can select one or more items.
</short>
</element>
<element name="TLazAccessibilityRole.larListItem">
<short>An item in a list of items.</short>
</element>
<element name="TLazAccessibilityRole.larMenuBar">
<short>A main menu bar.</short>
</element>
<element name="TLazAccessibilityRole.larMenuItem">
<short>A item in a menu.</short>
</element>
<element name="TLazAccessibilityRole.larProgressIndicator">
<short>A control which shows a progress indication.</short>
</element>
<element name="TLazAccessibilityRole.larRadioButton">
<short>A radio button, see for example TRadioButton.</short>
</element>
<element name="TLazAccessibilityRole.larResizeGrip">
<short>
A grip that the user can drag to change the size of widgets.
</short>
</element>
<element name="TLazAccessibilityRole.larRow">
<short>A generic row in a table.</short>
</element>
<element name="TLazAccessibilityRole.larScrollBar">
<short>A control to scroll another one.</short>
</element>
<element name="TLazAccessibilityRole.larSpinner">
<short>
A control which allows one to increment / decrement a value.
</short>
</element>
<element name="TLazAccessibilityRole.larTabControl">
<short>A control with tabs, like TPageControl.</short>
</element>
<element name="TLazAccessibilityRole.larText">
<short>Text inside of a control, like text in a row cell.</short>
</element>
<element name="TLazAccessibilityRole.larTextEditorMultiline">
<short>A multi-line text editor (for example: TMemo, SynEdit).</short>
</element>
<element name="TLazAccessibilityRole.larTextEditorSingleline">
<short>A single-line text editor (for example: TEdit).</short>
</element>
<element name="TLazAccessibilityRole.larToolBar">
<short>A control that holds ToolButtons.</short>
</element>
<element name="TLazAccessibilityRole.larToolBarButton">
<short>A button on a ToolBar.</short>
</element>
<element name="TLazAccessibilityRole.larTrackBar">
<short>A control which allows one to drag a slider.</short>
</element>
<element name="TLazAccessibilityRole.larTreeView">
<short>A list of items in a tree structure.</short>
</element>
<element name="TLazAccessibilityRole.larTreeItem">
<short>An item in a tree structure.</short>
</element>
<element name="TLazAccessibilityRole.larUnknown">
<short>An item that doesn't fit any of the other categories.</short>
</element>
<element name="TLazAccessibilityRole.larWindow">
<short>A top level window.</short>
</element>

<element name="TLazAccessibleObjectEnumerator">
<short>
Implements an enumerator for a list of TLazAccessibleObject instances.
</short>
<descr/>
<seealso/>
</element>

<element name="TLazAccessibleObjectEnumerator.GetCurrent">
<short>Gets the value for the Current property.</short>
<descr/>
<seealso/>
</element>
<element name="TLazAccessibleObjectEnumerator.GetCurrent.Result">
<short>Value for the property.</short>
</element>

<element name="TLazAccessibleObjectEnumerator.Current">
<short>Current value for the enumerator.</short>
<descr/>
<seealso/>
</element>

<element name="TLazAccessibleObject">
<short>
Represents an accessibility object for user or accessibility tool 
interactions.
</short>
<descr>
<p>
Every <var>TControl</var> has a <var>TLazAccessibleObject</var> instance 
associated with it, which means that every <var>TControl</var> is potentially 
accessible. But to actually be usable, the accessible object needs to have 
its properties set, the most important of which are the role, description and 
value. Native windowed classes should already receive accessibility 
properties from the underlying widgetset, while <var>TCustomControl</var> 
descendants will use the accessibility properties provided by LCL itself.
</p>
<p>
User applications should add accessibility for their own 
<var>TCustomControl</var> descendant classes, and possibly customize the 
descriptions of some elements. It is also possible to make an accessible 
object invisible to the user, which is done by setting its AccessibleRole 
property to <var>larIgnored</var>.
</p>
<p>
Accessibility support in Lazarus is also documented on the Wiki at:
<url href="https://wiki.lazarus.freepascal.org/LCL_Accessibility"/>.
</p>
</descr>
<seealso>
<link id="TControl"/>
<link id="TControl.AccessibleRole"/>
<link id="TControl.AccessibleDescription"/>
<link id="TControl.AccessibleValue"/>
<link id="TLazAccessibilityRole"/>
</seealso>
</element>

<element name="TLazAccessibleObject.FPosition"/>
<element name="TLazAccessibleObject.FSize"/>
<element name="TLazAccessibleObject.FLastSearchNode"/>
<element name="TLazAccessibleObject.FLastSearchIndex"/>
<element name="TLazAccessibleObject.FLastSearchInSubcontrols"/>

<element name="TLazAccessibleObject.GetPosition">
<short>Gets the value for the Position property.</short>
</element>
<element name="TLazAccessibleObject.GetPosition.Result">
<short>Value for the property.</short>
</element>

<element name="TLazAccessibleObject.GetSize">
<short>Gets the value for the Size property.</short>
<seealso>
<link id="TLazAccessibleObject.Size"/>
</seealso>
</element>
<element name="TLazAccessibleObject.GetSize.Result">
<short>Value for the property.</short>
</element>

<element name="TLazAccessibleObject.SetHandle">
<short>Sets the value for the Handle property.</short>
<seealso>
<link id="TLazAccessibleObject.Handle"/>
</seealso>
</element>
<element name="TLazAccessibleObject.SetHandle.AValue">
<short>New value for the Handle property.</short>
</element>

<element name="TLazAccessibleObject.SetPosition">
<short>Sets the value for the Position property.</short>
<seealso>
<link id="TLazAccessibleObject.Position"/>
</seealso>
</element>
<element name="TLazAccessibleObject.SetPosition.AValue">
<short>New value for the Position property.</short>
</element>

<element name="TLazAccessibleObject.SetSize">
<short>Sets the value for the Size property.</short>
<descr></descr>
<seealso>
<link id="TLazAccessibleObject.Size"/>
</seealso>
</element>
<element name="TLazAccessibleObject.SetSize.AValue">
<short>New value for the Size property.</short>
</element>

<element name="TLazAccessibleObject.FHandle">
<short>Member with the Handle for the accessibility object.</short>
</element>
<element name="TLazAccessibleObject.FChildrenSortedForDataObject">
<short>Member with the AVL tree for the sorted child objects.</short>
</element>
<element name="TLazAccessibleObject.FAccessibleName">
<short>Member with the value for AccessibleName.</short>
</element>
<element name="TLazAccessibleObject.FAccessibleDescription">
<short>Member with the value for AccessibleDescription.</short>
</element>
<element name="TLazAccessibleObject.FAccessibleValue">
<short>Member with the value for AccessibleValue.</short>
</element>
<element name="TLazAccessibleObject.FAccessibleRole">
<short>Member with the value for AccessibleRole.</short>
</element>

<element name="TLazAccessibleObject.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

<element name="TLazAccessibleObject.GetAccessibleValue">
<short>Gets the value for the AccessibleValue property.</short>
<descr/>
<seealso/>
</element>
<element name="TLazAccessibleObject.GetAccessibleValue.Result">
<short>Value for the property.</short>
</element>

<element name="TLazAccessibleObject.GetHandle">
<short>Gets the value for the Handle property.</short>
<descr/>
<seealso/>
</element>
<element name="TLazAccessibleObject.GetHandle.Result">
<short>Value for the property.</short>
</element>

<element name="TLazAccessibleObject.OwnerControl">
<short>
The control that this accessible object is attached to. It might be the main 
accessible object of this control or it might represent a sub-part of a 
control.
</short>
<descr>
<p>
The control that this accessible object is attached to. It might be the main 
accessible object of this control, or it might represent a sub-part of a 
control which does not have a corresponding TControl, like an item of 
TTreeView. One can verify if this is the main accessible object of the 
control by checking if (lAccessibleObject.OwnerControl = 
lAccessibleObject.OwnerControl.GetAccessibleObject())
</p>
</descr>
<seealso>
<link id="TControl.GetAccessibleObject"/>
</seealso>
</element>

<element name="TLazAccessibleObject.Parent">
<short>The parent TLazAccessibleObject of this accessible object.</short>
</element>

<element name="TLazAccessibleObject.DataObject">
<short>Available to be used to connect to an object.</short>
</element>

<element name="TLazAccessibleObject.SecondaryHandle">
<short>Available for Widgetsets to use.</short>
</element>

<element name="TLazAccessibleObject.Create">
<short>Constructor for the class instance.</short>
<descr/>
<seealso/>
</element>

<element name="TLazAccessibleObject.Destroy">
<short>Destructor for the class instance.</short>
<descr/>
<seealso/>
</element>

<element name="TLazAccessibleObject.HandleAllocated">
<short>
Returns if the handle of this object was already allocated or not.
</short>
<descr/>
<seealso/>
</element>

<element name="TLazAccessibleObject.InitializeHandle">
<short>
Utilized to set all properties of this property via widgetset routines when 
creating the handle.
</short>
<descr/>
<seealso/>
</element>

<element name="TLazAccessibleObject.SetAccessibleName">
<short>Sets the value for AccessibleName.</short>
<descr/>
<seealso>
<link id="TLazAccessibleObject.AccessibleName"/>
</seealso>
</element>
<element name="TLazAccessibleObject.SetAccessibleName.AName">
<short>New value for the AccessibleName property.</short>
</element>

<element name="TLazAccessibleObject.SetAccessibleDescription">
<short>Setter for the property AccessibleDescription.</short>
</element>

<element name="TLazAccessibleObject.SetAccessibleValue">
<short>Setter for the property AccessibleValue.</short>
</element>

<element name="TLazAccessibleObject.SetAccessibleRole">
<short>Setter for the property AccessibleRole.</short>
</element>

<element name="TLazAccessibleObject.FindOwnerWinControl">
<short>
Inspect the tree of accessible objects upwards until it finds a parent which 
is attached directly to a windowed control, a TWinControl.
</short>
</element>

<element name="TLazAccessibleObject.AddChildAccessibleObject">
<short>Creates and returns a new child accessibility object.</short>
</element>
<element name="TLazAccessibleObject.AddChildAccessibleObject.Result">
<short>Child accessibility object created in the method.</short>
</element>
<element name="TLazAccessibleObject.AddChildAccessibleObject.ADataObject">
<short/>
</element>

<element name="TLazAccessibleObject.InsertChildAccessibleObject">
<short>
Inserts an already created child accessible object as a child of this one.
</short>
</element>

<element name="TLazAccessibleObject.ClearChildAccessibleObjects">
<short>
Removes all children of this control; freed if they are not attached to a 
TControl instance.
</short>
</element>

<element name="TLazAccessibleObject.RemoveChildAccessibleObject">
<short>Removes a child accessible object.</short>
</element>

<element name="TLazAccessibleObject.GetChildAccessibleObject">
<short>Obtains a child accessible object by its index.</short>
</element>

<element name="TLazAccessibleObject.GetChildAccessibleObjectWithDataObject">
<short>Obtains a child accessible object by its DataObject property.</short>
</element>

<element name="TLazAccessibleObject.GetChildAccessibleObjectsCount">
<short>
Returns the number of direct children that this accessible object has.
</short>
</element>

<element name="TLazAccessibleObject.GetFirstChildAccessibleObject">
<short>
Searches in sub-controls for the first child accessibility object.
</short>
<descr/>
<seealso/>
</element>
<element name="TLazAccessibleObject.GetFirstChildAccessibleObject.Result">
<short/>
</element>

<element name="TLazAccessibleObject.GetNextChildAccessibleObject">
<short>
Searches in sub-controls for the next child accessibility object.
</short>
<descr/>
<seealso/>
</element>
<element name="TLazAccessibleObject.GetNextChildAccessibleObject.Result">
<short/>
</element>

<element name="TLazAccessibleObject.GetSelectedChildAccessibleObject">
<short>
Returns the currently selected child accessible object or <b>Nil</b> if none 
are selected; Override this method in your sub class.
</short>
<seealso>
<link id="TControl.GetSelectedChildAccessibleObject"/>
</seealso>
</element>

<element name="TLazAccessibleObject.GetChildAccessibleObjectAtPos">
<short>
Returns the child of this control located at a particular position given as a 
client position for the control.
</short>
<seealso>
<link id="TControl.GetChildAccessibleObjectAtPos"/>
</seealso>
</element>

<element name="TLazAccessibleObject.AccessibleName">
<short>The name for this accessible object.</short>
<descr/>
<seealso/>
</element>

<element name="TLazAccessibleObject.AccessibleDescription">
<short>The description of this accessible object.</short>
<seealso>
<link id="TControl.AccessibleDescription"/>
</seealso>
</element>

<element name="TLazAccessibleObject.AccessibleValue">
<short>The value of this accessible object.</short>
<seealso>
<link id="TControl.AccessibleValue"/>
</seealso>
</element>

<element name="TLazAccessibleObject.AccessibleRole">
<short>The role of this accessible object.</short>
<seealso>
<link id="TControl.AccessibleRole"/>
</seealso>
</element>

<element name="TLazAccessibleObject.Position">
<short>The position of this accessible object.</short>
</element>

<element name="TLazAccessibleObject.Size">
<short>The size of this accessible object.</short>
</element>

<element name="TLazAccessibleObject.Handle">
<short>The widgetset handle of this accessible object.</short>
</element>

<element name="TLazAccessibleObject.GetEnumerator">
<short>Default enumerator for the children.</short>
</element>

<element name="TControl">
<short>The base class for visible controls.</short>
<descr>
<p>
<var>TControl</var> is a <var>TLCLComponent</var> descendant which implements 
the base class for visual controls in the <b>LCL</b> (<b>Lazarus Component 
Library</b>). TControl extends ancestor classes, like TLCLComponent and 
TComponent, with properties and methods needed to configure the appearance 
and behavior for the visual control and handle user interactions at run-time.
</p>
<p>
Some properties and methods are in all of its descendent classes. Others are 
implemented as needed in descendent classes. The properties and methods fall 
into categories like:
</p>
<ul>
<li>Appearance</li>
<li>Position and Orientation</li>
<li>Sizing and Aligning</li>
<li>Assistance and Accessibility</li>
<li>Drag and Drop</li>
<li>Docking</li>
<li>Action Support</li>
<li>Hi-DPI Awareness and Scaling</li>
<li>Handler Lists for Event Notifications </li>
<li>Window and Control Message Handling</li>
<li>Keyboard and Mouse Message Handling</li>
<li>Widgetset-specific Members and Methods</li>
</ul>
<p>
Applications do not normally create instances of TControl. It is used as an 
ancestor for descendent classes which implement additional features or 
behaviors.
</p>
<p>
TControl does not provide a window handle needed to draw the control in the 
underlying widgetset class. It includes a Parent property which is the 
windowed control where the control is hosted. It also provides the handle 
needed to draw the control.
</p>
<p>
Use TWinControl for a control which provides its own window handle.
</p>
</descr>
<seealso>
<link id="TWinControl"/>
<link id="#lcl.lclclasses.TLCLComponent">TLCLComponent</link>
<link id="#rtl.classes.TComponent">TComponent</link>
</seealso>
</element>

<element name="TControl.FActionLink"/>
<element name="TControl.FAlign"/>
<element name="TControl.FAnchors"/>
<element name="TControl.FAnchorSides"/>
<element name="TControl.fAnchoredControls"/>
<element name="TControl.FAutoSizingLockCount"/>
<element name="TControl.FAutoSizingLockReasons"/>
<element name="TControl.FBaseBounds"/>
<element name="TControl.FBaseBoundsLock"/>
<element name="TControl.FBaseParentClientSize"/>
<element name="TControl.FBiDiMode"/>
<element name="TControl.FBorderSpacing"/>
<element name="TControl.FBoundsRectForNewParent"/>
<element name="TControl.FCaption"/>
<element name="TControl.FCaptureMouseButtons"/>
<element name="TControl.FColor"/>
<element name="TControl.FConstraints"/>
<element name="TControl.FControlFlags"/>

<element name="TControl.FControlHandlers">
<short>Array of the installable notification handlers.</short>
</element>

<element name="TControl.FControlStyle"/>
<element name="TControl.FDockOrientation"/>
<element name="TControl.FDragCursor"/>
<element name="TControl.FDragKind"/>
<element name="TControl.FDragMode"/>
<element name="TControl.FFloatingDockSiteClass"/>
<element name="TControl.FFont"/>
<element name="TControl.FHeight"/>
<element name="TControl.FHelpContext"/>
<element name="TControl.FHelpKeyword"/>
<element name="TControl.FHelpType"/>
<element name="TControl.FHint"/>
<element name="TControl.FHostDockSite"/>
<element name="TControl.FLastDoChangeBounds"/>
<element name="TControl.FLastDoChangeClientSize"/>
<element name="TControl.FLastResizeClientHeight"/>
<element name="TControl.FLastResizeClientWidth"/>
<element name="TControl.FLastResizeHeight"/>
<element name="TControl.FLastResizeWidth"/>
<element name="TControl.FLeft"/>

<element name="TControl.FLoadedClientSize">
<short>Intended ClientSize, initialized during loading.</short>
</element>

<element name="TControl.FLRDockWidth"/>
<element name="TControl.FOnChangeBounds"/>
<element name="TControl.FOnClick"/>
<element name="TControl.FOnConstrainedResize"/>
<element name="TControl.FOnContextPopup"/>
<element name="TControl.FOnDblClick"/>
<element name="TControl.FOnDragDrop"/>
<element name="TControl.FOnDragOver"/>
<element name="TControl.FOnEditingDone"/>
<element name="TControl.FOnEndDock"/>
<element name="TControl.FOnEndDrag"/>
<element name="TControl.FOnMouseDown"/>
<element name="TControl.FOnMouseEnter"/>
<element name="TControl.FOnMouseLeave"/>
<element name="TControl.FOnMouseMove"/>
<element name="TControl.FOnMouseUp"/>
<element name="TControl.FOnMouseWheel"/>
<element name="TControl.FOnMouseWheelDown"/>
<element name="TControl.FOnMouseWheelUp"/>
<element name="TControl.FOnMouseWheelHorz"/>
<element name="TControl.FOnMouseWheelLeft"/>
<element name="TControl.FOnMouseWheelUpRight"/>
<element name="TControl.FOnQuadClick"/>
<element name="TControl.FOnResize"/>
<element name="TControl.FOnShowHint"/>
<element name="TControl.FOnStartDock"/>
<element name="TControl.FOnStartDrag"/>
<element name="TControl.FOnTripleClick"/>
<element name="TControl.FParent"/>
<element name="TControl.FPopupMenu"/>
<element name="TControl.FPreferredMinHeight"/>
<element name="TControl.FPreferredMinWidth"/>
<element name="TControl.FPreferredWidth"/>
<element name="TControl.FPreferredHeight"/>
<element name="TControl.FReadBounds"/>
<element name="TControl.FSessionProperties"/>
<element name="TControl.FSizeLock"/>
<element name="TControl.FTBDockHeight"/>
<element name="TControl.FTop"/>
<element name="TControl.FUndockHeight"/>
<element name="TControl.FUndockWidth"/>
<element name="TControl.FWidth"/>
<element name="TControl.FWindowProc"/>
<element name="TControl.FDesktopFont"/>
<element name="TControl.FParentBiDiMode"/>
<element name="TControl.FIsControl"/>
<element name="TControl.FShowHint"/>
<element name="TControl.FParentColor"/>
<element name="TControl.FParentFont"/>
<element name="TControl.FParentShowHint"/>
<element name="TControl.FAutoSize"/>
<element name="TControl.FAutoSizingAll"/>
<element name="TControl.FAutoSizingSelf"/>
<element name="TControl.FEnabled"/>
<element name="TControl.FMouseInClient"/>
<element name="TControl.FVisible"/>

<element name="TControl.CaptureMouseButtonsIsStored">
<short>
Implements the storage specifier for the CaptureMouseButtons property.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.CaptureMouseButtonsIsStored.Result">
<short>
<b>True</b> if CaptureMouseButtons has a value other than [mbLeft].
</short>
</element>

<element name="TControl.DoActionChange">
<short>
Implements the OnChange handler routine assigned to the ActionLink.
</short>
<descr>
<p>
When an Action is assigned to the control, related properties are updated 
using <link id="TControl.ActionChange">ActionChange</link>.
</p>
</descr>
</element>
<element name="TControl.DoActionChange.Sender">
<short>The changed Action.</short>
</element>

<element name="TControl.GetAccessibleDescription">
<short>Gets the value for the AccessibleDescription property.</short>
<descr/>
<seealso>
<link id="TControl.AccessibleDescription"/>
</seealso>
</element>
<element name="TControl.GetAccessibleDescription.Result">
<short>Value for the property.</short>
</element>

<element name="TControl.GetAccessibleValue">
<short>Gets the value for the AccessibleValue property.</short>
<descr/>
<seealso>
<link id="TControl.AccessibleValue"/>
</seealso>
</element>
<element name="TControl.GetAccessibleValue.Result">
<short>Value for the property.</short>
</element>

<element name="TControl.GetAccessibleRole">
<short>Gets the value for the AccessibleRole property.</short>
<descr/>
<seealso>
<link id="TControl.AccessibleRole"/>
</seealso>
</element>
<element name="TControl.GetAccessibleRole.Result">
<short>Value for the property.</short>
</element>

<element name="TControl.GetAutoSizingAll">
<short>Gets the value for the AutoSizingAll property.</short>
<descr>
<p>
Returns the value from the AutoSizingAll property in the Parent when Parent 
has been assigned. Otherwise, the existing property value is used.
</p>
</descr>
<seealso>
<link id="TControl.AutoSizingAll"/>
<link id="TControl.Parent"/>
</seealso>
</element>
<element name="TControl.GetAutoSizingAll.Result">
<short>Value for the AutoSizingAll property.</short>
</element>

<element name="TControl.GetAnchorSide">
<short>Gets the value for the indexed AnchorSide property.</short>
<descr/>
<seealso>
<link id="TControl.AnchorSide"/>
<link id="TAnchorKind"/>
</seealso>
</element>
<element name="TControl.GetAnchorSide.Result">
<short>Value for the indexed AnchorSide property.</short>
</element>
<element name="TControl.GetAnchorSide.Kind">
<short>
TAnchorKind value with the array element accessed for the property value.
</short>
</element>

<element name="TControl.GetAnchoredControls">
<short>Gets the value for the indexed AnchoredControls property.</short>
<descr/>
<seealso>
<link id="TControl.AnchoredControls"/>
</seealso>
</element>
<element name="TControl.GetAnchoredControls.Result">
<short>Value for the indexed AnchoredControls property.</short>
</element>
<element name="TControl.GetAnchoredControls.Index">
<short>
Ordinal position in the list of anchored controls for the property value.
</short>
</element>

<element name="TControl.GetBoundsRect">
<short>Gets the value for the BoundsRect property.</short>
<descr/>
<seealso>
<link id="TControl.BoundsRect"/>
</seealso>
</element>
<element name="TControl.GetBoundsRect.Result">
<short>Value for the BoundsRect property.</short>
</element>

<element name="TControl.GetClientHeight">
<short>Gets the value for the ClientHeight property.</short>
<descr/>
<seealso>
<link id="TControl.ClientHeight"/>
</seealso>
</element>
<element name="TControl.GetClientHeight.Result">
<short>Value for the ClientHeight property.</short>
</element>

<element name="TControl.GetClientWidth">
<short>Gets the value for the ClientWidth property.</short>
<descr/>
<seealso>
<link id="TControl.ClientWidth"/>
</seealso>
</element>
<element name="TControl.GetClientWidth.Result">
<short>Value for the ClientWidth property.</short>
</element>

<element name="TControl.GetLRDockWidth">
<short>Gets the value for the LRDockWidth property.</short>
<descr/>
<seealso>
<link id="TControl.LRDockWidth"/>
</seealso>
</element>
<element name="TControl.GetLRDockWidth.Result">
<short>Value for the LRDockWidth property.</short>
</element>

<element name="TControl.GetTBDockHeight">
<short>Gets the value for the TBDockHeight property.</short>
<descr/>
<seealso>
<link id="TControl.TBDockHeight"/>
</seealso>
</element>
<element name="TControl.GetTBDockHeight.Result">
<short>Value for the TBDockHeight property.</short>
</element>

<element name="TControl.GetText">
<short>Gets the value for the Text property.</short>
<descr>
<p>
Uses RealGetText (which reads the Caption member), instead of GetTextBuf 
(which calls WM_GETTEXT), when possible.
</p>
</descr>
<seealso>
<link id="TControl.RealGetText"/>
<link id="TControl.GetTextBuf"/>
</seealso>
</element>
<element name="TControl.GetText.Result">
<short>The value for the Text property.</short>
</element>

<element name="TControl.GetUndockHeight">
<short>Gets the value for the UndockHeight property.</short>
<descr/>
<seealso>
<link id="TControl.UndockHeight"/>
</seealso>
</element>
<element name="TControl.GetUndockHeight.Result">
<short>Value for the UndockHeight property.</short>
</element>

<element name="TControl.GetUndockWidth">
<short>Gets the value for the UndockWidth property.</short>
<descr/>
<seealso>
<link id="TControl.UndockWidth"/>
</seealso>
</element>
<element name="TControl.GetUndockWidth.Result">
<short>Value for the UndockWidth property.</short>
</element>

<element name="TControl.IsAnchorsStored">
<short>Implements the storage specifier for the Anchors property.</short>
<descr/>
<seealso>
<link id="TControl.Anchors"/>
</seealso>
</element>
<element name="TControl.IsAnchorsStored.Result">
<short>
<b>True</b> when Anchors has value different than the value in AnchorAlign 
for the current setting in Align.
</short>
</element>

<element name="TControl.IsBiDiModeStored">
<short>Implements the storage specifier for the BiDiMode property.</short>
<descr/>
<seealso>
<link id="TControl.BiDiMode"/>
</seealso>
</element>
<element name="TControl.IsBiDiModeStored.Result">
<short>
<b>True</b> when ParentBidiMode has not been enabled.
</short>
</element>

<element name="TControl.IsEnabledStored">
<short>Implements the storage specifier for the Enabled property.</short>
<descr/>
<seealso>
<link id="TControl.Enabled"/>
</seealso>
</element>
<element name="TControl.IsEnabledStored.Result">
<short>
<b>True</b> when ActionLink has not been assigned or its Enabled property is 
not linked to the control.
</short>
</element>

<element name="TControl.IsFontStored">
<short>Implements the storage specifier for the Font property.</short>
<descr/>
<seealso>
<link id="TControl.Font"/>
</seealso>
</element>
<element name="TControl.IsFontStored.Result">
<short>
<b>True</b> when ParentFont has not been enabled.
</short>
</element>

<element name="TControl.IsHintStored">
<short>Implements the storage specifier for the Hint property.</short>
<descr>
<p>
The return value is <b>True</b> when the property value is not supplied by an 
Action linked to the control. This occurs when an ActionLink has not been 
assigned for the control, or when the IsHintLinked property in the ActionLink 
is set to <b>False</b>.
</p>
</descr>
<seealso>
<link id="TControl.Hint"/>
</seealso>
</element>
<element name="TControl.IsHintStored.Result">
<short>
<b>True</b> when the property value is stored using LCL component streaming.
</short>
</element>

<element name="TControl.IsHelpContextStored"/>
<element name="TControl.IsHelpContextStored.Result"/>

<element name="TControl.IsHelpKeyWordStored"/>
<element name="TControl.IsHelpKeyWordStored.Result"/>

<element name="TControl.IsShowHintStored"/>
<element name="TControl.IsShowHintStored.Result"/>

<element name="TControl.IsVisibleStored"/>
<element name="TControl.IsVisibleStored.Result"/>

<element name="TControl.DoBeforeMouseMessage">
<short>Generate MouseEnter and MouseLeave events.</short>
<descr/>
<seealso/>
</element>

<element name="TControl.DoConstrainedResize">
<short>
Adjusts the control Bounds using its sizing Constraints.
</short>
<descr/>
<seealso>
<link id="TControl.Constraints"/>
<link id="TControl.ConstrainedResize"/>
</seealso>
</element>
<element name="TControl.DoConstrainedResize.NewLeft"/>
<element name="TControl.DoConstrainedResize.NewTop"/>
<element name="TControl.DoConstrainedResize.NewWidth"/>
<element name="TControl.DoConstrainedResize.NewHeight"/>

<element name="TControl.SetAccessibleDescription">
<short>Sets the value for the AccessibleDescription property.</short>
<descr/>
<seealso>
<link id="TControl.AccessibleDescription"/>
</seealso>
</element>
<element name="TControl.SetAccessibleDescription.AValue">
<short>New value for the AccessibleDescription property.</short>
</element>

<element name="TControl.SetAccessibleValue">
<short>Sets the value for the AccessibleValue property.</short>
<descr/>
<seealso>
<link id="TControl.AccessibleValue"/>
</seealso>
</element>
<element name="TControl.SetAccessibleValue.AValue">
<short>New value for the AccessibleValue property.</short>
</element>

<element name="TControl. SetAccessibleRole">
<short>Sets the value for the AccessibleRole property.</short>
<descr/>
<seealso>
<link id="TControl.AccessibleRole"/>
</seealso>
</element>
<element name="TControl. SetAccessibleRole.AValue">
<short>New value for the AccessibleRole property.</short>
</element>

<element name="TControl.SetAnchorSide">
<short>Sets the value for the indexed AnchorSide property.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.SetAnchorSide.Kind">
<short>Index for the element updated in the method.</short>
</element>
<element name="TControl.SetAnchorSide.AValue">
<short>New value for the AnchorSize property.</short>
</element>

<element name="TControl.SetBorderSpacing">
<short>Sets the value for the BorderSpacing property.</short>
<descr/>
<seealso>
<link id="TControl.BorderSpacing"/>
</seealso>
</element>
<element name="TControl.SetBorderSpacing.AValue">
<short>New value for the BorderSpacing property.</short>
</element>

<element name="TControl.SetBoundsRect"/>
<element name="TControl.SetBoundsRect.ARect"/>
<element name="TControl.SetBoundsRectForNewParent"/>
<element name="TControl.SetBoundsRectForNewParent.AValue"/>
<element name="TControl.SetClientHeight"/>
<element name="TControl.SetClientHeight.Value"/>
<element name="TControl.SetClientSize"/>
<element name="TControl.SetClientSize.Value"/>
<element name="TControl.SetClientWidth"/>
<element name="TControl.SetClientWidth.Value"/>
<element name="TControl.SetConstraints"/>
<element name="TControl.SetConstraints.Value"/>
<element name="TControl.SetDesktopFont"/>
<element name="TControl.SetDesktopFont.AValue"/>
<element name="TControl.SetDragCursor"/>
<element name="TControl.SetDragCursor.AValue"/>
<element name="TControl.SetFont"/>
<element name="TControl.SetFont.Value"/>
<element name="TControl.SetHeight"/>
<element name="TControl.SetHeight.Value"/>
<element name="TControl.SetHelpContext"/>
<element name="TControl.SetHelpContext.AValue"/>
<element name="TControl.SetHelpKeyword"/>
<element name="TControl.SetHelpKeyword.AValue"/>
<element name="TControl.SetHostDockSite"/>
<element name="TControl.SetHostDockSite.AValue"/>
<element name="TControl.SetLeft"/>
<element name="TControl.SetLeft.Value"/>
<element name="TControl.SetMouseCapture"/>
<element name="TControl.SetMouseCapture.Value"/>
<element name="TControl.SetParentShowHint"/>
<element name="TControl.SetParentShowHint.Value"/>
<element name="TControl.SetParentColor"/>
<element name="TControl.SetParentColor.Value"/>
<element name="TControl.SetParentFont"/>
<element name="TControl.SetParentFont.Value"/>
<element name="TControl.SetPopupMenu"/>
<element name="TControl.SetPopupMenu.Value"/>
<element name="TControl.SetShowHint"/>
<element name="TControl.SetShowHint.Value"/>
<element name="TControl.SetText"/>
<element name="TControl.SetText.Value"/>
<element name="TControl.SetTop"/>
<element name="TControl.SetTop.Value"/>
<element name="TControl.SetWidth"/>
<element name="TControl.SetWidth.Value"/>

<element name="TControl.FAccessibleObject">
<short>Member with the accessibility object for the control.</short>
</element>
<element name="TControl.FControlState">
<short>Member with the value for the ControlState property.</short>
</element>
<element name="TControl.FCursor">
<short>Member with the value for the Cursor property.</short>
</element>

<element name="TControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

<element name="TControl.GetCursor">
<short>Gets the value for the Cursor property.</short>
<descr/>
<seealso>
<link id="TControl.Cursor"/>
</seealso>
</element>
<element name="TControl.GetCursor.Result">
<short>Value for the Cursor property.</short>
</element>

<element name="TControl.SetCursor">
<short>Sets the value for the Cursor property.</short>
<descr>
<p>
Calls Perform to send a CM_CURSORCHANGED control message to the processing 
loop when the member for the property is updated.
</p>
</descr>
<seealso>
<link id="TControl.Cursor"/>
<link id="TControl.Perform"/>
<link id="TControl.CMCursorChanged"/>
</seealso>
</element>
<element name="TControl.SetCursor.Value">
<short>New value for the Cursor property.</short>
</element>

<element name="TControl.SetVisible">
<short>Sets the value for the Visible property.</short>
<descr>
<p>
Changing the value for the property causes additional actions to be performed.
</p>
<p>
VisibleChanging is called to notify event handler routines for the control. 
The Perform method is used to send a CM_VISIBLECHANGED control message to the 
processing loop for the control.
</p>
<p>
Preferred width and height values in the control, and its children (when 
derived from TWinControl), are invalidated. To minimize the overhead from the 
DoAutoSize method, auto-sizing is temporarily disabled when the control is 
updated. The AdjustSize method is called to perform the equivalent of 
DoAutoSize without the extra overhead of getting the preferred sizes from the 
widgetset class. If the control is not Visible but has a Parent control, the 
AdjustSize method in Parent is called.
</p>
<p>
VisibleChanged is called to notify event handler routines for the control.
</p>
<p>
SetVisible ensures that ControlState is updated to include the value 
csVisibleSetInLoading when csLoading is included in the ComponentState 
property.
</p>
</descr>
<seealso>
<link id="TControl.Visible"/>
</seealso>
</element>
<element name="TControl.SetVisible.Value">
<short>New value for the Visible property.</short>
</element>

<element name="TControl.DoOnParentHandleDestruction">
<short>
Performs actions needed when the handle for the parent control is freed.
</short>
<descr>
<p>
Has an empty implementation in TControl, and must be implement in descendent 
classes.
</p>
</descr>
<seealso>
<link id="TGraphicControl.DoOnParentHandleDestruction"/>
</seealso>
</element>

<element name="TControl.DoAutoSize">
<short>For internal use only; call AdjustSize instead.</short>
<descr>
<remark>
IMPORTANT: Many Delphi controls override this method and many call this 
method directly after setting some properties.
</remark>
<p>
During handle creation not all interfaces can create complete Device Contexts 
which are needed to calculate things like text size. That's why you should 
always call <link id="#lcl.controls.TControl.AdjustSize">AdjustSize</link> 
instead of <var>DoAutoSize</var>.
</p>
</descr>
<seealso>
<link id="TControl.AutoSize"/>
<link id="TControl.AdjustSize"/>
</seealso>
</element>

<element name="TControl.DoAllAutoSize">
<short>Resizes and aligns the control and all of it children.</short>
<descr>
<p>
No actions are performed in the method when AutoSizingAll is <b>True</b>, or 
when the control is not derived from TWinControl.
</p>
<p>
Calls DoAutoSize while the control includes cfAutoSizeNeeded in its 
ControlFlags property. Called from the AdjustSize and EnableAutoSizing 
methods.
</p>
</descr>
<errors>
Raises an EInvalidOperation exception if Parent has not been assigned for the 
control.
</errors>
<seealso>
<link id="TControl.Parent"/>
<link id="TControl.AutoSizingAll"/>
<link id="TControl.AutoSizeDelayed"/>
<link id="TWinControl.Controls"/>
</seealso>
</element>

<element name="TControl.BeginAutoSizing">
<short>Sets AutoSizing to <b>True</b>; used to prevent loops.</short>
<descr/>
<seealso/>
</element>

<element name="TControl.EndAutoSizing">
<short>
End of the auto-sizing process, resets AutoSizing to <b>False</b>.
</short>
<descr/>
<seealso/>
</element>

<element name="TControl.AnchorSideChanged">
<short>Request further processing after an anchor side was changed.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AnchorSideChanged.TheAnchorSide">
<short>Ignored.</short>
</element>

<element name="TControl.ForeignAnchorSideChanged">
<short>
Requests further processing after an anchor side has changed, that anchors 
another control to this one.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ForeignAnchorSideChanged.TheAnchorSide">
<short>
Anchor side with the control added, removed, or moved in the notification.
</short>
</element>
<element name="TControl.ForeignAnchorSideChanged.Operation">
<short>
Operation for the notification.
</short>
</element>

<element name="TControl.SetAlign">
<short>Sets the value for the Align property.</short>
<descr>
<p>
Changing the value for the property causes additional actions to be performed.
</p>
</descr>
<seealso>
<link id="TControl.Align"/>
</seealso>
</element>
<element name="TControl.SetAlign.Value">
<short>New value for the Align property.</short>
</element>

<element name="TControl.SetAnchors">
<short>Sets the value for the Anchors property.</short>
<descr/>
<seealso>
<link id="TControl.Anchors"/>
</seealso>
</element>
<element name="TControl.SetAnchors.AValue">
<short>New value for the Anchors property.</short>
</element>

<element name="TControl.SetAutoSize">
<short>Sets the value for the AutoSize property.</short>
<descr>
<p>
Calls AdjustSize when the property is enabled.
</p>
</descr>
<seealso>
<link id="TControl.AdjustSize"/>
<link id="TControl.AutoSize"/>
</seealso>
</element>
<element name="TControl.SetAutoSize.Value">
<short>New value for the AutoSize property.</short>
</element>

<element name="TControl.BoundsChanged">
<short>
Called when the Bounds of the control have been changed; override as required.
</short>
<descr>
Notifications can be performed in this method.
</descr>
</element>

<element name="TControl.CreateControlBorderSpacing">
<short>
Creates the default BorderSpacing object instance for the class.
</short>
<descr>
<p>
Allocates the class instance used for the BorderSpacing property. Can be 
overridden in descendent controls to use the type or default values needed 
for the class instance.
</p>
</descr>
<seealso>
<link id="TControlBorderSpacing"/>
<link id="TControl.BorderSpacing"/>
</seealso>
</element>
<element name="TControl.CreateControlBorderSpacing.Result">
<short>The class instance created in the method.</short>
</element>

<element name="TControl.DoConstraintsChange">
<short>
Performs actions needed when value(s) in Constraints have been changed.
</short>
<descr>
<p>
DoConstraintsChange calls AdjustSize to ensure that the control and any 
children are sized and positioned to the new Constraints for the control. The 
method is overridden in descendent classes, like TWinControl, to perform 
actions needed for the class instance.
</p>
<p>
Called from the TSizeConstraints.Change method before it signals the OnChange 
event handler in the constraints class instance.
</p>
</descr>
<seealso>
<link id="TWinControl.DoConstraintsChange"/>
</seealso>
</element>
<element name="TControl.DoConstraintsChange.Sender">
<short>Not used in the method.</short>
</element>

<element name="TControl.DoBorderSpacingChange">
<short>
Performs actions needed when border spacing for the control is changed.
</short>
</element>
<element name="TControl.DoBorderSpacingChange.Sender">
<short>
Object for the notification. Not used in the method.
</short>
</element>
<element name="TControl.DoBorderSpacingChange.InnerSpaceChanged">
<short>
<b>True</b> if the inner border spacing has been changed for the control. Not 
used in the method.
</short>
</element>

<element name="TControl.IsBorderSpacingInnerBorderStored">
<short>
Checks for an assigned value in BorderSpacing.InnerBorder.
</short>
</element>
<element name="TControl.IsBorderSpacingInnerBorderStored.Result">
<short>
<b>True</b> when InnerBorder has been assigned and must be applied to the 
control.
</short>
</element>

<element name="TControl.IsCaptionStored">
<short>
Implements the storage specifier for the Caption property.
</short>
<descr>
<p>
Returns <b>True</b> if ActionLink has not been assigned, or its 
IsCaptionLinked property is set to <b>False</b>.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.IsCaptionStored.Result">
<short>
Returns <b>True</b> if ActionLink has not been assigned, or its 
IsCaptionLinked property is set to <b>False</b>.
</short>
</element>

<element name="TControl.SendMoveSizeMessages">
<short>
Sends Move and Size messages through the LCL message paths.
</short>
<descr>
<p>
Overridden in TWinControl; in TControl it's a NOP. This method simulates the 
VCL behavior and has no real effect.
</p>
</descr>
<seealso>
<link id="TControl.ChangeBounds"/>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.Width"/>
<link id="TControl.Height"/>
</seealso>
</element>
<element name="TControl.SendMoveSizeMessages.SizeChanged">
<short>
<b>True</b> if a TLMSize message is constructed and dispatched in the method.
</short>
</element>
<element name="TControl.SendMoveSizeMessages.PosChanged">
<short>
<b>True</b> if a TLMMove message is constructed and dispatched in the method.
</short>
</element>

<element name="TControl.ConstrainedResize">
<short>Signals the OnConstrainedResize handler.</short>
<descr>
<p>
<var>ConstrainedResize</var> is a method used to signal the 
<var>OnConstrainedResize</var> event handler (when assigned) for the control.
</p>
<p>
It is called from the DoConstrainedResize method, and occurs after values 
from Constraints have been normalized to the constraints from the LCL 
interface. The normalized values are stored in the MinWidth, MinHeight, 
MaxWidth, and MaxHeight arguments and passed to the OnConstrainedResize event 
handler.
</p>
</descr>
<seealso>
<link id="TControl.OnConstrainedResize"/>
<link id="TControl.Constraints"/>
</seealso>
</element>
<element name="TControl.ConstrainedResize.MinWidth">
<short>
Variable argument with the minimum width for the control.
</short>
</element>
<element name="TControl.ConstrainedResize.MinHeight">
<short>
Variable argument with the minimum height for the control.
</short>
</element>
<element name="TControl.ConstrainedResize.MaxWidth">
<short>
Variable argument with the maximum width for the control.
</short>
</element>
<element name="TControl.ConstrainedResize.MaxHeight">
<short>
Variable argument with the maximum height for the control.
</short>
</element>

<element name="TControl.CalculatePreferredSize">
<short>
Override this method to return the preferred height and width for the control.
</short>
<descr>
<p>
Calculates the preferred width and height for a control, which is used by the 
LCL auto-sizing algorithms as the default size. Negative or zero (0) values 
are treated as undefined and the LCL uses other sizes instead. This value is 
independent of constraints and siblings, only the inner parts are relevant.
</p>
<p>
<var>TWinControl</var> overrides this and asks the interface for theme 
dependent values. See <link id="TWinControl.CalculatePreferredSize"/> for 
more information.
</p>
<p>
When WithThemeSpace contains <b>True</b>, space is added for stacking.
</p>
<p>
For example: <var>TRadioButton</var> has a minimum size. But for stacking 
multiple TRadioButtons there should be some space around the controls. This 
space is theme-dependent, so the parameter is passed to the widgetset.
</p>
</descr>
</element>
<element name="TControl.CalculatePreferredSize.PreferredWidth">
<short>Set this argument to the preferred width.</short>
</element>
<element name="TControl.CalculatePreferredSize.PreferredHeight">
<short>Set this argument to the preferred height.</short>
</element>
<element name="TControl.CalculatePreferredSize.WithThemeSpace">
<short>
<b>True</b> when space around stacked controls should be added.
</short>
</element>

<element name="TControl.DoOnResize">
<short>Signals OnResize event handlers for the control.</short>
<descr>
<p>
Signals the <var>OnResize</var> event handler (when assigned) using the 
control instance as the Sender for the event notification. Calls 
DoCallNotifyHandler to signal any handler routines using the chtOnResize 
handler type.
</p>
</descr>
<seealso>
<link id="TControl.OnResize"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControlHandlerType"/>
</seealso>
</element>

<element name="TControl.DoOnChangeBounds">
<short>
Signals OnChangeBounds event handlers for the control.
</short>
<descr>
<p>
<var>DoOnChangeBounds</var> ensures that <var>cfOnChangeBoundsNeeded</var> is 
removed from the flag values for the control. DoOnChangeBounds signals the 
<var>OnChangeBounds</var> event handler (when assigned) using the control 
instance as the Sender for the event notification. Calls 
<var>DoCallNotifyHandler</var> to signal any handler routines using the 
<var>chtOnChangeBounds</var> handler type.
</p>
</descr>
<seealso>
<link id="TControl.CheckOnChangeBounds"/>
<link id="TControl.OnChangeBounds"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControlHandlerType"/>
</seealso>
</element>

<element name="TControl.CheckOnChangeBounds">
<short>
Checks for changes and calls <link 
id="#lcl.Controls.TControl.DoOnChangeBounds">DoOnChangeBounds</link> if 
needed.
</short>
<descr>
<p>
Maintains internal members used to track the last bounds rectangle and client 
size before DoOnChangeBounds is called. Called from the LoadedAll and 
ChangeBounds methods.
</p>
</descr>
<seealso>
<link id="TControl.LoadedAll"/>
<link id="TControl.ChangeBounds"/>
<link id="TControl.DoOnChangeBounds"/>
</seealso>
</element>

<element name="TControl.Resize">
<short>Checks for changes and calls DoOnResize if needed.</short>
<descr>
<p>
No actions are performed in the method at design-time, during LCL component 
streaming, or when AutoSizeDelayed is set to <b>True</b>.
</p>
<p>
Resize updates internal members used to track the current values in the 
Width, Height, ClientWidth, and ClientHeight properties. It calls DoOnResize 
to signal OnResize event handler(s) (when assigned) for the control.
</p>
</descr>
<seealso>
<link id="TControl.DoOnResize"/>
<link id="TControl.OnResize"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControlHandlerType"/>
</seealso>
</element>

<element name="TControl.RequestAlign">
<short>
Asks the parent control to realign all controls that are siblings.
</short>
<descr>
<p>
Calls the <var>AdjustSize</var> method to handle resize operations delayed 
during loading or handle creation.
</p>
</descr>
<seealso>
<link id="TControl.AdjustSize"/>
<link id="TWinControl.AlignControls"/>
</seealso>
</element>

<element name="TControl.UpdateAnchorRules">
<short>Update the rules for anchoring the control.</short>
</element>

<element name="TControl.ChangeBounds">
<short>
Sets the bounds (left, top, height, width) and optionally the BaseBounds of 
the control.
</short>
<descr>
<p>
ChangeBounds is called whenever the position or size of the control is set, 
either via the properties or by the layout engine in the LCL.
</p>
<p>
SetBounds calls ChangeBounds internally with KeepBase set to <b>False</b>, 
while the LCL layout engine calls it with KeepBase set to <b>True</b>.
</p>
<p>
Override this for code that might change the preferred size or resizes other 
controls.
</p>
<p>
You can call this function in your custom controls. Keep in mind that the 
given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by 
the LCL before applied.
</p>
</descr>
</element>
<element name="TControl.ChangeBounds.ALeft">
<short>
New value for the Left property in the control.
</short>
</element>
<element name="TControl.ChangeBounds.ATop">
<short>
New value for the Top property in the control.
</short>
</element>
<element name="TControl.ChangeBounds.AWidth">
<short>
New value for the Width property in the control.
</short>
</element>
<element name="TControl.ChangeBounds.AHeight">
<short>
New value for the Height property in the control.
</short>
</element>
<element name="TControl.ChangeBounds.KeepBase">
<short><b>True</b> when the BaseBounds should not be modified.</short>
</element>

<element name="TControl.DoSetBounds">
<short>
Internal function used to set the bounds for the control (Left, Top, Height, 
Width).
</short>
<descr>
<p>
DoSetBounds is a low-level function used to set the private variables FLeft, 
FTop, FWidth, FHeight. Do not call this function; only the LCL calls it.
</p>
<p>
It also updates FClientWidth and FClientHeight accordingly.
</p>
<p>
Override this to update the content layout within the control, for example 
scroll bars. As always: do not paint here, but call Invalidate and paint 
using the OnPaint handler or an overridden Paint method.
</p>
</descr>
</element>
<element name="TControl.DoSetBounds.ALeft">
<short>
Value applied to the Left member in the control.
</short>
</element>
<element name="TControl.DoSetBounds.ATop">
<short>
Value applied to the Top member in the control.
</short>
</element>
<element name="TControl.DoSetBounds.AWidth">
<short>
Value applied to the Width member in the control.
</short>
</element>
<element name="TControl.DoSetBounds.AHeight">
<short>
Value applied to the Height member in the control.
</short>
</element>

<element name="TControl.ScaleConstraints">
<short>Scales the minimum and maximum Width and Height.</short>
<descr>
<p>
<var>ScaleConstraints</var> is called from the ChangeScale method; never 
call it directly. Multiplier and Divider contain the values passed as 
arguments to the ChangeScale method.
</p>
</descr>
<seealso>
<link id="TControl.ChangeScale"/>
<link id="TWinControl.ScaleBy"/>
</seealso>
</element>
<element name="TControl.ScaleConstraints.Multiplier">
<short>
Multiplier used to derive the scaling factor for the control constraints.
</short>
</element>
<element name="TControl.ScaleConstraints.Divider">
<short>
Divisor used to derive the scaling factor for the control constraints.
</short>
</element>

<element name="TControl.ChangeScale">
<short>
Applies scaling (multiplier and divider) to the bounds coordinates, 
constraints, and Font in a control.
</short>
<descr>
<p>
ChangeScale is a method used to apply scaling, expressed by the Multiplier 
and Divider arguments, to size values in the control. These values include:
</p>
<ul>
<li>
The minimum and maximum heights and widths in Constraints (by calling 
ScaleContraints).
</li>
<li>
The Font height (when ParentFont is not enabled).
</li>
<li>
The bounds rectangle for the control (Left, Top, Bottom, and Right). If the 
control is the top-most form in a component hierarchy, the Top and Left 
values are not changed.
</li>
</ul>
<p>
ChangeScale calls the MulDiv routine in the <file>LCLType</file> unit to 
calculate the scaled numeric values. The results from the calculations are 
rounded and returned as an Integer type.
</p>
<p>
No actions are performed in the method when Multiplier and Divider have the 
same value.
</p>
<p>
ChangeScale can be overridden in descendent classes to perform any additional 
action needed for the class type.
</p>
<p>
ChangeScale is called from the ScaleControls and ScaleBy methods in the 
TWinControl descendant.
</p>
</descr>
<seealso>
<link id="TControl.BaseBounds"/>
<link id="TControl.BoundsRect"/>
<link id="TControl.Font"/>
<link id="TControl.ParentFont"/>
<link id="TControl.ScaleConstraints"/>
<link id="TWinControl.ScaleBy"/>
<link id="TWinControl.ScaleControls"/>
<link id="#lcl.lcltype.MulDiv">MulDiv</link>
</seealso>
</element>
<element name="TControl.ChangeScale.Multiplier">
<short>Multiplicand used to calculate the scaled numeric values.</short>
</element>
<element name="TControl.ChangeScale.Divider">
<short>Divisor used to calculate the scaled numeric values.</short>
</element>

<element name="TControl.CanAutoSize">
<short>
Determines if auto-sizing is possible, and if so, gets the new width and 
height when enabled.
</short>
<descr>
<p>
Always returns <b>True</b> in TControl. The values in NewWidth and NewHeight 
are not updated in TControl. Override the method in descendent classes to 
return values as needed for the class type.
</p>
</descr>
</element>
<element name="TControl.CanAutoSize.Result">
<short>TControl returns <b>True</b>.</short>
</element>
<element name="TControl.CanAutoSize.NewWidth">
<short>Suggested width, can be adjusted in an overridden version.</short>
</element>
<element name="TControl.CanAutoSize.NewHeight">
<short>Suggested height, can be adjusted in an overridden version.</short>
</element>

<element name="TControl.SetBiDiMode">
<short>Sets the value for the BiDiMode property.</short>
<descr>
</descr>
<seealso>
<link id="TControl.BiDiMode"/>
</seealso>
</element>
<element name="TControl.SetBiDiMode.AValue">
<short>New value for the BiDiMode property.</short>
</element>

<element name="TControl.SetParentBiDiMode">
<short>Sets the value for the ParentBiDiMode property.</short>
<descr/>
<seealso>
<link id="TControl.ParentBiDiMode"/>
</seealso>
</element>
<element name="TControl.SetParentBiDiMode.AValue">
<short>New value for the ParentBiDiMode property.</short>
</element>

<element name="TControl.IsAParentAligning">
<short>
Determines if a parent control is involved in the alignment process for the 
control.
</short>
<descr>
<p>
The return value is <b>True</b> when a control in the Parent hierarchy has 
been assigned and has wcfAligningControls in its Window control flags. The 
return value is <b>False</b> if both conditions are not satisfied.
</p>
<remark>
This method is not used in the current LCL implementation.
</remark>
</descr>
</element>
<element name="TControl.IsAParentAligning.Result">
<short>
<b>True</b> if a Parent control is actively aligning its descendent controls.
</short>
</element>

<element name="TControl.GetClientOrigin">
<short>Gets the value for the ClientOrigin property.</short>
<descr/>
<seealso>
<link id="TControl.ClientOrigin"/>
</seealso>
</element>
<element name="TControl.GetClientOrigin.Result">
<short>Value for the ClientOrigin property.</short>
</element>

<element name="TControl.GetClientRect">
<short>Gets the value for the ClientRect property.</short>
<descr>
<p>
Returns the size for the visual client area in the control. For example, the 
inner size of a TGroupBox. For a TScrollBox it is the visual size, and not 
the logical size.
</p>
<p>
The return value is a TRect instance with the Top and Left members set to 0, 
and the Height and Width members set to the corresponding property values for 
the control.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.ClientRect">TControl.ClientRect</link>
</seealso>
</element>
<element name="TControl.GetClientRect.Result">
<short>Value for the ClientRect property.</short>
</element>

<element name="TControl.GetLogicalClientRect">
<short>
Logical client area, can be bigger than the visible client area.
</short>
<descr>
A <link id="Forms.TScrollingWinControl"/> has a logical client area, of which 
only a portion can be visible. The origin always is (0,0), regardless of an 
ScrollOffset.
</descr>
<seealso>
<link id="TControl.BoundsRect"/>
<link id="TControl.ClientRect"/>
<link id="TControl.GetScrolledClientRect"/>
</seealso>
</element>
<element name="TControl.GetLogicalClientRect.Result">
<short>TControl returns the ClientRect.</short>
</element>

<element name="TControl.GetScrolledClientRect">
<short>Get the visible part of the logical client area.</short>
<descr>
<p>
Includes the ScrollOffset in a TScrollingWinControl Parent.
</p>
<p>
For TControl: When the Parent is a TScrollingWinControl, the ClientRect is 
offset by its ScrollOffset. This Rect can be intersected with the visible 
ClientArea of the Parent, to get the actual visible part of the control.
</p>
<p>
For TWinControl: The visible ClientRect is offset by ScrollOffset, to reflect 
the visible part of the logical ClientRect.
</p>
</descr>
<seealso>
<link id="TControl.ClientRect"/>
<link id="TControl.GetScrolledClientRect"/>
</seealso>
</element>
<element name="TControl.GetScrolledClientRect.Result">
<short>
The scrolled ClientRect (TopLeft, BottomRight).
</short>
</element>

<element name="TControl.GetClientScrollOffset">
<short>
Returns the offset of the scrolled client area (in a scrolling TWinControl).
</short>
<descr>
<p>
The overridden method may fail when the TScrollingWinControl has only one 
scroll bar.
</p>
</descr>
<seealso>
<link id="TControl.GetScrolledClientRect"/>
<link id="#lcl.forms.TScrollingWinControl.GetClientScrollOffset">
TScrollingWinControl.GetClientScrollOffset</link>
</seealso>
</element>
<element name="TControl.GetClientScrollOffset.Result">
<short>
The X and Y offsets of the visible client area, equal to the scroll bar 
positions.
</short>
</element>

<element name="TControl.GetControlOrigin">
<short>
Gets the value for the ControlOrigin property.
</short>
<descr>
<p>
Returns the origin (top, left pixel) for the control, in screen coordinates.
</p>
</descr>
<seealso>
<link id="TControl.ControlOrigin"/>
</seealso>
</element>
<element name="TControl.GetControlOrigin.Result">
<short>Value for the ControlOrigin property.</short>
</element>

<element name="TControl.IsClientHeightStored">
<short>
Implements the storage specifier for the ClientHeight property.
</short>
<descr/>
<seealso>
<link id="TControl.ClientHeight"/>
</seealso>
</element>
<element name="TControl.IsClientHeightStored.Result">
<short>
<b>True</b> if the value for ClientHeight is stored using LCL component 
streaming.
</short>
</element>

<element name="TControl.IsClientWidthStored">
<short>
Implements the storage specifier for the ClientWidth property.
</short>
<descr/>
<seealso>
<link id="TControl.ClientWidth"/>
</seealso>
</element>
<element name="TControl.IsClientWidthStored.Result">
<short>
<b>True</b> if the property is stored using LCL component streaming.
</short>
</element>

<element name="TControl.WidthIsAnchored">
<short>
<b>True</b> when both the control's left and right side are anchored.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WidthIsAnchored.Result">
<short><b>True</b> if the Width varies with the Parent.Width.</short>
</element>

<element name="TControl.HeightIsAnchored">
<short>
<b>True</b> when both the control's top and bottom side are anchored.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.HeightIsAnchored.Result">
<short>
<b>True</b> if the Height varies with the Parent.Height.
</short>
</element>

<element name="TControl.AutoSizing">
<short>
Contains <b>True</b> while auto-sizing is in progress.
</short>
<descr>
<p>
<var>AutoSizing</var> is a read-only <var>Boolean</var> property which 
indicates if an auto-size operation is currently active for the control. The 
property value is set to <b>True</b> when the <var>BeginAutoSizing</var> 
method is called, and set to <b>False</b> in the <var>EndAutoSizing</var> 
method. These methods raise a catchable exception when AutoSizing does not 
contain the expected / required value.
</p>
</descr>
<seealso>
<link id="TControl.BeginAutoSizing"/>
<link id="TControl.EndAutoSizing"/>
</seealso>
</element>

<element name="TControl.AutoSizingAll">
<short>Flag to prevent recursive AutoSizing (in DoAllAutoSize).</short>
<descr>
By default Parent.AutoSizingAll is read, because a mere TControl cannot have 
child controls.
</descr>
<seealso/>
</element>

<element name="TControl.AutoSizingLockCount">
<short>
Internal counter increased and decreased in the DisableAutoSizing and 
EnableAutoSizing methods.
</short>
<descr/>
<seealso/>
</element>

<element name="TControl.WMCancelMode">
<short>
Handles a LM_CANCELMODE message for the control.
</short>
<descr>
<p>
Calls the SetCaptureControl routine to clear the value in the CaptureControl 
variable.
</p>
</descr>
</element>
<element name="TControl.WMCancelMode.Message">
<short>Message handled in the method.</short>
</element>

<element name="TControl.WMContextMenu">
<short>
Handles a LM_CONTEXTMENU message for the control.
</short>
<descr>
<p>
No actions are performed in the method at design-time, or when the result 
code in Message has a non-zero value.
</p>
<p>
Calls DoContextPopup to signal the OnContextPopup event handler (when 
assigned). No additional actions are performed in the method if the context 
menu was displayed and executed in the OnContextPopup event handler.
</p>
<p>
Otherwise, the TPopupMenu instance in the PopupMenu property is displayed and 
executed by calling its Popup method.
</p>
<p>
The result code in Message is set to 1 if the context menu was displayed and 
executed in the method.
</p>
</descr>
<seealso>
<link id="TControl.PopupMenu"/>
<link id="TControl.DoContextPopup"/>
<link id="TControl.OnContextPopup"/>
<link id="#lcl.menus.TPopupMenu">TPopupMenu</link>
</seealso>
</element>
<element name="TControl.WMContextMenu.Message">
<short>Message examined and optionally handled in the method.</short>
</element>

<element name="TControl.WMLButtonDown">
<short>
Handles a LM_LBUTTONDOWN (left mouse button down) message for the control.
</short>
<descr>
<p>
Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property 
and the left mouse button is included in CaptureMouseButtons. Includes 
csClicked in ControlState when click events have been enabled in the 
ControlStyle property.
</p>
<p>
Calls the DoMouseDown method to perform the mouse button event for the 
control, and to signal its OnMouseDown event handler (when assigned). No 
mouse down actions are performed when standard events are ignored by 
including csNoStdEvents in the ControlStyle property.
</p>
</descr>
<seealso>
<link id="TControl.ControlStyle"/>
<link id="TControl.MouseCapture"/>
<link id="TControl.CaptureMouseButtons"/>
<link id="TControl.DoMouseDown"/>
<link id="TControl.MouseDown"/>
<link id="TControl.OnMouseDown"/>
<link id="TMouseButton"/>
</seealso>
</element>
<element name="TControl.WMLButtonDown.Message">
<short>Message handled in the method.</short>
</element>

<element name="TControl.WMRButtonDown">
<short>
Handles a LM_RBUTTONDOWN (right mouse button down) message for the control.
</short>
<descr>
<p>
Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property 
and the right mouse button is included in CaptureMouseButtons.
</p>
<p>
Calls the DoMouseDown method to perform the mouse button event for the 
control, and to signal its OnMouseDown event handler (when assigned). No 
mouse down actions are performed when standard events are ignored by 
including csNoStdEvents in the ControlStyle property.
</p>
</descr>
<seealso>
<link id="TControl.ControlStyle"/>
<link id="TControl.MouseCapture"/>
<link id="TControl.CaptureMouseButtons"/>
<link id="TControl.MouseDown"/>
<link id="TControl.DoMouseDown"/>
<link id="TControl.OnMouseDown"/>
<link id="TMouseButton"/>
</seealso>
</element>
<element name="TControl.WMRButtonDown.Message">
<short>Message handled in the method.</short>
</element>

<element name="TControl.WMMButtonDown">
<short>
Handles a LM_MBUTTONDOWN (middle mouse button down) message for the control.
</short>
<descr>
<p>
Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property 
and the middle mouse button is included in CaptureMouseButtons.
</p>
<p>
Calls the DoMouseDown method to perform the mouse button event for the 
control, and to signal its OnMouseDown event handler (when assigned). No 
mouse down actions are performed when standard events are ignored by 
including csNoStdEvents in the ControlStyle property.
</p>
</descr>
<seealso>
<link id="TControl.ControlStyle"/>
<link id="TControl.MouseCapture"/>
<link id="TControl.CaptureMouseButtons"/>
<link id="TControl.MouseDown"/>
<link id="TControl.DoMouseDown"/>
<link id="TControl.OnMouseDown"/>
<link id="TMouseButton"/>
</seealso>
</element>
<element name="TControl.WMMButtonDown.Message">
<short>Message handled in the method.</short>
</element>

<element name="TControl.WMXButtonDown">
<short>
Handles a LM_XBUTTONDOWN (extra mouse button down) message for the control.
</short>
<descr>
<p>
Checks the Keys member in Message to determine whether the first or second 
extra mouse button is represented in the structure. No actions are performed 
in the method if Keys does not represent the mbExtra1 or mbExtra2 mouse 
button.
</p>
<p>
Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property 
and the mouse button is included in CaptureMouseButtons.
</p>
<p>
Calls the DoMouseDown method to perform the mouse button event for the 
control, and to signal its OnMouseDown event handler (when assigned). No 
mouse down actions are performed when standard events are ignored by 
including csNoStdEvents in the ControlStyle property.
</p>
</descr>
<seealso>
<link id="TControl.ControlStyle"/>
<link id="TControl.MouseCapture"/>
<link id="TControl.CaptureMouseButtons"/>
<link id="TControl.MouseDown"/>
<link id="TControl.DoMouseDown"/>
<link id="TControl.OnMouseDown"/>
<link id="TMouseButton"/>
</seealso>
</element>
<element name="TControl.WMXButtonDown.Message">
<short>Message examined and optionally handled in the method.</short>
</element>

<element name="TControl.WMLButtonDblClk">
<short>
Handles a left mouse button double click message for the control.
</short>
<descr>
<p>
<var>WMLButtonDblClk</var> is a method used to handle a LM_LBUTTONDBLCLK 
window message for the control. Values in ControlStyle and 
CaptureMouseButtons are used to determine if MouseCapture is enabled in the 
method. The MouseDown method is called to update the mouse pointer position 
and to signal the OnMouseDown event handler (when assigned). The DblClick 
method is called to signal the OnDblClick event handler (when assigned).
</p>
</descr>
<seealso>
<link id="TControl.MouseCapture"/>
<link id="TControl.ControlStyle"/>
<link id="TControl.CaptureMouseButtons"/>
<link id="TControl.MouseDown"/>
<link id="TControl.DblClick"/>
</seealso>
</element>
<element name="TControl.WMLButtonDblClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMRButtonDblClk">
<short>
Message handler for right mouse button double click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMRButtonDblClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMMButtonDblClk">
<short>
Message handler for middle mouse button double click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMMButtonDblClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMXButtonDblClk">
<short>
Message handler for extra mouse button double click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMXButtonDblClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMLButtonTripleClk">
<short>
Message handler for left mouse button triple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMLButtonTripleClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMRButtonTripleClk">
<short>
Message handler for right mouse button triple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMRButtonTripleClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMMButtonTripleClk">
<short>
Message handler for middle mouse button triple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMMButtonTripleClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMXButtonTripleClk">
<short>
Message handler for extra mouse button triple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMXButtonTripleClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMLButtonQuadClk">
<short>
Message handler for left mouse button quadruple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMLButtonQuadClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMRButtonQuadClk">
<short>
Message handler for right mouse button quadruple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMRButtonQuadClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMMButtonQuadClk">
<short>
Message handler for middle mouse button quadruple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMMButtonQuadClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMXButtonQuadClk">
<short>
Message handler for extra mouse button quadruple click events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMXButtonQuadClk.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMXButtonup">
<short>
Message handler for extra mouse button up events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMXButtonup.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMMouseMove">
<short>
Message handler for mouse move events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMMouseMove.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMLButtonUp">
<short>
Message handler for left mouse button up events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMLButtonUp.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMRButtonUp">
<short>
Message handler for right mouse button up events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMRButtonUp.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMMButtonUp">
<short>
Message handler for middle mouse button up events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMMButtonUp.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMMouseWheel">
<short>Handles mouse wheel messages for the control.</short>
</element>
<element name="TControl.WMMouseWheel.Message">
<short>Mouse wheel message handled in the method.</short>
</element>

<element name="TControl.WMMouseHWheel">
<short>Handles horizontal mouse wheel messages for the control.</short>
</element>
<element name="TControl.WMMouseHWheel.Message">
<short>Mouse wheel message handled in the method.</short>
</element>

<element name="TControl.WMMove">
<short>
Message handler for control move events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMMove.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMSize">
<short>
Message handler for changed control size.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMSize.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.WMWindowPosChanged">
<short>
Message handler for changed control position events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.WMWindowPosChanged.Message">
<short>Window message handled in the method.</short>
</element>

<element name="TControl.CMChanged">
<short>
Handles CM_CHANGED control messages for the control.
</short>
<descr>
<p>
Calls the WindowProc method in the Parent control (when assigned) to handle 
the control message in Message.
</p>
</descr>
<seealso>
<link id="TControl.WindowProc"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMChanged.Message">
<short>Control message handled in the method.</short>
</element>

<element name="TControl.LMCaptureChanged">
<short>
Handles a LM_CaptureChanged message for the control.
</short>
<descr>
<p>
<var>LMCaptureChanged</var> handles a LM_CAPTURECHANGED control message 
received when the mouse capture control has been changed. LMCaptureChanged 
calls the CaptureChanged method which notifies the DragManager singleton of 
the mouse capture change.
</p>
</descr>
<seealso>
<link id="TControl.CaptureChanged"/>
<link id="TDragManager.CaptureChanged"/>
<link id="DragManager"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.LMCaptureChanged.Message">
<short>
Control message examined and handled in the method.
</short>
</element>

<element name="TControl.CMBiDiModeChanged">
<short>
Handles CM_BIDIMODECHANGED messages for the control.
</short>
<descr>
<p>
Calls the Invalidate method to redraw the control when the wParam member in 
Message is 0 (zero).
</p>
</descr>
<seealso>
<link id="TControl.Invalidate"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMBiDiModeChanged.Message">
<short>
Message examined and handled in the method.
</short>
</element>

<element name="TControl.CMSysFontChanged">
<short>
Handles the CM_SYSFONTCHANGED message for the control.
</short>
<descr>
<p>
<var>CMSysFontChanged</var> ensures that a control with its DesktopFont 
property set to <b>True</b> is updated when the system font has been changed. 
The Font property in the control is set to the value in SystemFont from the 
Screen singleton.
</p>
<p>
No actions are performed in the method when DesktopFont is set to 
<var>False</var>.
</p>
</descr>
<seealso>
<link id="TControl.DesktopFont"/>
<link id="TControl.Font"/>
<link id="#lcl.forms.Screen">Screen</link>
<link id="#lcl.forms.TScreen.SystemFont">TScreen.SystemFont</link>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMSysFontChanged.Message">
<short>
Control message which triggered the method. Not used in the method.
</short>
</element>

<element name="TControl.CMEnabledChanged">
<short>
Handles a CM_ENABLEDCHANGED message for the control.
</short>
<descr>
<p>
Calls the Invalidate method and causes the control to be redrawn when the 
Enabled state has been changed.
</p>
</descr>
<seealso>
<link id="TControl.Invalidate"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMEnabledChanged.Message">
<short>
Message which triggered the method.
</short>
</element>

<element name="TControl.CMHitTest">
<short>
Handles the CM_HITTEST message for the control.
</short>
<descr>
<p>
The hit test handler determines if the control was located at the mouse 
position for the test. Sets the Result member in Message to 1 if it was 
received by the control.
</p>
<p>
Descendent control may reimplement the method to check for a specific area on 
the control, like a border or a dock site.
</p>
</descr>
<seealso>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMHitTest.Message">
<short>
Message with the result for the hit test.
</short>
</element>

<element name="TControl.CMMouseEnter">
<short>
Handles a CM_MOUSEENTER message for the control.
</short>
<descr>
<p>
<var>CMMouseEnter</var> ensures that the <var>MouseInClient</var> property is 
updated when the mouse pointer enters the client area for the control. No 
actions are performed in the method if MouseInClient is already set to 
<b>True</b> on entry.
</p>
<p>
CMMouseEnter calls Perform to broadcast the CM_MOUSEENTER message to the 
Parent and ancestor controls (when assigned). If the Message is not a child 
message, the MouseEnter method is called to signal the OnMouseEnter event 
handler (when assigned).
</p>
</descr>
<seealso>
<link id="TControl.MouseInClient"/>
<link id="TControl.Parent"/>
<link id="TControl.Perform"/>
<link id="TControl.MouseEnter"/>
<link id="TControl.OnMouseEnter"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMMouseEnter.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TControl.CMMouseLeave">
<short>
Handles a CM_MOUSELEAVE message for the control.
</short>
<descr>
<p>
<var>CMMouseLeave</var> ensures that the <var>MouseInClient</var> property is 
updated when the mouse pointer has left the client area for the control. No 
actions are performed in the method if MouseInClient is already set to 
<b>False</b> on entry.
</p>
<p>
CMMouseLeave calls Perform to broadcast the CM_MOUSELEAVE message to the 
Parent and ancestor controls (when assigned). If the Message is not a child 
message, the MouseLeave method is called to signal the OnMouseLeave event 
handler (when assigned).
</p>
</descr>
<seealso>
<link id="TControl.MouseInClient"/>
<link id="TControl.Parent"/>
<link id="TControl.Perform"/>
<link id="TControl.MouseLeave"/>
<link id="TControl.OnMouseLeave"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMMouseLeave.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TControl.CMHintShow">
<short>
Handles the CM_HINTSHOW message for the control.
</short>
<descr>
<p>
<var>CMHintShow</var> is a method used to handle a CM_HINTSHOW message 
received by the control.
</p>
<p>
<var>Message</var> is the <var>TLMessage</var> instance with the control 
message constant, hint information, and result code used in the method.
</p>
<p>
CMHintShow calls DoOnShowHint to signal the OnShowHint event handler (when 
assigned) using the hint information in Message. When ActionLink has been 
assigned, its DoShowHint is called using the hint information.
</p>
<p>
The result code is Message is updated prior to exiting from the method.
</p>
</descr>
<seealso>
<link id="TControl.ActionLink"/>
<link id="TControl.DoOnShowHint"/>
<link id="TControl.OnShowHint"/>
<link id="TControlActionLink.DoShowHint"/>
<link id="#lcl.forms.TCMHintShow">TCMHintShow</link>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMHintShow.Message">
<short>
Message with the hint information displayed for the control.
</short>
</element>

<element name="TControl.CMParentBiDiModeChanged">
<short>
Handles a CM_PARENTBIDIMODECHANGED message for the control.
</short>
<descr>
<p>
<var>CMParentBiDiModeChanged</var> ensures that the BidiMode property from the Parent control is used when the ParentBidiMode property is set to 
<b>True</b>. No actions are performed in the method when ParentBidiMode is set to <b>False</b>.
</p>
</descr>
<seealso>
<link id="TControl.BiDiMode"/>
<link id="TControl.ParentBiDiMode"/>
<link id="TControl.Parent"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMParentBiDiModeChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TControl.CMParentColorChanged">
<short>
Handles a CM_PARENTCOLORCHANGED message for the control.
</short>
<descr>
<p>
<var>CMParentColorChanged</var> ensures that the Color property is updated when the message is received for the control. The property value from the Parent control is stored in Color when ParentColor is set to <b>True</b>. 
No actions are performed in the method when ParentColor is set to 
<var>False</var>.
</p>
</descr>
<seealso>
<link id="TControl.Color"/>
<link id="TControl.ParentColor"/>
<link id="TControl.Parent"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
</seealso>
</element>
<element name="TControl.CMParentColorChanged.Message">
<short>
Message handled in the method.
</short>
</element>

<element name="TControl.CMParentFontChanged">
<short>
Handles a CM_PARENTFONTCHANGED message for the control.
</short>
<descr>
<p>
<var>CMParentFontChanged</var> ensures that the Font from the Parent control 
is applied to the class instance when the message is received. It applies the 
PixelsPerInch setting in the Parent font (which is not included in object 
persistence) to the Font in the control.
</p>
<p>
No actions are performed in the method if ParentFont is set to <b>False</b>, 
or when the Parent property has not been assigned.
</p>
<remark>
The current LCL version calls the ParentFontChanged method prior to exit. It 
has an empty implementation, and is maintained only for compatibility with 
older versions of the LCL. The work is actually performed in this method.
</remark>
</descr>
<seealso>
<link id="TControl.Font"/>
<link id="TControl.ParentFont"/>
<link id="TControl.Parent"/>
<link id="TControl.ParentFOntChanged"/>
<link id="#lcl.graphics.TFont.PixelsPerInch">TFont.PixelsPerInch</link>
</seealso>
</element>
<element name="TControl.CMParentFontChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TControl.CMParentShowHintChanged">
<short>
Handles a CM_PARENTSHOWHINTCHANGED message for the control.
</short>
<descr>
<p>
<var>CMParentShowHintChanged</var> ensures that the ShowHint property in the 
control is updated when the corresponding property in the Parent control is 
changed. When ParentShowHint is set to <b>True</b>, the ShowHint property 
from the Parent is copied into the control.
</p>
</descr>
<seealso>
<link id="TControl.ShowHint"/>
<link id="TControl.ParentShowHint"/>
</seealso>
</element>
<element name="TControl.CMParentShowHintChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TControl.CMVisibleChanged">
<short>
Handles a CM_VISIBLECHANGED message for the control.
</short>
<descr>
<p>
<var>CMVisibleChanged</var> causes the control to be redrawn using the 
Visible and ControlStyle properties in the class instance. It allows a 
parented control to be redrawn using the visibility and opacity settings for 
the control. It calls the InvalidateControl method to invalidate the bounds 
rectangle or the control.
</p>
<p>
No actions are performed in the method at design-time.
</p>
</descr>
<seealso>
<link id="TControl.Visible"/>
<link id="TControl.ControlStyle"/>
<link id="#rtl.classes.TComponent.ComponentState">TComponent.ComponentState</link>
</seealso>
</element>
<element name="TControl.CMVisibleChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TControl.CMTextChanged">
<short>
Handles a CM_TEXTCHANGED message for the control.
</short>
<descr>
<p>
Calls the TextChanged method when the message is received by the control.
</p>
</descr>
<seealso>
<link id="TControl.TextChanged"/>
</seealso>
</element>
<element name="TControl.CMTextChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TControl.CMCursorChanged">
<short>
Handles the CM_CURSORCHANGED message for the control.
</short>
<descr>
<p>
At run-time, the SetTempCursor method is called to apply the temporary cursor 
shape in the Cursor property. No actions are performed in the method at 
design-time.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.CMCursorChanged.Message">
<short>Control message handled in the method.</short>
</element>

<element name="TControl.CalculateDockSizes">
<short>Saves the docked and undocked extent of the control.</short>
<descr>
<p>
In the floating state, it sets UndockWidth/Height to the current 
Width/Height. In docked state, it sets LRDockWidth/TBDockHeight to the 
current Width/Height.
</p>
<remark>
Should save both in any case, independent from DockOrientation or host Align. 
Rationale: a DockManager will either ignore these values, or use them 
according to the <b><i>new</i></b> alignment. Without a DockManager both 
extents are required, because no (valid) alignment information applies.
</remark>
</descr>
</element>

<element name="TControl.CreateFloatingDockSite">
<short>
Create a floating dock site with a client area equal to the given screen 
coordinates.
</short>
<descr>
The new dock site is owned by the control.
</descr>
</element>
<element name="TControl.CreateFloatingDockSite.Result">
<short>
The dock site, can be <b>Nil</b> for a TWinControl that can float by itself.
</short>
</element>
<element name="TControl.CreateFloatingDockSite.Bounds">
<short>The bounds of the client area of the floating window.</short>
</element>

<element name="TControl.GetDockEdge">
<short>
Determines the side to which the dragged control shall be docked.
</short>
</element>
<element name="TControl.GetDockEdge.Result">
<short>
Alignment edge for the docked control. Default value is alNone.
</short>
</element>
<element name="TControl.GetDockEdge.MousePos">
<short>
Mouse position relative to the Left, Top properties in the control.
</short>
</element>

<element name="TControl.GetDragImages">
<short>
Get the list of images used when a drag operation is active.
</short>
</element>
<element name="TControl.GetDragImages.Result">
<short>
Always returns <b>Nil</b> in TControl.
</short>
</element>

<element name="TControl.GetFloating">
<short>Determines whether the control is floating.</short>
<descr>
<p>
Floating state is assumed when the control has a HostDockSite using the 
FloatingDockSiteClass type, and 0 or 1 docked clients.
</p>
</descr>
</element>
<element name="TControl.GetFloating.Result">
<short>
True if HostDockSite is a floating dock site with 0 0r 1 docked clients.
</short>
</element>

<element name="TControl.GetFloatingDockSiteClass">
<short>Returns the class for a floating host dock site.</short>
<descr>
<p>
An instance of this class is created whenever a control shall float,
but cannot (or shall not) float by itself.
</p>
<p>
Only TWinControls can float on the screen (with Parent=Nil), but not ordinary 
TControls.
</p>
<p>
Since dockable forms are not supported by every platform, a dockable 
TWinControl may need a floating host which presents a docking handle to the 
user (e.g. a dock caption).
</p>
</descr>
<seealso>
<link id="TControl.CreateFloatingDockSite"/>
</seealso>
</element>
<element name="TControl.GetFloatingDockSiteClass.Result">
<short>The class of a floating host dock site for this control.</short>
</element>

<element name="TControl.BeforeDragStart">
<short>
Performs actions needed before a drag operation is started for the control.
</short>
<descr>
<p>
<var>BeforeDragStart</var> has an empty implementation in 
<var>TControl</var>. The virtual method can be overridden in descendent 
classes to perform the actions needed. Some common actions include updating 
control flags or checking for a valid Handle before starting the drag 
operation.
</p>
<p>
BeforeDragStart is called from the DragStart method in TDragManager.
</p>
</descr>
<seealso>
<link id="TDragManager.DragStart"/>
<link id="DragManager"/>
</seealso>
</element>

<element name="TControl.BeginAutoDrag">
<short>For internal use: user has started dragging the control.</short>
</element>

<element name="TControl.DoFloatMsg">
<short>Handler called when the control starts floating.</short>
<descr>
<p>
Since TControls cannot float for themselves, a FloatHost site is created and 
the control is docked into it.
</p>
<p>
When the control already has a Parent (FloatHost site), the Parent's position 
and extent is adjusted to fit the DockRect as its ClientRect.
</p>
</descr>
</element>
<element name="TControl.DoFloatMsg.ADockSource">
<short>The DockObject of the current drag-dock operation.</short>
</element>

<element name="TControl.DockTrackNoTarget">
<short>
Adjust the DockRect for floating state (no drop target under the mouse).
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.DockTrackNoTarget.Source">
<short>
The dragged DockObject, containing the DockRect to adjust.
</short>
</element>
<element name="TControl.DockTrackNoTarget.X">
<short>The horizontal mouse position in screen coordinates.</short>
</element>
<element name="TControl.DockTrackNoTarget.Y">
<short>The vertical mouse position in screen coordinates.</short>
</element>

<element name="TControl.DoDock">
<short>
Adjusts the control position and extent for the new docksite.
</short>
<descr>
<p>
DoDock is an Internal method, called by Dock, to performs actions needed when 
a control is docked to a docksite.
</p>
<p>
If NewDockSite=Nil, Parent is set to <b>Nil</b> (in preparation of floating 
the control). Otherwise ARect is ignored, and recomputed to fit approximately 
into the ClientRect of the NewDockSite.
</p>
<p>
Finally the computed coordinates are stored, in BoundsRectForNewParent when 
the NewDockSite differs from Parent, else in BoundsRect.
</p>
</descr>
<errors>
A correct implementation should allow for computations in a derived class, 
and accept and handle the changed bounds without any further adjustments.
</errors>
<seealso/>
</element>
<element name="TControl.DoDock.NewDockSite">
<short>
The site where the control will be docked, or <b>Nil</b> when it becomes 
floating.
</short>
</element>
<element name="TControl.DoDock.ARect">
<short>The control's new Bounds, in screen coordinates when NewDockSite is 
Nil, else in client coordinates of NewDockSite.
</short>
</element>

<element name="TControl.DoDragMsg">
<short>
Handler for a drag message, sent by the DragManager to the current target 
control.
</short>
<descr>
<p>These messages can be sent while dragging:
</p>
<dl>
<dt>dmFindTarget</dt>
<dd>
Request to determine the possible target control for an drop. A TControl 
returns itself, a TWinControl finds the child control closest to the mouse 
position.
</dd>
<dt>dmDragEnter, dmDragLeave, dmDragMove</dt>
<dd>
Notification of mouse moves. Invokes DragOver, or DockOver if docking. Result 
indicates acceptance of a drop.
</dd>
<dt>dmDragDrop</dt>
<dd>
The dragged object has been dropped onto this control. Invokes DragDrop, or 
DockDrop if docking.
</dd>
</dl>
<p>
The <var>Source</var> argument of the invoked methods is the DragDockObject 
when docking. If the DragObject has been AutoCreated, the dragged control is 
passed as the Source. Otherwise, the DragObject itself is passed as Source.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.DoDragMsg.Result">
<short>
Contains the result for the Drag message.
</short>
<descr>
<p>
The Result member is polymorphic:
</p>
<p>
For dmFindTarget, the result is a reference to the target control. For 
dmDragDropm the result is zero (0). For other drag messages, the result 
indicates acceptance of the drop message.
</p>
</descr>
</element>
<element name="TControl.DoDragMsg.ADragMessage">
<short>The task to perform.</short>
</element>
<element name="TControl.DoDragMsg.APosition">
<short>The mouse position in <b>screen</b> coordinates.</short>
</element>
<element name="TControl.DoDragMsg.ADragObject">
<short>The drag object.</short>
</element>
<element name="TControl.DoDragMsg.ATarget">
<short>The drop target, <b>Nil</b> if none.</short>
</element>
<element name="TControl.DoDragMsg.ADocking">
<short>Distinguishes between a drag-drop and drag-dock operation.</short>
</element>

<element name="TControl.DoEndDock">
<short>
Signals the OnEndDock event handler when the control has been undocked.
</short>
<descr>
<p>
No actions are performed in the method if a handler routine has not been 
assigned to OnEndDock.
</p>
<p>
DoEndDock is called from the EndDrag method in TDragDockObject.
</p>
</descr>
<seealso>
<link id="TControl.OnEndDock"/>
<link id="TDragDockObject.EndDrag"/>
</seealso>
</element>
<element name="TControl.DoEndDock.Target">
<short>
Object instance with the target control or dock site site.
</short>
</element>
<element name="TControl.DoEndDock.X">
<short>
Horizontal mouse coordinate where the mouse button was released.
</short>
</element>
<element name="TControl.DoEndDock.Y">
<short>
Vertical mouse coordinate where the mouse button was released.
</short>
</element>

<element name="TControl.DoEndDrag">
<short>
Signals the OnEndDrag event handler.
</short>
<descr>
<p>
<var>DoEndDrag</var> occurs when a drag operation for the control has been 
completed. In <var>TControl</var>, it signals the <var>OnEndDrag</var> event 
handler (when assigned). Arguments to the handler include the target control 
(or dock site) and the mouse coordinates when the drag operation was 
completed.
</p>
<p>
No actions are perform in the method if a handler routine has not been 
assigned to OnEndDrag.
</p>
<p>
Descendent classes may override the method to perform additional actions 
needed in their implementation.
</p>
<p>
DoEndDrag is called from the EndDrag method in TDragObject.
</p>
</descr>
<seealso>
<link id="TControl.OnEndDrag"/>
<link id="TDragObject.EndDrag"/>
</seealso>
</element>
<element name="TControl.DoEndDrag.Target">
<short>
Object instance with the target control or dock site.
</short>
</element>
<element name="TControl.DoEndDrag.X">
<short>
Horizontal mouse coordinate where the mouse button was released.
</short>
</element>
<element name="TControl.DoEndDrag.Y">
<short>
Vertical mouse coordinate where the mouse button was released.
</short>
</element>

<element name="TControl.DoStartDock">
<short>
Signals the OnStartDock event handler.
</short>
<descr/>
<seealso>
<link id="TControl.OnStartDock"/>
<link id="TDragObject"/>
</seealso>
</element>
<element name="TControl.DoStartDock.DragObject">
<short>
Object instance (TDragObject) for the event notification.
</short>
</element>

<element name="TControl.DoStartDrag">
<short>
Signals the OnStartDrag event handler.
</short>
<descr/>
<seealso>
<link id="TControl.OnStartDrag"/>
<link id="TDragObject"/>
</seealso>
</element>
<element name="TControl.DoStartDrag.DragObject">
<short>
Object instance (TDragObject) for the event notification.
</short>
</element>

<element name="TControl.DragCanceled">
<short>
Notifies the control of a cancelled drag operation.
</short>
<descr>
<p>
DragCanceled has an empty implementation in TControl.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.DragOver">
<short>
Called when an object is dragged over this control; Determines whether a drop 
is acceptable, using the OnDragOver handler.
</short>
<descr>
<p>
An OnDragOver handler is required, or any drop will be rejected (Accept 
becomes <b>False</b>).
</p>
<p>
When an OnDragOver handler is installed, Accept is set to <b>True</b> and can 
be changed by the handler.
</p>
<remark>
Source can be either a TDragObject, or the dragged control.
</remark>
</descr>
<seealso>
<link id="TControl.OnDragOver"/>
<link id="TWinControl.DockOver"/>
</seealso>
</element>
<element name="TControl.DragOver.Source">
<short>The dragged object, a control or a DragObject.</short>
</element>
<element name="TControl.DragOver.X">
<short>
The horizontal mouse position in client coordinates.
</short>
</element>
<element name="TControl.DragOver.Y">
<short>
The vertical mouse position in client coordinates.
</short>
</element>
<element name="TControl.DragOver.State">
<short>State change flag (dsDragEnter, dsDragMove, dsDragLeave).</short>
</element>
<element name="TControl.DragOver.Accept">
<short>Set to <b>True</b> when a drop is allowed.</short>
</element>

<element name="TControl.PositionDockRect">
<short>Get the DockRect for an possible drop.</short>
<descr>
<p>
Calls the <var>DockManager.PositionDockRect</var> in the target site, or 
<var>DragDockObject.AdjustDockRect</var> after moving the undocked control 
rectangle to the <var>DragPos</var>. AdjustDockRect takes the hotspot of the 
DockRect into account.
</p>
</descr>
<seealso>
<link id="TDragDockObject.AdjustDockRect"/>
</seealso>
</element>
<element name="TControl.PositionDockRect.DragDockObject">
<short>
Object instance (TDragDockObject) with the control positioned and aligned in 
the method.
</short>
</element>

<element name="TControl.SetDragMode">
<short>Sets the value for the DragMode property.</short>
<descr/>
<seealso>
<link id="TControl.DragMode"/>
</seealso>
</element>
<element name="TControl.SetDragMode.Value">
<short>New value for the DragMode property.</short>
</element>

<element name="TControl.GetDefaultDockCaption">
<short>
Returns the string for the dock caption, by default the control's Name.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.GetDefaultDockCaption.Result">
<short>
Default value for the dock caption. Defaults to the control name.
</short>
</element>

<element name="TControl.Click">
<short>
Signals OnClick and/or executes the ActionLink when the control has been 
clicked.
</short>
<descr>
<p>
Performs actions needed when the control has been clicked using the mouse or 
its keyboard equivalent.
</p>
<p>
Click uses the value in ActionLink (when assigned) to determine whether 
OnClick and / or Action are executed for the control.
</p>
<p>
When ActionLink has been assigned, it is compared to the routine in the 
OnClick event handler (when assigned). When the routines differ, the OnCLick 
event handler is signalled. If an ActionLink exists, the Execute method in 
ActionLink is called as well.
</p>
<p>
Neither OnClick nor the ActionLink are executed at design-time.
</p>
</descr>
<seealso>
<link id="TControl.OnClick"/>
<link id="TControl.ActionLink"/>
<link id="#rtl.classes.TBasicActionLink.Execute">TBasicActionLink.Execute</link>
</seealso>
</element>

<element name="TControl.DblClick">
<short>
Signals the OnDblClick event handler (when assigned).
</short>
<descr>
<p>
<var>DblCLick</var> is a method used to perform actions needed when a mouse 
double click event has occurred on the control. In TControl, it signals the 
OnDblClick event handler (when assigned) using the class instance as the 
Sender argument in the event type.
</p>
<p>
Descendent classes may override the method to perform additional actions 
needed in the their implementations.
</p>
<p>
DblClick is called from the WMLButtonDBLCLK method when the LM_LBUTTONDBLCLK 
window message is handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.OnDblClick"/>
<link id="TControl.WMLButtonDBLCLK"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.TripleClick">
<short>
Signals the OnTripleClick event handler (when assigned).
</short>
<descr>
<p>
<var>TripleClick</var> is a method used to perform actions needed when a 
mouse triple click event has occurred on the control. In <var>TControl</var>, 
it signals the OnTripleClick event handler (when assigned) using the class 
instance as the Sender argument in the event type.
</p>
<p>
Descendent classes may override the method to perform additional actions 
needed in the their implementations.
</p>
<p>
TripleClick is called from the WMLButtonTripleCLK method when the M_LBUTTONTRIPLECLK window message is handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.OnTripleClick"/>
<link id="TControl.WMLButtonTripleCLK"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.QuadClick">
<short>
Signals the OnQuadClick event handler (when assigned).
</short>
<descr>
<p>
<var>QuadClick</var> is a method used to perform actions needed when a 
mouse quadruple click event has occurred on the control. In 
<var>TControl</var>, it signals the OnQuadClick event handler (when assigned) 
using the class instance as the Sender argument in the event type.
</p>
<p>
Descendent classes may override the method to perform additional actions 
needed in the their implementations.
</p>
<p>
QuadClick is called from the WMLButtonQuadCLK method when the 
M_LBUTTONQUADCLK window message is handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.OnQuadClick"/>
<link id="TControl.WMLButtonQuadCLK"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.GetMousePosFromMessage">
<short>
Converts the coordinates in the mouse message from SmallInt to LongInt values.
</short>
<descr>
<p>
MessageMousePos is a TSmallPoint type with the mouse coordinates as SmallInt 
values. The return value is a TPoint instance with the LongInt values for the 
converted mouse coordinates.
</p>
<p>
If the control has a Width or Height that exceeds the maximum value for the 
SmallInt type, GetCursorPos is called to get the current mouse pointer 
position and the values are converted from screen to client coordinates. 
Otherwise, SmallPointToPoint is called to convert the values in 
MessageMousePos.
</p>
<p>
GetMousePosFromMessage provides coordinates using the type needed in 
MouseDown, MouseUp, MouseMove, and other mouse message handling methods in 
the control.
</p>
</descr>
<seealso>
<link id="TControl.ScreenToClient"/>
<link id="TControl.MouseUp"/>
<link id="TControl.MouseDown"/>
<link id="TControl.MouseMove"/>
<link id="TControl.OnMouseWheelDown"/>
<link id="TControl.OnMouseWheelUp"/>
<link id="#rtl.types.TSmallPoint">TSmallPoint</link>
<link id="#rtl.types.TPoint">TPoint</link>
</seealso>
</element>
<element name="TControl.GetMousePosFromMessage.Result">
<short>
TPoint instance with the LongInt values for the mouse cursor position.
</short>
</element>
<element name="TControl.GetMousePosFromMessage.MessageMousePos">
<short>TSmallPoint instance with the values converted in the method.</short>
</element>

<element name="TControl.DoMouseUp">
<short>
Performs actions needed to handle a mouse up event for the control.
</short>
<descr>
<p>
<var>DoMouseUp</var> is a virtual method used to apply the mouse button up 
event in the Message and Button arguments. DoMouseUp checks the control style 
flags in ControlStyle to determine whether the control responds to standard 
mouse events.
</p>
<p>
No actions are performed in the method when csNoStdEvents has been included 
in ControlStyle. This indicates that mouse events are handled by the 
widgetset class instance for the control.
</p>
<p>
Otherwise, values in Message and Button are applied in the method. When 
DragManager is active for a drag and drop operation, the mouse coordinates in 
Message are converted to screen coordinates and applied using the 
DragManager. The Result member in Message is set to 1 to show that is has 
been handled.
</p>
<p>
The MouseUp method is called to signal the OnMouseUp event handler (when 
assigned).
</p>
<p>
DoMouseUp is called from methods like WMLButtonUp, WMRButtonUp, WMMButtonUp, 
and WMXButtonUp.
</p>
</descr>
<seealso>
<link id="TControl.ControlStyle"/>
<link id="TControl.MouseUp"/>
<link id="TControl.OnMouseUp"/>
<link id="TControl.WMLButtonUp"/>
<link id="TControl.WMRButtonUp"/>
<link id="TControl.WMMButtonUp"/>
<link id="TControl.WMXButtonUp"/>
</seealso>
</element>
<element name="TControl.DoMouseUp.Message">
<short>
Mouse message examined and handled in the method.
</short>
</element>
<element name="TControl.DoMouseUp.Button">
<short>
Mouse button for the message.
</short>
</element>

<element name="TControl.DoMouseDown">
<short>
Performs actions needed to handle a mouse down event for the control.
</short>
<descr>
<p>
<var>DoMouseDown</var> is a virtual method used to apply the mouse button 
down event in the Message and Button arguments. DoMouseDown checks the 
control style flags in ControlStyle to determine whether the control responds 
to standard mouse events.
</p>
<p>
No actions are performed in the method when csNoStdEvents has been included 
in ControlStyle. This indicates that mouse events are handled by the 
widgetset class instance for the control.
</p>
<p>
Otherwise, values in Message and Button are applied in the method. The mouse 
coordinates in Message are converted to screen coordinates, and the message 
is applied by calling the MouseDown method.
</p>
<p>
DoMouseDown is called from methods like: WMLButtonDown, WMRButtonDown, 
WMMButtonDown, and WMXButtonDown.
</p>
</descr>
<seealso>
<link id="TControl.ControlStyle"/>
<link id="TControl.MouseDown"/>
<link id="TControl.OnMouseDown"/>
<link id="TControl.WMLButtonDown"/>
<link id="TControl.WMRButtonDown"/>
<link id="TControl.WMMButtonDown"/>
<link id="TControl.WMXButtonDown"/>
</seealso>
</element>
<element name="TControl.DoMouseDown.Message">
<short>Mouse message examined and handled in the method.</short>
</element>
<element name="TControl.DoMouseDown.Button">
<short>Mouse button for the message.</short>
</element>
<element name="TControl.DoMouseDown.Shift">
<short>Ctrl, Shift, or Alt modifier for the mouse button event.</short>
</element>

<element name="TControl.MouseDown">
<short>Handles a mouse down event for the control.</short>
<descr>
<p>
Called by the <var>MouseDown</var> message handler. Handles Focus changes, 
and notifies the DragManager while dragging. Finally, it calls the <link 
id="TControl.OnMouseDown"/> handler.
</p>
</descr>
</element>
<element name="TControl.MouseDown.Button">
<short>Which buttons are down.</short>
</element>
<element name="TControl.MouseDown.Shift">
<short>Which of Ctrl, Shift or Alt keys are also pressed.</short>
</element>
<element name="TControl.MouseDown.X">
<short>Horizontal Mouse position in <b>client</b> coordinates.</short>
</element>
<element name="TControl.MouseDown.Y">
<short>Vertical Mouse position in <b>client</b> coordinates.</short>
</element>

<element name="TControl.MouseMove">
<short>Handler for MouseMove events.</short>
<descr>
<p>
Called by the <var>MouseMove</var> message handler. The DragManager is 
notified while the control is being dragged. Finally the <link 
id="#lcl.Controls.TControl.OnMouseMove">OnMouseMove</link> handler is invoked.
</p>
</descr>
</element>
<element name="TControl.MouseMove.Shift">
<short>
The currently pressed mouse buttons and modifier keys.
</short>
</element>
<element name="TControl.MouseMove.X">
<short>Horizontal Mouse position in <b>client</b> coordinates.</short>
</element>
<element name="TControl.MouseMove.Y">
<short>Vertical Mouse position in <b>client</b> coordinates.</short>
</element>

<element name="TControl.MouseUp">
<short>
Signals the <link id="#lcl.Controls.TControl.OnMouseUp">OnMouseUp</link> 
handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.MouseUp.Button">
<short>The currently pressed modifier keys.</short>
</element>
<element name="TControl.MouseUp.Shift">
<short>The currently pressed mouse buttons.</short>
</element>
<element name="TControl.MouseUp.X">
<short>Horizontal Mouse position in <b>client</b> coordinates.</short>
</element>
<element name="TControl.MouseUp.Y">
<short>Vertical Mouse position in <b>client</b> coordinates.</short>
</element>

<element name="TControl.MouseEnter">
<short>
Signals the OnMouseEnter event handler (when assigned).
</short>
<descr>
<p>
<var>MouseEnter</var> is a method used to perform actions when the mouse 
pointer enters the client rectangle for the control. In <var>TControl</var>, 
it signals the OnMouseEnter event handler using the class instance as the 
Sender argument.
</p>
<p>
Descendent classes may override the method to perform actions needed for 
their implementations.
</p>
<p>
MouseEnter is called from the CMMouseEnter method when a CM_MOUSEENTER 
message is handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseEnter"/>
<link id="TControl.CMMouseEnter"/>
<link id="TControl.MouseCapture"/>
<link id="TControl.MouseInClient"/>
<link id="TControl.MouseLeave"/>
</seealso>
</element>

<element name="TControl.MouseLeave">
<short>
Signals the OnMouseLeave event handler (when assigned).
</short>
<descr>
<p>
<var>MouseLeave</var> is a method used to perform actions when the mouse 
pointer leaves the client rectangle for the control. In <var>TControl</var>, 
it signals the OnMouseLeave event handler using the class instance as the 
Sender argument.
</p>
<p>
Descendent classes may override the method to perform actions needed for 
their implementations.
</p>
<p>
MouseLeave is called from the CMMouseLeave method when a CM_MOUSELEAVE 
message is handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseLeave"/>
<link id="TControl.CMMouseLeave"/>
<link id="TControl.MouseCapture"/>
<link id="TControl.MouseInClient"/>
<link id="TControl.MouseEnter"/>
</seealso>
</element>

<element name="TControl.DialogChar">
<short>
Performs actions needed to handle an accelerator key for the control.
</short>
<descr>
<p>
Always return <b>False</b> in TControl. The method is overridden in 
descendent classes to perform actions needed to handle an accelerator 
character in the Message argument.
</p>
<p>
This method is called even if the control is disabled or hidden. Provided for 
Delphi VCL compatibility.
</p>
</descr>
<seealso>
<link id="TWinControl.DialogChar"/>
<link id="TWinControl.SendDialogChar"/>
</seealso>
</element>
<element name="TControl.DialogChar.Result">
<short>
<b>True</b> if the accelerator key in Message is handled by the control.
</short>
</element>
<element name="TControl.DialogChar.Message">
<short>TLMKey instance with the character code examined in the method.</short>
</element>

<element name="TControl.UpdateMouseCursor">
<short>Changes the cursor shape to the value in the Cursor property.</short>
<descr>
<p>
UpdateMouseCursor is a method used to change the cursor shape displayed when 
the mouse is hovered over the control. No actions are performed in the method 
at design-time, or when the screen cursor already has a shape other than 
crDefault.
</p>
<p>
UpdateMouseCursor calls SetTempCursor to apply the value in the Cursor 
property to the Parent control.
</p>
<p>
UpdateMouseCursor is called from WMMouseMove after the mouse position has 
been captured, and before the OnMouseMove event handler is signalled.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.UpdateMouseCursor.X">
<short>Not used in the method.</short>
</element>
<element name="TControl.UpdateMouseCursor.Y">
<short>Not used in the method.</short>
</element>

<element name="TControl.Changed">
<short>
Performs actions needed when the value for the control has been changed.
</short>
<descr>
<p>
In <var>TControl</var>, <var>Changed</var> calls Perform to post a CM_CHANGED 
control message to the message processing loop. The Parent control, which 
provides the window handle, receives the message in its CMChanged method and 
calls its WindowProc processing loop.
</p>
<p>
Changed may be overridden or reimplemented in descendent classes to perform 
actions needed in the implementations for the controls. For instance, 
triggering OnChange or other notification events.
</p>
<p>
Changed is called when properties for the control, especially its value, have 
been modified.
</p>
</descr>
<seealso>
<link id="TControl.CMChanged"/>
<link id="TControl.Parent"/>
<link id="TControl.Perform"/>
</seealso>
</element>

<element name="TControl.GetPalette">
<short>
Override <var>GetPalette</var> to return the handle of a color palette.
</short>
<descr>
<p>
Always returns 0 (zero) in TControl.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.GetPalette.Result">
<short>The Palette handle, zero (no Palette) by default.</short>
</element>

<element name="TControl.GetParentBackground">
<short>
Gets the value for the ParentBackground property.
</short>
<descr/>
<seealso>
<link id="TControl.ParentBackground"/>
</seealso>
</element>
<element name="TControl.GetParentBackground.Result">
<short>
Value for the ParentBackground property.
</short>
</element>

<element name="TControl.ChildClassAllowed">
<short>
Returns <b>True</b> if the specified class is allowed for children of this 
control.
</short>
<descr>
<p>
Always returns <b>False</b> in TControl. It is overridden in descendent 
classes to check whether the class reference in ChildClass is allowed for the 
control.
</p>
</descr>
<seealso>
<link id="TWinControl.ChildClassAllowed"/>
</seealso>
</element>
<element name="TControl.ChildClassAllowed.Result">
<short><b>True</b> when the class is allowed as a child control.</short>
</element>
<element name="TControl.ChildClassAllowed.ChildClass">
<short>The class type for the child control.</short>
</element>

<element name="TControl.ReadState">
<short>Updates control flags and reads the data for the component.</short>
<descr/>
<seealso>
<link id="#rtl.classes.TComponent">TComponent</link>
</seealso>
</element>
<element name="TControl.ReadState.Reader">
<short>TReader instance used to read the component data. </short>
</element>

<element name="TControl.Loaded">
<short>
Performs actions needed when LCL component streaming has been completed.
</short>
<descr>
<p>
Calls the inherited method on entry.
</p>
<p>
Ensures that values for Width and Height are available in the Bounds 
rectangle for the control. Explicit values for Width and Height are not 
always available in the values loaded using LCL component streaming. When 
this condition is indicated in the control flags, the ClientWidth and 
ClientHeight loaded from the resource stream are used in the Bounds for the 
control.
</p>
<p>
Ensures that values for Color, Font, BiDiMode, and ShowHint are set to values 
in the Parent control when enabled in the ParentColor, ParentFont, 
ParentBiDiMode, and ParentShowHint properties. The values from Parent are 
omitted when Parent has not been assigned.
</p>
<p>
Calls UpdateBaseBounds to store the bounds rectangle and client size using 
the loaded values.
</p>
<p>
If an Action has been assigned in the control, the ActionChange method is 
called to ensure that default values from the Action are applied to the 
control.
</p>
<p>
If an ancestor control is still loading its child controls, resize and align 
operations are deferred for the control. Otherwise, the LoadedAll method is 
called to adjust the sizes and layout for the control.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TComponent">TComponent</link>
</seealso>
</element>

<element name="TControl.LoadedAll">
<short>
Called when the control and its child controls have been loaded, and their 
control state is changed.
</short>
<descr>
<p>
<var>LoadedAll</var> is a procedure called when the control (and its child 
controls) have been loaded using the LCL component streaming mechanism, and 
csLoading is removed from their control state. LoadedAll is called from the 
Loaded method.
</p>
</descr>
<seealso>
<link id="TControl.Loaded"/>
</seealso>
</element>

<element name="TControl.DefineProperties">
<short>
Defines which non-published properties should be streamed (none here).
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.DefineProperties.Filer">
<short>
Object used to read or write values using the LCL resource stream.
</short>
</element>

<element name="TControl.AssignTo">
<short>
Implements assignment of the control to an Action object, or calls the 
inherited method.
</short>
<descr>
<p>
Properties copied in the method include:
</p>
<ul>
<li>Enabled</li>
<li>Hint</li>
<li>Caption</li>
<li>Visible</li>
<li>OnExecute (copied to OnClick in the destination object)</li>
<li>HelpContext</li>
<li>HelpKeyword</li>
<li>HelpType</li>
</ul>
</descr>
<seealso>
<link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
</seealso>
</element>
<element name="TControl.AssignTo.Dest">
<short>Destination object which receives values copied in the method.</short>
</element>

<element name="TControl.FormEndUpdated">
<short>
Called for each control on a form where the update count has reached 0 (zero).
</short>
<descr>
<p>
FormEndUpdated is overridden in descendent classes, like TWinControl, which 
provides a container for its child controls.
</p>
</descr>
<seealso>
<link id="TWinControl.GetChildren"/>
</seealso>
</element>

<element name="TControl.InvalidateControl">
<short>Requests a repaint of the control.</short>
<descr>
<p>
<var>InvalidateControl</var> is an overloaded method used to redraw the 
bounds rectangle for control. No actions are performed in the method if the 
Parent control or its Handle are not assigned, during LCL component 
streaming, or when the control is being freed.
</p>
<p>
When CtrlIsVisible is set to <b>True</b> or the control has a visible design 
surface, the InvalidateRect routine is called. The BoundsRect for the control 
is erased and redrawn when the control uses an opaque drawing style, or when 
it occludes a sibling control in its Parent.
</p>
<p>
InvalidateControl is called from methods like Invalidate and ChangeBounds, 
and when a new value is assigned to the Visible property.
</p>
</descr>
<seealso>
<link id="TControl.Invalidate"/>
<link id="TControl.ChangeBounds"/>
<link id="TControl.Visible"/>
<link id="TControl.VisibleChanged"/>
<link id="TControl.CMVisibleChanged"/>
</seealso>
</element>
<element name="TControl.InvalidateControl.CtrlIsVisible">
<short><b>True</b> if the control is visible.</short>
</element>
<element name="TControl.InvalidateControl.CtrlIsOpaque">
<short><b>True</b> if the control use an opaque drawing style.</short>
</element>
<element name="TControl.InvalidateControl.IgnoreWinControls">
<short>
<b>True</b> if TWinControl descendants are ignored in the method.
</short>
</element>

<element name="TControl.FontChanged">
<short>
Handles changes to the Font property.
</short>
<descr>
<p>
<var>FontChanged</var> is a procedure used to perform actions needed when the 
value in the <var>Font</var> property has been changed for the control. 
FontChanged ensures that values in <var>ParentFont</var> and 
<var>DesktopFont</var> are set to <b>False</b> to reflect the font assignment.
</p>
<p>
FontChanged calls the <var>Invalidate</var> method to force the control to be 
redrawn when it is Visible. The CM_FONTCHANGED control change message is 
performed to reflect the change in the control state. When 
<var>AutoSize</var> contains <b>True</b>, the 
<var>InvalidatePreferredSize</var> and <var>AdjustSize</var> methods are 
called to update the control dimensions using the new font.
</p>
<p>
FontChanged is assigned to the <var>OnChange</var> event handler for the 
<var>Font</var> property in the constructor for the class instance.
</p>
</descr>
<seealso>
<link id="TControl.Font"/>
<link id="TControl.ParentFont"/>
<link id="TControl.DesktopFont"/>
<link id="TControl.Invalidate"/>
<link id="TControl.InvalidatePreferredSize"/>
<link id="TControl.AdjustSize"/>
<link id="TControl.IsVisible"/>
<link id="TControl.AutoSize"/>
<link id="TControl.Perform"/>
</seealso>
</element>
<element name="TControl.FontChanged.Sender">
<short>Class instance generating the change notification.</short>
</element>

<element name="TControl.ParentFontChanged">
<short>
[Delphi compatible] Does nothing here, all work is done in 
CMParentFontChanged.
</short>
<descr/>
<seealso>
<link id="TControl.CMParentFontChanged"/>
</seealso>
</element>

<element name="TControl.GetAction">
<short>Gets the value for the Action property.</short>
<descr>
<p>
The property value is retrieved from ActionLink (when assigned). Otherwise, 
the property value is <b>Nil</b>.
</p>
</descr>
<seealso>
<link id="TControl.Action"/>
</seealso>
</element>
<element name="TControl.GetAction.Result">
<short>Value for the Action property.</short>
</element>

<element name="TControl.RealGetText">
<short>Returns the Caption property.</short>
<descr>
<p>
This method is called by <var>GetText</var>, when GetTextBuf has not been 
overridden.
</p>
</descr>
<seealso>
<link id="TControl.GetTextBuf"/>
<link id="TControl.RealSetText"/>
<link id="TControl.SetTextBuf"/>
</seealso>
</element>
<element name="TControl.RealGetText.Result">
<short>Value for the Caption property.</short>
</element>

<element name="TControl.RealSetText">
<short>Sets the value for the Caption property.</short>
<descr>
<p>
RealSetText is a method used to apply the TCaption value in AValue to the 
text or caption for the control. RealSetText is called by the private 
<var>SetText</var> method, when <var>SetTextBuf</var> has not been overridden.
</p>
<p>
<b>Notes on TControl.Caption, TControl.Text, et. al.</b>
</p>
<p>
The Delphi VCL implementation relies on the virtual GetTextBuf and SetTextBuf 
methods to exchange text for controls.. This requires a lot of (unnecessary) 
copies to move values between Text and Caption.
</p>
<p>
The LCL uses strings to exchange text values because it is more efficient. To 
maintain VCL compatibility, the virtual RealGetText and RealSetText methods 
were introduced. These functions use the LCLInterface. The default GetTextBuf 
and SetTextBuf implementations calls the RealGetText and RealSetText methods 
as needed. As long as the GetTextBuf and/or SetTextBuf aren't overridden, 
GetText and SetText call RealGetText and RealSetText to avoid copying PChar 
values.
</p>
<p>
To keep things optimal, LCL implementations should always override 
RealGetText and RealSetText. GetTextBuf and SetTextBuf are only kept for 
compatibility with Delphi code.
</p>
</descr>
<seealso>
<link id="TControl.Caption"/>
<link id="TControl.Text"/>
<link id="TControl.RealGetText"/>
<link id="TControl.SetTextBuf"/>
<link id="TControl.GetTextBuf"/>
</seealso>
</element>
<element name="TControl.RealSetText.Value">
<short>The string value to store in the Text / Caption properties.</short>
</element>

<element name="TControl.TextChanged">
<short>
Performs actions needed when the value for the Text property has been changed.
</short>
<descr>
<p>
TextChanged has an empty implementation in TControl, and is overridden in 
descendent classes to perform any actions needed for the control type. Called 
from the CMTextChanged message handler.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.GetCachedText">
<short>Returns the cached Text property (FCaption).</short>
<descr/>
<seealso/>
</element>
<element name="TControl.GetCachedText.Result">
<short><b>True</b> if successful.</short>
</element>
<element name="TControl.GetCachedText.CachedText">
<short>Here: FCaption (can be overridden).</short>
</element>

<element name="TControl.SetAction">
<short>Sets the value for the Action property.</short>
<descr>
<p>
Ensures that ActionLink is updated when the value for the property is 
updated.
</p>
<p>
When Value is unassigned (Nil), ActionLink is freed and set to <b>Nil</b>. 
The control style flags are also updated to remove the value csActionClient. 
Otherwise, a new ActionLink class instance is created for ActionLink and 
Value is assigned to its Action property. Its OnChange handler is assigned, 
and the ActionChange method is called to apply values from the action to the 
control.
</p>
</descr>
<seealso>
<link id="TControl.Action"/>
</seealso>
</element>
<element name="TControl.SetAction.Value">
<short>New value for the Action property.</short>
</element>

<element name="TControl.SetColor">
<short>Sets the value for the Color property.</short>
<descr>
<p>
SetColor is a method used to set the value for the Color property to the 
specified TColor value. Assigning a value to Color causes the ParentColor 
property to be set to <b>False</b>.
</p>
<p>
SetColor calls Perform to send a CM_COLORCHANGED control message to the 
widgetset class. Invalidate is called to force the control to be redrawn.
</p>
</descr>
<seealso>
<link id="TControl.Color"/>
</seealso>
</element>
<element name="TControl.SetColor.Value">
<short>New value for the Color property.</short>
</element>

<element name="TControl.SetEnabled">
<short>Sets the value for the Enabled property.</short>
<descr>
<p>
Calls EnabledChanging to notify handlers for the chtOnEnabledChanged type. 
Stores the new value for the property, and performs a CM_ENABLEDCHANGED 
control message. Calls EnabledChanged to notify handlers for the 
chtOnEnabledChanged type.
</p>
</descr>
<seealso>
<link id="TControl.Enabled"/>
</seealso>
</element>
<element name="TControl.SetEnabled.Value">
<short>New value for the Enabled property.</short>
</element>

<element name="TControl.SetHint">
<short>Sets the value for the Hint property.</short>
<descr>
<p>
Value is a TTranslateString type which allows it be recognized and processed 
in the LCL translation facilities.
</p>
</descr>
<seealso>
<link id="TControl.Hint"/>
</seealso>
</element>
<element name="TControl.SetHint.Value">
<short>New value for the Hint property.</short>
</element>

<element name="TControl.SetName">
<short>Sets the value for the Name property.</short>
<descr/>
<seealso>
<link id="#rtl.classes.TComponent.Name">TComponent.Name</link>
</seealso>
</element>
<element name="TControl.SetName.Value">
<short>New value for the Name property.</short>
</element>

<element name="TControl.SetParent">
<short>Sets the value for the Parent property.</short>
<descr/>
<seealso>
<link id="TControl.Parent"/>
</seealso>
</element>
<element name="TControl.SetParent.NewParent">
<short>New value for the Parent property.</short>
</element>

<element name="TControl.SetParentBackground">
<short>
Sets the value for the ParentBackground property.
</short>
<descr/>
<seealso>
<link id="TControl.ParentBackground"/>
</seealso>
</element>
<element name="TControl.SetParentBackground.AParentBackground">
<short>
New value for the ParentBackground property.
</short>
</element>

<element name="TControl.SetParentComponent">
<short>
Sets the value in the Parent property when the new parent component is a 
TWinControl instance.
</short>
<descr>
<p>
Implements the dynamic method inherited from TComponent. When 
NewParentComponent is derived from TWinControl, the SetParent method is 
called to re-parent, position, and resize the control.
</p>
</descr>
<seealso>
<link id="TControl.SetParent"/>
<link id="TControl.Parent"/>
<link id="#rtl.classes.TComponent.GetParentComponent">TComponent.GetParentComponent</link>
</seealso>
</element>
<element name="TControl.SetParentComponent.NewParentComponent">
<short>New TWinControl instance used as the Parent for the control.</short>
</element>

<element name="TControl.ParentFormHandleInitialized">
<short>Internal handler for activities after a form widget has been created.
</short>
<descr>
<p>
Called by <var>ChildHandlesCreated</var> of parent form.
</p>
<p>
Functions like GetTextWidth require a valid widget and a device context.
That is why AutoSizing is delayed until the handle in a parent Form is 
allocated.
</p>
</descr>
</element>

<element name="TControl.GetMouseCapture">
<short>Gets the value for the MouseCapture property.</short>
<descr>
<p>
Indicates if the class instance is the current CaptureControl for the LCL 
framework.
The property value is <b>True</b> when the following condition are satisfied:
</p>
<ul>
<li>
Parent is assigned (not <b>Nil</b>).
</li>
<li>
Parent has an allocated window handle.
</li>
<li>
The value in the LCL CaptureContol variable is the current class instance.
</li>
</ul>
</descr>
<seealso>
<link id="TControl.MouseCapture"/>
<link id="GetCaptureControl"/>
</seealso>
</element>
<element name="TControl.GetMouseCapture.Result">
<short>
<b>True</b> when the current class instance is the LCL CaptureControl.
</short>
</element>

<element name="TControl.CaptureChanged">
<short>Handler for mouse capture moved to a different control.</short>
<descr>
<p>
Notifies the DragManager of a change to the capture control, and to stop 
dragging this control. A very dangerous implementation; it can cause an 
immediate abort of dragging before dragging really starts.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.Notification">
<short>
Notification handler for insertion or deletion of components.
</short>
<descr>
<p>
First, the inherited <var>TComponent.Notification</var> is called to notify 
all attached notification handlers.
</p>
<p>
If <var>Operation</var> is <var>opRemove</var>, additional actions are 
performed, depending on <var>AComponent</var>: the PopupMenu, Action, or 
anchors for the removed control are detached.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TComponent.Notification">TComponent.Notification</link>
</seealso>
</element>
<element name="TControl.Notification.AComponent">
<short>The component being inserted or removed.</short>
</element>
<element name="TControl.Notification.Operation">
<short>The action (opInsert or opRemove).</short>
</element>

<element name="TControl.CanTab">
<short>
Determines whether the Tab key can be used for navigation in the control.
</short>
<descr>
<p>
Always returns <b>False</b> in TControl. Overridden in TWinControl.
</p>
</descr>
<seealso>
<link id="TWinControl.CanTab"/>
</seealso>
</element>
<element name="TControl.CanTab.Result">
<short>
Always returns <b>False</b> in TControl.
</short>
</element>

<element name="TControl.GetDeviceContext">
<short>Returns a device context handle for the control, from Parent.
</short>
<descr>
<p>
Initializes the device context position to the control origin, and shrinks 
its clipping rectangle to the bounds for the control.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.GetDeviceContext.Result">
<short>The device context.</short>
</element>
<element name="TControl.GetDeviceContext.WindowHandle">
<short>Returns the window handle of the device context.</short>
</element>

<element name="TControl.GetEnabled">
<short>Gets the value for the Enabled property.</short>
<descr/>
<seealso>
<link id="TControl.Enabled"/>
</seealso>
</element>
<element name="TControl.GetEnabled.Result">
<short>Value for the Enabled property.</short>
</element>

<element name="TControl.GetPopupMenu">
<short>Gets the value for the PopupMenu property.</short>
<descr/>
<seealso>
<link id="TControl.PopupMenu"/>
</seealso>
</element>
<element name="TControl.GetPopupMenu.Result">
<short>Value for the PopupMenu property.</short>
</element>

<element name="TControl.DoOnShowHint">
<short>Signals the <var>OnShowHint</var> event handler.</short>
<descr>
<p>
Called when the CM_HINTSHOW message is handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.OnShowHint"/>
<link id="TControl.CMHintShow"/>
<link id="PHintInfo"/>
<link id="THintInfo"/>
</seealso>
</element>
<element name="TControl.DoOnShowHint.HintInfo">
<short>
Pointer to the structure with the position, width, color, and hint text for 
the event handler.
</short>
</element>

<element name="TControl.DoMouseWheel">
<short>
Signals the OnMouseWheel handlers, when the mouse wheel has been turned.
</short>
<descr>
<p>
Multiple wheel handlers can be implemented. First the general OnMouseWheel 
handler is tried, and if it doesn't report the event handled, then 
OnMouseWheelUp or OnMouseWheelDown are tried.
</p>
<p>
The actual WheelDelta is available <b>only</b> to the OnMouseWheel handler, 
not to the up and down handlers [Delphi compatible].
</p>
</descr>
<seealso>
<link id="TMouseWheelEvent"/>
<link id="TMouseWheelUpDownEvent"/>
</seealso>
</element>
<element name="TControl.DoMouseWheel.Result">
<short>Set Result to <b>True</b> if handled.</short>
</element>
<element name="TControl.DoMouseWheel.Shift">
<short>State of the modifier keys and mouse buttons.</short>
</element>
<element name="TControl.DoMouseWheel.WheelDelta">
<short>How many notches the wheel has been turned.</short>
</element>
<element name="TControl.DoMouseWheel.MousePos">
<short>The mouse coordinates.</short>
</element>

<element name="TControl.DoMouseWheelDown">
<short>
Signals the OnMouseWheelDown handler.
</short>
</element>
<element name="TControl.DoMouseWheelDown.Result">
<short>
<b>True</b> if the mouse wheel message is handled.
</short>
</element>
<element name="TControl.DoMouseWheelDown.Shift">
<short>
Shift, Ctrl or Alt modifier for the mouse wheel event notification.
</short>
</element>
<element name="TControl.DoMouseWheelDown.MousePos">
<short>
Location for the mouse pointer when the wheel event was generated.
</short>
</element>

<element name="TControl.DoMouseWheelUp">
<short>
Signals the OnMouseWheelUp handler.
</short>
</element>
<element name="TControl.DoMouseWheelUp.Result">
<short><b>True</b> if handled.</short>
</element>
<element name="TControl.DoMouseWheelUp.Shift" link="#lcl.controls.TMouseWheelEvent.Shift"/>
<element name="TControl.DoMouseWheelUp.MousePos" link="#lcl.controls.TMouseWheelEvent.MousePos"/>

<element name="TControl.DoMouseWheelHorz">
<short>
Performs actions needed to handle horizontal mouse wheel events.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.DoMouseWheelHorz.Result">
<short>
<b>True</b> when the mouse wheel event has been handled for the control.
</short>
</element>
<element name="TControl.DoMouseWheelHorz.Shift">
<short>Shift state for the mouse wheel event.</short>
</element>
<element name="TControl.DoMouseWheelHorz.WheelDelta">
<short>Number of units (or clicks) the mouse wheel was moved.</short>
</element>
<element name="TControl.DoMouseWheelHorz.MousePos">
<short>TPoint with the mouse coordinates for the event.</short>
</element>

<element name="TControl.DoMouseWheelLeft">
<short>
Signals the OnMouseWheelLeft event handler (when assigned).
</short>
<descr>
<p>
<var>DoMouseWheelLeft</var> is a <var>Boolean</var> function used to perform 
actions when a horizontal mouse wheel movement towards the left has occurred 
in the control. It is called, via DoMouseWheelHorz, when a LM_MOUSEHWHEEL 
message is received and handled in the WMMouseHWheel method.
</p>
<p>
DoMouseWheelLeft signals the OnMouseWheelLeft event handler when it has been 
assigned in the control. Shift and MousePos contain the shift modifier and 
the coordinates where the mouse event occurred. They are passed as arguments 
to the event handler.
</p>
<p>
The return value indicates whether the event handler accepted and processed 
the mouse wheel event at the specified position. The default value is 
<b>False</b>, but it can be updated in the handler routine. The return value 
is <b>False</b> if OnMouseWheelLeft has not been assigned.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheelLeft"/>
<link id="TControl.DoMouseWheelHorz"/>
<link id="TControl.DoMouseWheelRight"/>
<link id="TControl.WMMouseHWheel"/>
</seealso>
</element>
<element name="TControl.DoMouseWheelLeft.Result">
<short>
<b>True</b> if the mouse wheel event was handled in the OnMouseWheelLeft 
event handler.
</short>
</element>
<element name="TControl.DoMouseWheelLeft.Shift">
<short>
Shift, Ctrl, or Alt modifier for the mouse wheel event.
</short>
</element>
<element name="TControl.DoMouseWheelLeft.MousePos">
<short>
TPoint instance with the coordinates where the mouse wheel event was detected.
</short>
</element>

<element name="TControl.DoMouseWheelRight">
<short>
Signals the OnMouseWheelRight event handler.
</short>
<descr>
<p>
<var>DoMouseWheelRight</var> is a <var>Boolean</var> function used to perform 
actions when a horizontal mouse wheel movement towards the right has occurred 
in the control. It is called, via DoMouseWheelHorz, when a LM_MOUSEHWHEEL 
message is received and handled in the WMMouseHWheel method.
</p>
<p>
DoMouseWheelRight signals the OnMouseWheelRight event handler when it has 
been assigned in the control. Shift and MousePos contain the shift modifier 
and the coordinates where the mouse event occurred. They are passed as 
arguments to the event handler.
</p>
<p>
The return value indicates whether the event handler accepted and processed 
the mouse wheel event at the specified position. The default value is 
<b>False</b>, but it can be updated in the handler routine. The return value 
is <b>False</b> if OnMouseWheelRight has not been assigned.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheelRight"/>
<link id="TControl.DoMouseWheelHorz"/>
<link id="TControl.DoMouseWheelLeft"/>
<link id="TControl.WMMouseHWheel"/>
</seealso>
</element>
<element name="TControl.DoMouseWheelRight.Result">
<short>
<b>True</b> if the mouse wheel event was handled in the OnMouseWheelRight 
event handler.
</short>
</element>
<element name="TControl.DoMouseWheelRight.Shift">
<short>
Shift, Ctrl, or Alt modifier for the mouse wheel event.
</short>
</element>
<element name="TControl.DoMouseWheelRight.MousePos">
<short>
TPoint instance with the coordinates where the mouse wheel event was detected.
</short>
</element>

<element name="TControl.VisibleChanging">
<short>
Notifies all chtOnVisibleChanging handlers for the control.
</short>
<descr>
<p>
<var>VisibleChanging</var> is called when a new value is assigned to the 
<var>Visible</var> property. It occurs before the new property value is 
stored to its member in the class instance. It allows all of the 
<var>TNotifyEvent</var> routines registered for the 
<var>chtOnVisibleChanging</var> control handler type to be signalled prior to 
the change in the property value.
</p>
<p>
VisibleChanging calls the DoCallNotifyHandler method to signal each of the 
handler routines using the chtOnVisibleChanging control handler type. The 
class instance is used as the Sender argument for the event notification.
</p>
<p>
Use AddHandlerOnVisibleChanging and RemoveHandlerOnVisibleChanging to manage 
the TNotifyEvent handler routines for the chtOnVisibleChanging handler type 
used in the control.
</p>
<p>
See VisibleChanged for the actions performed after the value in Visible has 
been updated.
</p>
</descr>
<seealso>
<link id="TControl.Visible"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControl.AddHandlerOnVisibleChanging"/>
<link id="TControl.RemoveHandlerOnVisibleChanging"/>
<link id="TControl.VisibleChanged"/>
<link id="TControlHandlerType"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.VisibleChanged">
<short>
Notifies all chtOnVisibleChanged handlers for the control.
</short>
<descr>
<p>
<var>VisibleChanged</var> is called when a new value has been assigned to the 
<var>Visible</var> property. It occurs after the new property value is stored 
to its member in the class instance. It allows all of the 
<var>TNotifyEvent</var> routines registered for the 
<var>chtOnVisibleChanged</var> control handler type to be signalled for the 
new property value.
</p>
<p>
VisibleChanged calls the DoCallNotifyHandler method to signal each of the 
handler routines using the chtOnVisibleChanged control handler type. The 
class instance is used as the Sender argument for the event notification.
</p>
<p>
Use AddHandlerOnVisibleChanged and RemoveHandlerOnVisibleChanged to manage 
the TNotifyEvent handler routines for the chtOnVisibleChanged handler type 
used in the control.
</p>
<p>
See VisibleChanging for the actions performed before the value in Visible is 
updated.
</p>
</descr>
<seealso>
<link id="TControl.Visible"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControl.AddHandlerOnVisibleChanged"/>
<link id="TControl.RemoveHandlerOnVisibleChanged"/>
<link id="TControl.VisibleChanging"/>
<link id="TControlHandlerType"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.EnabledChanging">
<short>
Notifies all chtOnEnabledChanging handlers for the control.
</short>
<descr>
<p>
<var>EnabledChanging</var> is called when a new value has been assigned to 
the Enabled property. It occurs after the new property value is stored to its 
member, and before a CM_ENABLEDCHANGED control message is posted for the 
control. It allows all of the <var>TNotifyEvent</var> routines registered for 
the <var>chtOnEnabledChanging</var> control handler type to be signalled for 
the new property value.
</p>
<p>
EnabledChanging calls the <var>DoCallNotifyHandler</var> method to signal 
each of the handler routines using the chtOnEnabledChanging control handler 
type. The class instance is used as the Sender argument for the event 
notification.
</p>
<p>
Use RemoveHandlerOnEnabledChanging to manage the TNotifyEvent handler 
routines for the handler type used in the control. AddHandler and 
RemoveHandler can be used if the control handler type is passed as an 
argument.
</p>
<p>
See EnabledChanged for the actions performed after the value in Enabled is 
updated.
</p>
</descr>
<seealso>
<link id="TControl.Enabled"/>
<link id="TControl.EnabledChanged"/>
<link id="TControl.Perform"/>
<link id="TControl.DoCallNotifyHandler"/>
<!-- <link id="TControl.RemoveHandlerOnEnabledChanging"/> -->
<link id="TControlHandlerType"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.EnabledChanged">
<short>
Notifies all chtOnEnabledChanged handlers for the control.
</short>
<descr>
<p>
<var>EnabledChanged</var> is called when a new value has been assigned to 
the Enabled property. It occurs after the EnabledChanging method has been 
called, and the CM_ENABLEDCHANGED control message has been sent for the 
control. It allows all of the <var>TNotifyEvent</var> routines registered for 
the <var>chtOnEnabledChanged</var> control handler type to be signalled for 
the new property value.
</p>
<p>
EnabledChanged calls the <var>DoCallNotifyHandler</var> method to signal 
each of the handler routines using the chtOnEnabledChanged control handler 
type. The class instance is used as the Sender argument for the event 
notification.
</p>
<p>
Use AddHandlerOnEnabledChanged and RemoveHandlerOnEnabledChanged to manage 
the TNotifyEvent handler routines for the handler type used in the control. 
AddHandler and RemoveHandler can be used if the control handler type is 
passed as an argument.
</p>
<p>
See EnabledChanging for the actions performed before the value in Enabled 
is updated in its widgetset class instance.
</p>
</descr>
<seealso>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControlHandlerType"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.AddHandler">
<short>
Adds a notification handler for the specified control handler type.
</short>
<descr>
<p>
<var>AddHandler</var> is a method used to include the handler routine 
specified in <var>AMethod</var> in the list of notification handlers for the 
type in <var>HandlerType</var>.
</p>
<p>
<var>HandlerType</var> is a <var>TControlHandlerType</var> enumeration value, 
and indicates both the subject for the notification and the method list where 
the handler routine is stored.
</p>
<p>
<var>AMethod</var> is the <var>TMethod</var> instance with the handler 
routine signalled when a notification is needed. It is an object procedure 
which implements the <var>TNotifyEvent</var> signature and cast to the 
<var>TMethod</var> type.
</p>
<p>
AddHandler ensures that a <var>TMethodList</var> instance has been allocated 
for handler routines using the specified type; if it does not exist, it is 
created and stored in the internal array of handler types.
</p>
<p>
AddHandler calls the Add method in the method list to store the routine in 
AMethod.
</p>
<p>
<var>AsFirst</var> indicates whether the routine is inserted as the first 
item in the list. When set to False, the routine is appended as the last 
entry in the method list.
</p>
<p>
Use RemoveHandler to remove a handler routine from the method list for a 
specific handler type.
</p>
<p>
Convenience methods which act upon a specific control handler type using 
TNotifyEvent arguments are also available. For example:
</p>
<ul>
<li>AddHandlerOnResize</li>
<li>AddHandlerOnChangeBounds</li>
<li>AddHandlerOnVisibleChanged</li>
<li>and others</li>
</ul>
</descr>
<seealso>
<link id="TControl.RemoveHandler"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControlHandlerType"/>
<link id="#lazutils.lazmethodlist.TMethodList">TMethodList</link>
<link id="#rtl.system.TMethod">TMethod</link>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>
<element name="TControl.AddHandler.HandlerType">
<short>
Control handler type of the handler routine.</short>
</element>
<element name="TControl.AddHandler.AMethod">
<short>
The handler routine added in the method.
</short>
</element>
<element name="TControl.AddHandler.AsFirst">
<short>
True if the handler routine is signalled first in the notification order.
</short>
</element>

<element name="TControl.RemoveHandler">
<short>
Removes a notification handler from the list for the specified handler type.
</short>
<descr>
<p>
<var>RemoveHandler</var> is a method used to remove the specified handler 
routine from the method list for a given control handler type. It removes an 
entry in the method list created using the AddHandler method.
</p>
<p>
<var>HandlerType</var> is a value from the <var>TControlHandlerType</var> 
enumeration that identifies the method list updated in the method. It is an 
index into the internal array of TMethodList instances used to store handler 
routines.
</p>
<p>
<var>AMethod</var> is the <var>TMethod</var> instance to locate and remove 
from the method list for the handler type. It is a reference to a 
<var>TNotifyEvent</var> implementation cast to the TMethod type used in the 
method list.
</p>
<p>
RemoveHandler calls the Remove method in the TMethodList instance using 
AMethod as an argument.
</p>
<p>
Convenience methods are provided that manage a method list for a single 
control type handler. For example:
</p>
<ul>
<li>RemoveHandlerOnResize</li>
<li>RemoveHandlerOnChangeBounds</li>
<li>RemoveHandlerOnVisibleChanging</li>
<li>and others</li>
</ul>
</descr>
<seealso>
<link id="TControl.AddHandler"/>
<link id="TControlHandlerType"/>
<link id="#lazutils.lazmethodlist.TMethodList">TMethodList</link>
<link id="#rtl.system.TMethod">TMethod</link>
</seealso>
</element>
<element name="TControl.RemoveHandler.HandlerType">
<short>
Control handler type for the routine removed in the method.
</short>
</element>
<element name="TControl.RemoveHandler.AMethod">
<short>
The handler routine removed from the list of handlers for the specified type.
</short>
</element>

<element name="TControl.DoCallNotifyHandler">
<short>
Signals handler routines for the specified control handler type.
</short>
<descr>
<p>
<var>DoCallNotifyHandler</var> is a method used to signal control handler 
routines which were added for the specified <var>HandlerType</var>.
</p>
<p>
<var>HandlerType</var> is a value form the <var>TControlHandlerType</var> 
enumeration which identifies the list with the routines signalled in the 
method.
</p>
<p>
A control handler routine is a reference to a <var>TNotifyEvent</var> 
implementation. In TControl, multiple handler routines can be added for a 
given handler type. DoCallNotifyHandler ensures that each of the routines is 
signalled using the control instance as the Sender or origin for the 
notification.
</p>
<p>
DoCallNotifyHandler uses the value in HandlerType to select the 
<var>TMethodList</var> with the handler routines. The 
<var>CallNotifyEvents</var> method in the TMethodList instance is called to 
perform the event notification.
</p>
<p>
DoCallNotifyHandler is called from methods which perform event notifications 
using both a published event handler property and a list of control handlers. 
For example: DoOnResize and DoOnChangeBounds. These methods signal the event 
handlers represented by the OnResize and OnChangeBounds properties. They also 
use DoCallNotifyHandler for their control handler types (chtOnResize and 
chtOnChangeBounds) to signal the additional handlers added to the control.
</p>
<p>
DoCallNotifyHandler is also called from methods which do not have a published 
event handler property, but may have control handlers added at run-time. For 
example: VisibleChanging and EnabledChanged.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.DoCallNotifyHandler.HandlerType">
<short>
Identifies the handler type for the routines signalled in the method.
</short>
</element>

<element name="TControl.DoCallKeyEventHandler">
<short>
Passes key events for the specified type to the handlers added to the control.
</short>
<descr>
<p>
DoCallKeyEventHandler iterates over the handler routines using the type 
specified in HandlerType. The routines are cast to the TKeyEvent type used to 
implement the handler and receives the arguments specified in Key and Shift. 
The current class instance is used as the Sender for the event notification.
</p>
<p>
DoCallKeyEventHandler is called from the KeyDown method in descendent classes 
like TWinControl.
</p>
</descr>
<seealso>
<link id="TWinControl.KeyDown"/>
<link id="TControlHandlerType"/>
<link id="TKeyEvent"/>
<link id="#rtl.classes.TShiftState">TShiftState</link>
</seealso>
</element>
<element name="TControl.DoCallKeyEventHandler.HandlerType">
<short>
Type for the handler, like OnKeyDown.
</short>
</element>
<element name="TControl.DoCallKeyEventHandler.Key">
<short>Key code for the key event notification.</short>
</element>
<element name="TControl.DoCallKeyEventHandler.Shift">
<short>
Shift, Ctrl, or Alt modifier for the key event notification.
</short>
</element>

<element name="TControl.DoCallMouseWheelEventHandler">
<short>
Executes assigned mouse wheel events until a handler is found for the event 
notifications.
</short>
<descr>
<p>
DoCallMouseWheelEventHandler iterates over the handler routines using the 
type specified in HandlerType. The routines are cast to the TMouseWheelEvent 
type used to implement the handler and receives the arguments specified in 
Shift, WheelDelta, MousePos, and Handled. Iteration is halted when an event 
handler returns <b>True</b> in the Handled argument, or when all handlers for 
the type have been signalled.
</p>
<p>
The current class instance is used as the Sender for each of the event 
notifications.
</p>
<p>
DoCallMouseWheelEventHandler is called from methods like DoMouseWheel and 
DoMouseWheelHorz.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.DoCallMouseWheelEventHandler.HandlerType">
<short>
Type for the handlers signalled in the method.
</short>
</element>
<element name="TControl.DoCallMouseWheelEventHandler.Shift">
<short>
Shift, Ctrl, or Alt modifier for the mouse wheel event notification.
</short>
</element>
<element name="TControl.DoCallMouseWheelEventHandler.WheelDelta">
<short>
Number of relative units that the mouse wheel was moved. Negative values 
indicate a move wheel up or left direction.
</short>
</element>
<element name="TControl.DoCallMouseWheelEventHandler.MousePos">
<short>
Position of the mouse pointer when the wheel event occurred.
</short>
</element>
<element name="TControl.DoCallMouseWheelEventHandler.Handled">
<short>
Set to <b>True</b> in a handler routine if the control handles the event 
notification.
</short>
</element>

<element name="TControl.DoContextPopup">
<short>Signals the OnContextPopup handler.</short>
<descr>
<p>
<var>DoContextPopup</var> is a method used to signal the OnContextPopup event 
handler (when assigned). The control instance is used as the Sender argument. 
Values in MousePos and Handled are also passed as parameters to the event 
handler. Handled should be set to <b>True</b> in the handler routine if the 
context pop-up was displayed and a menu item was executed.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.DoContextPopup.MousePos">
<short>
TPoint instance with the Mouse position, used to place the menu.
</short>
</element>
<element name="TControl.DoContextPopup.Handled">
<short>
Set to <b>True</b> in the event handler if the menu display and selection was 
handled for the control.
</short>
</element>

<element name="TControl.SetZOrder">
<short>
Moves the control in front of or behind all sibling controls.
</short>
<descr>
<p>
<var>SetZOrder</var> calls the SetChildZPosition method in the Parent control 
to change the Z-Order for the control instance. TopMost indicates whether the 
control is moved to the top or bottom of the Z-Order.
</p>
<p>
No actions are performed in the method when Parent has not been assigned.
</p>
<p>
SetZOrder is used to implement the BringToFront and SendToBack methods. It 
may be overridden is descendent classes to perform actions needed for the 
derived controls. See 
<link id="#lcl.forms.TCustomForm.SetZOrder">TCustomForm.SetZOrder</link>.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TWinControl.SetChildZPosition"/>
<link id="#lcl.forms.TCustomForm.SetZOrder">TCustomForm.SetZOrder</link>
</seealso>
</element>
<element name="TControl.SetZOrder.TopMost">
<short>
<b>True</b> to move the control in front of other sibling controls. 
<b>False</b> to move the control behind other siblings.
</short>
</element>

<element name="TControl.GetControlClassDefaultSize">
<short>
Returns the default dimensions for new instances of the class.
</short>
<descr>
<p>
The CX member is set to 75 (pixels).
The CY member is set to 50 (pixels).
</p>
</descr>
</element>
<element name="TControl.GetControlClassDefaultSize.Result">
<short>
TSize instance with the Width and Height for a new instance of the control 
class.
</short>
</element>

<element name="TControl.ColorIsStored">
<short>Implements the storage specifier for the Color property.</short>
<descr/>
<seealso>
<link id="TControl.Color"/>
<link id="TControl.ParentColor"/>
</seealso>
</element>
<element name="TControl.ColorIsStored.Result">
<short>
<b>True</b> when ParentColor is not enabled for the control.
</short>
</element>

<element name="TControl.DoAutoAdjustLayout">
<short>
Applies layout changes using the specified policy and scaling proportions to 
the control.
</short>
<descr>
<p>
<var>DoAutoAdjustLayout</var> is a method which implements changes to control 
sizes for the AutoAdjustLayout method. These methods are called when High-DPI 
and scaling have been enabled in the project options for an application.
</p>
<p>
<var>AMode</var> indicates the automatic layout policy applied in the method. 
It is a value from the TLayoutAdjustmentPolicy enumeration, and determines 
whether horizontal / vertical / or both sizes are adjusted in the method. It 
generally reflects the constraints for the device type where the application 
is running.
</p>
<p>
<var>AXProportion</var> and <var>AYProportion</var> contain the scaling 
factors applied to the horizontal and/or vertical sizes.
</p>
<p>
DoAutoAdjustLayout ensures that new values for Height and Width in the 
control are calculated (when allowed and needed) using the scaling factors, 
Constraints, BorderSpacing and Anchors for the control. The SetBoundsKeepBase 
method is called to apply the newly calculated values to the control.
</p>
<p>
Font scaling is performed in AutoAdjustLayout (when needed) and occurs prior 
to calling DoAutoAdjustLayout.
</p>
<p>
DoAutoAdjustLayout, ScaleFontsPPI, and FixDesignFontsPPI are often overridden 
in descendent classes to perform additional actions needed for a control or 
its children.
</p>
</descr>
<seealso>
<link id="TControl.AutoAdjustLayout"/>
<link id="TControl.ShouldAutoAdjust"/>
<link id="TControl.Anchors"/>
<link id="TControl.BorderSpacing"/>
<link id="TControl.Constraints"/>
<link id="TControl.SetBoundsKeepBase"/>
</seealso>
</element>
<element name="TControl.DoAutoAdjustLayout.AMode">
<short>Identifies the auto-layout policy applied in the method.</short>
</element>
<element name="TControl.DoAutoAdjustLayout.AXProportion">
<short>Scaling factor for horizontal dimensions.</short>
</element>
<element name="TControl.DoAutoAdjustLayout.AYProportion">
<short>Scaling factor for vertical dimensions.</short>
</element>

<element name="TControl.DoFixDesignFontPPI">
<short>
Applies the design-time PPI and resizes the specified control font.
</short>
<descr>
<p>
Implements the FixDesignFontsPPI method for the control.
</p>
<p>
Performs actions needed to restore the design-time PPI (Pixels Per Inch) for 
controls when they are loaded using the LCL component streaming mechanism. 
The design-time PPI for fonts is not stored in .LFM files, and could result 
in invalid scaling operations when loaded on a machine with a different 
display density. DoFixDesignFontPPI ensures that the font is resized to the 
specified design-time PPI.
</p>
</descr>
<seealso>
<link id="TControl.FixDesignFontsPPI"/>
</seealso>
</element>
<element name="TControl.DoFixDesignFontPPI.AFont">
<short>
TFont instance updated in the method.
</short>
</element>
<element name="TControl.DoFixDesignFontPPI.ADesignTimePPI">
<short>
Design-time display density to which the font height is adjusted.
</short>
</element>

<element name="TControl.DoScaleFontPPI">
<short>
Implements the ScaleFontsPPI method for the control.
</short>
<descr>
<p>
Adjusts the height for a given Font to the specified pixels per inch (PPI).
</p>
</descr>
<seealso>
<link id="TControl.ScaleFontsPPI"/>
</seealso>
</element>
<element name="TControl.DoScaleFontPPI.AFont">
<short>Font examined and updated in the method.</short>
</element>
<element name="TControl.DoScaleFontPPI.AToPPI">
<short>Pixels per inch setting adjusted in the method.</short>
</element>
<element name="TControl.DoScaleFontPPI.AProportion">
<short>Scaling factor a applied to the font.</short>
</element>

<element name="TControl.GetActionLinkClass">
<short>The default ActionLink class (TControlActionLink).</short>
<descr>Used when the control is linked to an Action.</descr>
<seealso>
<link id="TControlActionLink"/>
</seealso>
</element>
<element name="TControl.GetActionLinkClass.Result">
<short>
Returns the TControlActionLink type.
</short>
</element>

<element name="TControl.ActionChange">
<short>Handler for a changed Action.</short>
<descr>Several properties are copied from the new Action.</descr>
</element>
<element name="TControl.ActionChange.Sender">
<short>The changed Action.</short>
</element>
<element name="TControl.ActionChange.CheckDefaults">
<short>
When <b>True</b>, forces update of all properties. Otherwise only properties 
in default state are overwritten.
</short>
</element>

<element name="TControl.ActionLink">
<short>Link to the default Action associated with this control.</short>
</element>

<element name="TControl.DesktopFont">
<short>
Indicates if the desktop (system) font is used for the text displayed on this 
control.
</short>
<descr>
<p>
<var>DesktopFont</var> is a <var>Boolean</var> property which indicates 
whether the default desktop (or system) font is used to display the text on 
the control. The default value for the property is set to <b>True</b> in the 
Create constructor, and indicates that an explicit assignment has not been 
made to the Font property. When set to <b>True</b>, the System font in Screen 
is loaded into the Font property.
</p>
<p>
Changing the property value causes a CM_SYSFONTCHANGED message to be 
performed for the control. DesktopFont is set to <b>False</b> when an 
explicit TFont value is assigned to the Font property.
</p>
</descr>
<seealso>
<link id="TControl.Perform"/>
<link id="TControl.CMSysFontChanged"/>
<link id="#lcl.forms.TScreen.SystemFont">TScreen.SystemFont</link>
<link id="#lcl.forms.Screen">Screen</link>
</seealso>
</element>

<element name="TControl.DragCursor">
<short>The cursor shape shown during a drag operation.</short>
<descr>
<p>
The default value is crDrag. If the control cannot be dropped on a target, 
the cursor changes temporarily to crNoDrop.
</p>
</descr>
</element>

<element name="TControl.DragKind">
<short>
Indicates the action performed for a drag operation: drag-and-drop or drag-and-dock.
</short>
<descr>
<p>
Set to dkDrag for a drag-drop operation, or to dkDock for a drag-dock 
operation.
</p>
</descr>
<seealso>
<link id="TDragKind"/>
</seealso>
</element>

<element name="TControl.DragMode">
<short>
Determines how a drag operation is started for the control.
</short>
<descr>
<p>
<var>DragMode</var> is a <var>TDragMode</var> property which determines how a 
drag operation is started for the control.
</p>
<p>
dmManual is the default value, and indicates that drag operation must be 
started in code by calling the BeginDrag method.
</p>
<p>
dmAutomatic allows a drag operation to start when the mouse pointer is 
dragged over the control.
</p>
<p>
Use DragKind to specify whether the drag operation is a drag-and-drop or a 
drag-and-dock operation.
</p>
</descr>
<seealso>
<link id="TControl.BeginDrag"/>
<link id="TControl.DragKind"/>
<link id="TDragManager"/>
</seealso>
</element>

<element name="TControl.MouseCapture">
<short>
<b>True</b> when mouse messages are currently captured by this control.
</short>
<descr>
<p>
In normal operation, all mouse messages are sent to the control under the 
mouse pointer. Mouse messages also can be sent to a capturing control, e.g. 
when a control is dragged.
</p>
<p>
Applications should capture mouse events only for special purposes, and 
release the capture as soon as a the target position has been determined. 
Limited user feedback is possible while the mouse is captured, not all 
application controls will work properly so long.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.ParentBackground">
<short>
Indicates if the control uses the background color from its Parent control.
</short>
<descr>
<p>
<var>ParentBackground</var> is a <var>Boolean</var> property which indicates 
if the background color from the <var>Parent</var> control is used as the 
background color for the current control instance.
</p>
<p>
ParentBackground is <b>True</b> when <var>csParentBackground</var> is 
included in the <var>ControlStyle</var> property. Setting the value in 
ParentBackground causes ControlStyle to be updated to include or exclude the 
csParentBackground enumeration value; it is included when the property is set 
to <b>True</b>.
</p>
<p>
ParentBackground and ParentColor are updated when a new value is assigned to 
the Color property. The properties are set to <b>False</b> when an explicit 
color is assigned to the Color property.
</p>
</descr>
<seealso>
<link id="TControl.ParentColor"/>
<link id="TControl.Color"/>
<link id="TControl.ControlStyle"/>
<link id="TControl.Parent"/>
<link id="TControlStyleType"/>
<link id="TControlStyle"/>
</seealso>
</element>

<element name="TControl.ParentColor">
<short>
Use the Color from the Parent control, when enabled.
</short>
<descr>
<p>
<var>ParentColor</var> determines if the control should use the 
<var>Color</var> from the Parent control, when enabled. The default value is 
<b>True</b>.
</p>
<p>
When this property is <b>True</b>, all changes to the <var>Color</var> of the 
parent will also be applied to the Color of the control, ensuring that they 
both contain same value. If the Color of the control is changed by the 
application, then <var>ParentColor</var> will be automatically set to 
<b>False</b>.
</p>
<p>
Using <var>ParentColor</var> when the <var>Color</var> value is 
<var>clDefault</var> can cause problems in resolving the actual color value. 
To obtain the Color property of a control while taking into account clDefault 
and ParentColor, use the <var>GetColorResolvingParent</var> method. This 
method might return a non-RGB color, but will never return clDefault. To 
obtain a purely RGB result use the <var>GetRGBColorResolvingParent</var> 
method.
</p>
</descr>
<seealso>
<link id="TControl.Color"/>
<link id="TControl.GetColorResolvingParent"/>
<link id="TControl.GetRGBColorResolvingParent"/>
</seealso>
</element>

<element name="TControl.ParentFont">
<short>
Indicates if the Font from the Parent control is used in the control.
</short>
<descr>
<p>
While <var>ParentFont</var> is <b>True</b>, changes to the font in the Parent 
are also applied to the Font for the control. This synchronizes them, keeping 
them set to the same value. If the value in <var>Font</var> is changed by the 
application, then <var>ParentFont</var> will automatically be set to 
<b>False</b>.
</p>
<p>
The default value for ParentFont is <b>True</b>.
</p>
</descr>
<seealso>
<link id="TControl.Font"/>
<link id="TControl.Parent"/>
</seealso>
</element>

<element name="TControl.ParentShowHint">
<short>
If <b>True</b>, the value of ShowHint for the control will be the same as the 
one from the Parent. Default is <b>True</b>.
</short>
<descr>
<p>
While <var>ParentShowHint</var> is <b>True</b>, all changes to the 
<var>ShowHint</var> property of the parent will also be applied to the 
<var>ShowHint</var> property for the control. This synchronizes them, keeping 
them with the same value. If the <var>ShowHint</var> property for the control 
is changed by the application, then <var>ParentShowHint</var> will 
automatically be set to <b>False</b>.
</p>
</descr>
<seealso>
<link id="TControl.Hint"/>
<link id="TControl.ShowHint"/>
</seealso>
</element>

<element name="TControl.SessionProperties">
<short>
Delimited list of property or sub-component property names saved to and 
restored from an external storage mechanism.
</short>
<descr>
<p>
<var>SessionProperties</var> is a <var>String</var> property with the names 
of properties, in the class instance or its child Components. 
SessionProperties allows published property values to be saved to and 
restored from an external storage mechanism like: TIniPropStorage, 
TXMLPropStorage, or TJSONPropStorage.
</p>
<p>
Values in the property are delimited using the ';' (SemiColon) character. 
Component properties require both the component and property names using 
dotted notation like 'Image1.Visible'. In the TForm descendent class, the 
values can be assigned at design-time using a dialog in the Lazarus IDE, or 
by setting the property value at run-time.
</p>
<p>
In <var>TControl</var>, SessionProperties has protected visibility; it is 
elevated to published visibility in the TForm descendant.
</p>
</descr>
<seealso>
<link id="#lcl.forms.TForm.SessionProperties">TForm.SessionProperties</link>
</seealso>
</element>

<element name="TControl.Text">
<short>
String with the text or caption for the control.
</short>
<descr>
<p>
This is the character string, shown in controls with visible text content 
(<link id="#lcl.StdCtrls.TEdit">TEdit</link>...).
</p>
<remark>
BEWARE: In other controls it can be the Name or Caption of the control, quite 
tricky to use.
</remark>
<p>
The Delphi VCL implementation stores Text mostly in the widgets, using the 
virtual <var>Get/SetTextBuf</var> methods to exchange text between widgets 
and VCL. This means a lot of text copies and message handling in WM_GETTEXT 
and WM_SETTEXT.
</p>
<p>
The LCL instead (typically) stores Text in a field of the control, and 
transfers it from/to the widgets only when required.
</p>
<p>
To maintain VCL compatibility, the virtual <var>RealGet/SetText</var> methods 
have been introduced, which read or write the Caption string directly.
</p>
<p>
The default <var>Get/SetTextBuf</var> implementation calls the 
<var>RealGet/SetText</var> methods, resulting in a string-to-PCHAR and 
another PCHAR-to-string conversion. But as long as <var>Get/SetTextBuf</var> 
is not overridden, <var>Get/SetText</var> can (and does) safely call 
<var>RealGet/SetText</var> immediately, to avoid the mentioned conversions.
</p>
<p>
To keep things optimal, LCL components should always override 
RealGet/SetText; Get/SetTextBuf is only kept for compatibility.
</p>
</descr>
</element>

<element name="TControl.OnConstrainedResize">
<short>
This handler can supply specific Constraints (size limits), when the control 
is resized.
</short>
<descr/>
<seealso>
<link id="TConstrainedResizeEvent"/>
<link id="TControl.Constraints"/>
</seealso>
</element>

<element name="TControl.OnContextPopup">
<short>Invoked when a context-sensitive pop-up menu is requested.</short>
<descr>
<p>
The handler can show and handle the menu selection itself. If so, it should 
set Handled to <b>True</b>. Otherwise the installed PopupMenu is shown.
</p>
</descr>
<seealso>
<link id="TContextPopupEvent"/>
<link id="TControl.PopupMenu"/>
</seealso>
</element>

<element name="TControl.OnDblClick">
<short>
Event handler signalled when a mouse double click occurs in the control.
</short>
<descr>
<p>
<var>OnDblClick</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled when the mouse is double-clicked on the control. OnDblClick 
is signalled from the DblClick method, and occurs when the LM_LBUTTONDBLCLK 
message is handled in the WMLButtonDBLCLK method.
</p>
<remark>
Click events are not generated if csClickEvents has been omitted from the 
ControlStyle flags for the control.
</remark>
<p>
Double-clicking is much more common in a Windows environment than in Unix or 
Linux, where single-clicking is the default method for selecting an object. 
However, in all environments there could be valid use for a double-click, and 
a method should be supplied if appropriate.
</p>
<p>
Use OnClick to perform actions needed when a single mouse click occurs in the 
control.
</p>
</descr>
<seealso>
<link id="TControl.DblClick"/>
<link id="TControl.WMLButtonDBLCLK"/>
<link id="TControl.ControlStyle"/>
<link id="TControl.OnClick"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnTripleClick">
<short>
Event handler signalled when a mouse triple click occurs in the control.
</short>
<descr>
<p>
<var>OnTripleClick</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled when the mouse is triple-clicked on the control. 
OnTripleClick is signalled (when assigned) from the TripleClick method, and 
occurs when the LM_LBUTTONTRIPLECLK message is handled in the 
WMLButtonTRIPLECLK method.
</p>
<remark>
Click events are not generated if csClickEvents has been omitted from the 
ControlStyle flags for the control.
</remark>
<p>
Use OnClick or OnDblClick to perform actions needed when a single or double 
mouse click occurs in the control.
</p>
</descr>
<seealso>
<link id="TControl.TripleClick"/>
<link id="TControl.WMLButtonTRIPLECLK"/>
<link id="TControl.ControlStyle"/>
<link id="TControl.OnClick"/>
<link id="TControl.OnDblClick"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnQuadClick">
<short>
Event handler signalled when a mouse quadruple mouse occurs in the control.
</short>
<descr>
<p>
<var>OnQuadClick</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled when the mouse is quadruple-clicked on the control. 
OnQuadClick is signalled (when assigned) from the QuadClick method, and 
occurs when the LM_LBUTTONQUADCLK message is handled in the WMLButtonQUADCLK 
method.
</p>
<remark>
Click events are not generated if csClickEvents has been omitted from the 
ControlStyle flags for the control.
</remark>
<p>
Use OnClick, OnDblClick, or OnTripleClick to perform actions needed when a 
single, double, or triple mouse click occurs in the control.
</p>
</descr>
<seealso>
<link id="TControl.QuadClick"/>
<link id="TControl.WMLButtonQUADCLK"/>
<link id="TControl.ControlStyle"/>
<link id="TControl.OnClick"/>
<link id="TControl.OnDblClick"/>
<link id="TControl.OnTripleClick"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnDragDrop">
<short>
Event handler signalled when an object is dropped onto the control.
</short>
<descr>
<p>
<var>OnDragDrop</var> is a <var>TDragDropEvent</var> property with the event 
handler signalled when another control is dropped onto the control instance. 
Unlike with drag-dock, a default action is not associated with the drag-drop 
operation. The OnDragDrop handler is the only way to do something meaningful 
for the drag-drop operation.
</p>
<p>
The <var>Sender</var> argument contains the current control instance (Self)
for for the event.
</p>
<p>
The <var>Source</var> argument is the object (TControl) which is droppped 
onto the current control instance.
</p>
<p>
<var>X</var> and <var>Y</var> contains the control-relative coordinates for 
the mouse pointer when the event occurred.
</p>
<p>
OnDragDrop is signalled from the DragDrop method, and occurs when dmDragDrop 
messages (TDragMessage) are handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.DragDrop"/>
<link id="TDragDropEvent"/>
<link id="TDragMessage"/>
</seealso>
</element>

<element name="TControl.OnDragOver">
<short>
Event handler signalled when a control is dragged over the control instance.
</short>
<descr>
<p>
<var>OnDragOver</var> is a <var>TDragOverEvent</var> property with the event 
handler signalled when another control is dragged over the current control. 
It is signalled from the DragOver method, and occurs when drag messages are 
handled for the control.
</p>
<p>
The <var>Sender</var> argument is the current TControl instance.
</p>
<p>
The <var>Source</var> argument contains the control instance which is being 
dragged over the control.
</p>
<p>
The X and Y arguments contain the control-relative coordinates for the mouse 
pointer when the event was triggered.
</p>
<p>
<var>State</var> indicates whether the event has occurred when the mouse 
pointer entered the control, was repositioned, or exited the control.
</p>
<p>
The <var>Accept</var> argument indicates whether the drag operation is 
handled in the routine or rejected. Set Accept to <b>False</b> to reject a 
drop on the control.
</p>
</descr>
<seealso>
<link id="TControl.DragOver"/>
<link id="TDragOverEvent"/>
</seealso>
</element>

<element name="TControl.OnEndDock">
<short>
Event handler signalled for the end of a drag-dock operation.
</short>
<descr>
<p>
<var>OnEndDock</var> is a <var>TEndDragEvent</var> property with the event 
handler signalled when a drag-dock operation is ended. It occurs when the 
EndDrag method is called for the active drag object in the DragManager.
</p>
<p>
Use OnEndDrag to perform actions needed when a drag-drop operation is ended.
</p>
</descr>
<seealso>
<link id="TControl.OnEndDrag"/>
<link id="TEndDragEvent"/>
<link id="TDragDockObject.EndDrag"/>
<link id="TDragManager"/>
<link id="DragManager"/>
</seealso>
</element>

<element name="TControl.OnEndDrag">
<short>
Event handler signalled for the end of a drag-drop operation.
</short>
<descr>
<p>
<var>OnEndDrag</var> is a <var>TEndDragEvent</var> property with the event 
handler signalled when a drag-drop operation is ended. It occurs when the 
EndDrag method is called for the active drag object in the DragManager.
</p>
<p>
Use OnEndDrag to perform actions needed when a drag-drop operation is ended.
</p>
</descr>
<seealso>
<link id="TControl.OnEndDock"/>
<link id="TEndDragEvent"/>
<link id="TDragObject.EndDrag"/>
<link id="TDragManager"/>
<link id="DragManager"/>
</seealso>
</element>

<element name="TControl.OnMouseDown">
<short>
Event handler signalled when a mouse down event is handled for the control.
</short>
<descr>
<p>
<var>OnMouseDown</var> is signalled (when assigned) from the 
<var>MouseDown</var> method. It occurs after the parent form has been 
focused, and an active edit control has been cancelled. If the DragManager is 
active, it has already been updated with the mouse position prior to the 
event.
</p>
<p>
An application must implement and assign a TMouseEvent handler routine to the 
property which responds to the event notification.
</p>
<p>
Use OnMouseUp to perform actions needed when a mouse up event is handled for 
the control.
</p>
<p>
Use OnMouseMove to perform actions needed when the mouse pointer position has 
changed for the control.
</p>
<p>
Use OnMouseWheel, OnMouseWheelDown, and OnMouseWheelUp to preforms actions 
needed when mouse scroll wheel messages are handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.MouseDown"/>
<link id="TControl.OnMouseUp"/>
<link id="TControl.OnMouseMove"/>
<link id="TControl.OnMouseWheel"/>
<link id="TControl.OnMouseWheelDown"/>
<link id="TControl.OnMouseWheelUp"/>
<link id="TControl.OnClick"/>
<link id="TMouseEvent"/>
</seealso>
</element>

<element name="TControl.OnMouseMove">
<short>
Event handler signalled when the mouse pointer is moved in the control.
</short>
<descr>
<p>
<var>OnMouseMove</var> is a <var>TMouseMoveEvent</var> property with the 
event handler signalled when the LM_MOUSEMOVE message is handled for the 
control. It is signalled (when assigned) from the MouseMove method, and 
occurs after the mouse position has been updated and the DragManager has been 
notified of the new pointer position.
</p>
<p>
An application can implement and assign an object procedure to the event 
handler to perform actions needed when the mouse position is changed within 
the control. The control for the notification event is passed as the Sender 
argument.
</p>
<p>
Use OnMouseDown and OnMouseUp to respond to mouse button events in the 
control.
</p>
<p>
Use OnMouseEnter and OnMouseLeave to respond to mouse movements where the 
pointer enters or exits the control.
</p>
<p>
Use OnMouseWheel to perform actions needed when a mouse wheel event occurs in 
the control.
</p>
</descr>
<seealso>
<link id="TControl.MouseMove"/>
<link id="TControl.WMMouseMove"/>
<link id="TControl.OnMouseDown"/>
<link id="TControl.OnMouseEnter"/>
<link id="TControl.OnMouseLeave"/>
<link id="TControl.OnMouseUp"/>
<link id="TControl.OnMouseWheel"/>
<link id="TMouseMoveEvent"/>
<link id="TDragManager.MouseMove"/>
<link id="DragManager"/>
</seealso>
</element>

<element name="TControl.OnMouseUp">
<short>
Event handler signalled when a mouse up event is handled for the control.
</short>
<descr>
<p>
<var>OnMouseUp</var> is signalled (when assigned) from the <var>MouseUp</var> 
method. It is signalled when standard mouse events are enabled using the 
ControlStyle property. The event is signalled after the mouse position has 
been updated and the event is applied to an active DragManager.
</p>
<p>
An application must implement and assign a TMouseEvent handler routine to the 
property which responds to the event notification.
</p>
<p>
Use OnMouseDown to perform actions needed when a mouse down event is handled 
for the control.
</p>
<p>
Use OnMouseMove to perform actions needed when the mouse pointer position has 
changed for the control.
</p>
<p>
Use OnMouseWheel, OnMouseWheelDown, and OnMouseWheelUp to preforms actions 
needed when mouse scroll wheel messages are handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.MouseUp"/>
<link id="TControl.OnMouseDown"/>
<link id="TControl.OnMouseMove"/>
<link id="TControl.OnMouseWheel"/>
<link id="TControl.OnMouseWheelDown"/>
<link id="TControl.OnMouseWheelUp"/>
<link id="TControl.OnClick"/>
<link id="TMouseEvent"/>
</seealso>
</element>

<element name="TControl.OnMouseEnter">
<short>
Event handler signalled when the mouse pointer has entered the control.
</short>
<descr>
<p>
<var>OnMouseEnter</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled when the mouse pointer has entered the bounds for the 
control. OnMouseEnter is signalled from the MouseEnter method (when 
assigned), and occurs after the Parent control has been notified of the 
event. The Sender argument contains the control for the notification, and 
must be cast to a TControl type to access the properties or values specific 
to the class type.
</p>
<p>
Use OnMouseLeave to perform actions needed when the mouse pointer has left 
the bounds for the control.
</p>
</descr>
<seealso>
<link id="TControl.MouseEnter"/>
<link id="TControl.CMMouseEnter"/>
<link id="TControl.OnMouseLeave"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnMouseLeave">
<short>
Event handler signalled when the mouse pointer has left the control.
</short>
<descr>
<p>
<var>OnMouseLeave</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled when the mouse pointer has left the bounds for the control. 
OnMouseLeave is signalled from the MouseLeave method (when assigned), and 
occurs after the Parent control has been notified of the event. The Sender 
argument contains the control for the notification, and must be cast to a 
TControl type to access the properties or values specific to the class type.
</p>
<p>
Use OnMouseEnter to perform actions needed when the mouse pointer has entered 
the bounds for the control.
</p>
</descr>
<seealso>
<link id="TControl.MouseLeave"/>
<link id="TControl.CMMouseLeave"/>
<link id="TControl.OnMouseEnter"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnMouseWheel">
<short>Event handler for mouse wheel turned.</short>
<descr>
<p>
<var>OnMouseWheel</var> is a <var>TMouseWheelEvent</var> property with the 
event handler signalled when a mouse wheel movement occurs in for the 
control. By default all mouse wheel actions are translated into scroll 
events. Write an OnMouseWheel handler to react when the mouse wheel is 
rotated.
</p>
<p>
Arguments for the event handler routine include:
</p>
<dl>
<dt>Sender</dt>
<dd>
The control for the event notification.
</dd>
<dt>Shift</dt>
<dd>
The shift modifier in effect when the action occurred.
</dd>
<dt>WheelDelta</dt>
<dd>
The relative number of units and direction the mouse wheel was rotated.
</dd>
<dt>MousePos</dt>
<dd>
The location for the mouse pointer when the event occurred.
</dd>
<dt>Handled</dt>
<dd>
A variable argument which indicates if the mouse wheel movement is handled in 
the event handler.
</dd>
</dl>
<p>
OnMouseWheel is signalled (when assigned) from the DoMouseWheel method, and 
occurs when the LM_MOUSEWHEEL message is handled in the WMMouseWheel method. 
If the event handler does not set the Handled argument to <b>True</b>, other 
assigned handler routines are signalled. These include control handlers added 
using the AddHandler method, as well as OnMouseWheelDown and OnMouseWheelUp.
</p>
<p>
The value in WheelDelta argument is used to determine the handler signalled. 
OnMouseWheelUp is used when the delta value (or the relative number of units 
of movement) is 0 (zero) or a positive number. OnMouseWheelDown is used when 
the delta value is a negative number.
</p>
<p>
Neither OnMouseWheelUp nor OnMouseWheelDown include the wheel delta value; 
they are simple notifications that the event has occurred at a given position.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheelDown"/>
<link id="TControl.OnMouseWheelLeft"/>
<link id="TControl.OnMouseWheelRight"/>
<link id="TControl.OnMouseWheelUp"/>
<link id="TControl.DoMouseWheel"/>
<link id="TControl.WMMouseHWheel"/>
<link id="TControl.DoCallMouseWheelEventHandler"/>
<link id="TMouseWheelEvent"/>
</seealso>
</element>

<element name="TControl.OnMouseWheelDown">
<short>
Event handler signalled for a downward movement of the mouse wheel.
</short>
<descr>
<p>
<var>OnMouseWheelDown</var> is a <var>TMouseWheelUpDownEvent</var> property 
with the event handler signalled when a downward movement of the mouse wheel 
has occurred in the control.
</p>
<p>
OnMouseWheelDown is signalled (when assigned) from the DoMouseWheelDown 
method using the control instance as the Sender for the event notification. 
It occurs when the OnMouseWheel event handler has not been assigned, or does 
not handle the mouse wheel event.
</p>
<p>
Use OnMouseWheelUp to perform actions needed when an upward movement of the 
mouse wheel has occurred.
</p>
<p>
Use OnMouseWheel when a delta value with the direction for the mouse wheel 
movement is needed.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheel"/>
<link id="TControl.OnMouseWheelUp"/>
<link id="TControl.DoMouseWheelDown"/>
<link id="TControl.DoMouseWheel"/>
<link id="TMouseWheelUpDownEvent"/>
</seealso>
</element>

<element name="TControl.OnMouseWheelUp">
<short>
Event handler signalled for an upward movement of the mouse wheel.
</short>
<descr>
<p>
<var>OnMouseWheelUp</var> is a <var>TMouseWheelUpDownEvent</var> property 
with the event handler signalled when the mouse wheel has been rotated in the 
upward direction. It is signalled (when assigned) in the DoMouseWheelUp 
method.
</p>
<p>
OnMouseWheelUp occurs when a mouse wheel event is handled in the WMMouseWheel 
method, and an OnMouseWheel event handler has not been assigned or does not 
handle the mouse wheel event in the DoMouseWheel method.
</p>
<p>
The arguments for the TMouseWheelUpDownEvent event handler include:
</p>
<dl>
<dt>Sender</dt>
<dd>
The control for the event notification.
</dd>
<dt>Shift</dt>
<dd>
The Ctrl, Alt, or Shift modifier in effect when the wheel event occurred.
</dd>
<dt>MousePos</dt>
<dd>
The location of the mouse pointer when the event occurred.
</dd>
<dt>Handled</dt>
<dd>
An variable Boolean argument which indicates if the event is handled in 
the routine.
</dd>
</dl>
<p>
OnMouseWheelUp is used when the delta value (or the relative number of units 
of movement) is 0 (zero) or a positive number.
</p>
<p>
OnMouseWheelDown is used when the delta value is a negative number.
</p>
<p>
Neither OnMouseWheelUp nor OnMouseWheelDown include the delta value; they are 
simple notifications that the event has occurred at a given position.
</p>
<p>
Use OnMouseWheel when the delta value (or the relative number of units of 
movement) are important.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheel"/>
<link id="TControl.OnMouseWheelDown"/>
<link id="TControl.DoMouseWheel"/>
<link id="TControl.DoMouseWheelUp"/>
<link id="TControl.WMMouseWheel"/>
<link id="TMouseWheelUpDownEvent"/>
</seealso>
</element>

<element name="TControl.OnMouseWheelHorz">
<short>
Event handler signalled for a horizontal movement of the mouse wheel.
</short>
<descr>
<p>
<var>OnMouseWheelHorz</var> is a <var>TMouseWheelEvent</var> property with 
the event handler signalled when a mouse wheel tilt event occurs in the 
control. It is signalled (when assigned) from the DoMouseWheelHorz method, 
and occurs when the LM_MOUSEHWHEEL message is handled in the WMMouseHWheel 
method.
</p>
<p>
An application can implement and assign a TMouseWheelEvent routine to the 
event handler to perform actions needed when the event occurs in the control. 
Other control handlers, created using AddHandler and the chtOnMouseWheelHorz 
handler type, may be signalled if OnMouseWheelHorz has not been assigned or 
does not handle the mouse wheel event.
</p>
<p>
OnMouseWheelLeft or OnMouseWheelRight may be signalled (when assigned) if 
OnMouseWheelHorz or other control handlers have not been assigned or do not 
handle the mouse wheel event. The value in the WheelDelta argument determines 
which handler is used; OnMouseWheelLeft when the delta is a negative number 
and OnMouseWheelRight when the delta is 0 or a positive number.
</p>
<p>
OnMouseWheelHorz, and the other horizontal mouse wheel event handlers, 
require a mouse with a tilting scroll wheel to generate the event 
notification.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheelLeft"/>
<link id="TControl.OnMouseWheelRight"/>
<link id="TControl.OnMouseWheel"/>
<link id="TControl.AddHandler"/>
<link id="TMouseWheelEvent"/>
<link id="TControlHandlerType"/>
</seealso>
</element>

<element name="TControl.OnMouseWheelLeft">
<short>
Event handler signalled for a leftward movement of the mouse wheel.
</short>
<descr>
<p>
<var>OnMouseWheelLeft</var> is a <var>TMouseWheelUpDownEvent</var> property 
with the event handler signalled when the mouse wheel is "tilted" towards the 
left. It is signalled (when assigned) from the DoMouseWheelLeft method, and 
occurs when the LM_MOUSEHWHEEL message is handled in the WMMouseHWheel method.
</p>
<p>
Applications can implement and assign a TMouseWheelUpDownEvent to perform 
actions needed when the event has occurred in the control. The arguments to 
the event handler include:
</p>
<dl>
<dt>Sender</dt>
<dd>
The control for the event notification.
</dd>
<dt>Shift</dt>
<dd>
The shift modifier in effect when the event occurred.
</dd>
<dt>MousePos</dt>
<dd>
The coordinates for the mouse pointer when the event occurred.
</dd>
<dt>Handled</dt>
<dd>
A variable argument which indicates if the wheel event is handled in the 
routine.
</dd>
</dl>
<p>
There are several horizontal mouse wheel event handlers, and they are 
signalled in order until a handler is found that responds to the event 
notification. These include: 
</p>
<ul>
<li>
OnMouseWheelHorz
</li>
<li>
Controls handlers added using AddHandler and the chtOnMouseWheelHorz handler 
type.
</li>
<li>
OnMouseWheelLeft or OnMouseWheelRight depending on the WheelDelta - or 
relative units of movement for the mouse wheel.
</li>
</ul>
<p>
OnMouseWheelLeft, and the other horizontal mouse wheel event handlers, 
require a mouse with a tilting scroll wheel to generate the event 
notification.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheelRight"/>
<link id="TControl.OnMouseWheelHorz"/>
<link id="TControl.OnMouseWheel"/>
<link id="TMouseWheelUpDownEvent"/>
</seealso>
</element>

<element name="TControl.OnMouseWheelRight">
<short>
Event handler signalled for a rightward movement of the mouse wheel.
</short>
<descr>
<p>
<var>OnMouseWheelRight</var> is a <var>TMouseWheelUpDownEvent</var> property 
with the event handler signalled when the mouse wheel is "tilted" towards the 
right. It is signalled (when assigned) from the DoMouseWheelRight method, and 
occurs when the LM_MOUSEHWHEEL message is handled in the WMMouseHWheel method.
</p>
<p>
Applications can implement and assign a TMouseWheelUpDownEvent to perform 
actions needed when the event has occurred in the control. The arguments to 
the event handler include:
</p>
<dl>
<dt>Sender</dt>
<dd>
The control for the event notification.
</dd>
<dt>Shift</dt>
<dd>
The shift modifier in effect when the event occurred.
</dd>
<dt>MousePos</dt>
<dd>
The coordinates for the mouse pointer when the event occurred.
</dd>
<dt>Handled</dt>
<dd>
A variable argument which indicates if the wheel event is handled in the 
routine.
</dd>
</dl>
<p>
There are several horizontal mouse wheel event handlers, and they are 
signalled in order until a handler is found that responds to the event 
notification. These include: 
</p>
<ul>
<li>
OnMouseWheelHorz
</li>
<li>
Controls handlers added using AddHandler and the chtOnMouseWheelHorz handler 
type.
</li>
<li>
OnMouseWheelLeft or OnMouseWheelRight depending on the WheelDelta - or 
relative units of movement for the mouse wheel.
</li>
</ul>
<p>
OnMouseWheelRight, and the other horizontal mouse wheel event handlers, 
require a mouse with a tilting scroll wheel to generate the event 
notification.
</p>
</descr>
<seealso>
<link id="TControl.OnMouseWheelLeft"/>
<link id="TControl.OnMouseWheelHorz"/>
<link id="TControl.OnMouseWheel"/>
<link id="TMouseWheelUpDownEvent"/>
</seealso>
</element>

<element name="TControl.OnStartDock">
<short>Event handler for the start of a docking operation.</short>
<descr>
<p>
The handler can provide a special DragDock object, otherwise a default object 
is created.
</p>
</descr>
<seealso>
<link id="TControl.OnStartDrag"/>
<link id="TDragDockObject"/>
</seealso>
</element>

<element name="TControl.OnStartDrag">
<short>
Event handler signalled for the start of a dragging operation.
</short>
<descr>
<p>
<var>OnStartDrag</var> is a <var>TStartDragEvent</var> property with the 
event handler signalled when a drag operation is started for the control. Use 
the event handler to perform actions needed when the drag operation is 
started, such customizing the drag cursor or initializing related drag event 
handlers.
</p>
<p>
The <var>Sender</var> argument is the TControl instance for the event 
notification.
</p>
<p>
The <var>DragObject</var> argument returns the TDragControlObject allocated 
by the drag manager when the drag operation was started.
</p>
</descr>
<seealso>
<link id="TControl.OnStartDock"/>
<link id="TDragControlObject"/>
<link id="TStartDragEvent"/>
</seealso>
</element>

<element name="TControl.OnEditingDone">
<short>
Event handler signalled when editing is completed for the control.
</short>
<descr>
<p>
The user has finished editing the value for the control, and the resulting 
text can be validated. It is called (when assigned) from the 
<var>EditingDone</var> method, which occurs when focus changes to another 
control.
</p>
</descr>
<seealso>
<link id="TControl.EditingDone"/>
</seealso>
</element>

<element name="TControl.FCompStyle">
<short>
Enables use of the 'IN' operator for component styles.
</short>
<descr>
<p>
Enables valid use of the <b>'IN'</b> operator (this is a hack for speed). It 
will eventually be replaced by use of the widgetset classes. So, don't use it 
anymore... even though some existing LCL code still does.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.DragDrop">
<short>
Signals the OnDragDrop handler when a dragged object is dropped onto this 
control.
</short>
<seealso>
<link id="TControl.OnDragDrop"/>
</seealso>
</element>
<element name="TControl.DragDrop.Source">
<short>The dropped object (control or DragDrop object).</short>
</element>
<element name="TControl.DragDrop.X">
<short>The drop position in client coordinates.</short>
</element>
<element name="TControl.DragDrop.Y">
<short>The drop position in client coordinates.</short>
</element>

<element name="TControl.Dock">
<short>Moves the control into a new docksite.</short>
<descr>
<p>
Calls <link id="TControl.DoDock">DoDock</link> to prepare for the new 
position of the control, when docked into an unmanaged or floating docksite.
</p>
<p>
When the old and new docksites are different, the control is removed from the 
DockClients of the old docksite, and added to the DockClients of the new 
docksite; afterwards the docksites are notified by calling their 
DoAddDockClient and DoRemoveDockClient methods, to adjust the control's 
Parent.
</p>
</descr>
<errors>
An exception is raised if there is already a docking process in progress for 
this control.
</errors>
</element>
<element name="TControl.Dock.NewDockSite">
<short>
The host site into which which the control is to be docked, <b>Nil</b> for 
floating.
</short>
</element>
<element name="TControl.Dock.ARect">
<short>
The new Bounds for the control. Expressed in screen coordinates when 
NewDockSite is <b>Nil</b>. Otherwise, client coordinates for NewDockSite.
</short>
</element>

<element name="TControl.ManualDock">
<short>Docks a control programmatically.</short>
<descr>
<p>
Docks this control into NewDockSite, relative to DropControl. When 
NewDockSite is <b>Nil</b>, the control becomes floating.
</p>
<p>
When the new docksite uses an DockManager, and DropControl is not <b>Nil</b>, 
the control will be docked relative to DropControl, as specified by 
ControlSide.
</p>
<p>
The interpretation of ControlSide depends on the DockManager of NewDockSite,
or on the OnDockDrop handler in an unmanaged docksite.
</p>
<p>
A tree docking manager (TDockTree) should interpret alCustom as NoteBook 
docking, i.e. a tabbed notebook is created in place of DropControl, and both 
DropControl and this control are docked into pages of this notebook.
</p>
</descr>
</element>
<element name="TControl.ManualDock.Result">
<short><b>True</b> if successfully docked.</short>
</element>
<element name="TControl.ManualDock.NewDockSite">
<short>
The site into which the control is docked; <b>Nil</b> to make it float.
</short>
</element>
<element name="TControl.ManualDock.DropControl">
<short>The sibling control where the control is inserted; can be <b>Nil</b>.
</short>
</element>
<element name="TControl.ManualDock.ControlSide">
<short>
The side or edge of the DropControl to which the control is docked.
</short>
</element>
<element name="TControl.ManualDock.KeepDockSiteSize">
<short/>
</element>

<element name="TControl.ManualFloat">
<short>Undocks the control into a floating dock site.</short>
<descr>
<p>
<var>ManualFloat</var> is a <var>Boolean</var> function used to undock the 
control. It undocks the control from the HostDockSite (when assigned) found 
in the control or in its Parent.
</p>
<p>
For TControl, which does not have a handle, a floating host dock site where 
the control can be docked is created. TWinControl has a handle and can float 
without any assistance.
</p>
<p>
The Dock method is called to dock the control to the new floating dock site.
</p>
<p>
The return value is <var>True</var> if the control was successfully undocked 
and re-docked to a floating dock site.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TControl.HostDockSite"/>
<link id="TControl.CreateFloatingDockSite"/>
<link id="TControl.Dock"/>
<link id="TWinControl.DoUndock"/>
<link id="TWinControl.DoUndockClientMsg"/>
</seealso>
</element>
<element name="TControl.ManualFloat.Result">
<short><b>True</b> if successfully floated.</short>
</element>
<element name="TControl.ManualFloat.TheScreenRect">
<short>
The screen area where the floating control is moved; or the client area for a 
floating host site.
</short>
</element>
<element name="TControl.ManualFloat.KeepDockSiteSize">
<short>
<b>True</b> if the undocked control keeps its docked dimensions. The default 
value is <b>True</b>.
</short>
</element>

<element name="TControl.ReplaceDockedControl">
<short>Replaces a previously docked control.</short>
<descr>
<p>
This method exists for use by the DockManager for NoteBook docking. It should 
not be used in application code.
</p>
<p>
Delphi introduced a different method, DockReplaceDockClient, which is used 
when the replaced Control is in an unmanaged docksite.
</p>
</descr>
<seealso>
<link id="TControl.ManualDock"/>
</seealso>
</element>
<element name="TControl.ReplaceDockedControl.Result">
<short>
<b>True</b> if the docked control has been successfully replaced.
</short>
</element>
<element name="TControl.ReplaceDockedControl.Control">
<short>The control to be replaced, will be docked into NewDockSite.</short>
</element>
<element name="TControl.ReplaceDockedControl.NewDockSite">
<short>The new dock site for Control, typically a docking Notebook.
</short>
</element>
<element name="TControl.ReplaceDockedControl.DropControl">
<short>The control to which Control is docked.</short>
</element>
<element name="TControl.ReplaceDockedControl.ControlSide">
<short>The side of DropControl, to which Control is docked.</short>
</element>

<element name="TControl.Docked">
<short>Indicates if the control has a host dock site.</short>
<descr>
<p>
Docked is a Boolean function which indicates if the control instance is 
docked to a host docking site. The return value is <b>True</b> when all of 
the following conditions are met:
</p>
<ul>
<li>Parent is assigned (not <b>Nil</b>).</li>
<li>Parent has the same value as the HostDockSite property.</li>
<li>
Parent has a parent form with a value different than the one in Parent.
</li>
</ul>
</descr>
<seealso>
<link id="TControl.HostDockSite"/>
<link id="TControl.Parent"/>
<link id="#lcl.forms.GetParentForm">GetParentForm</link>
</seealso>
</element>
<element name="TControl.Docked.Result">
<short>
True if the Parent control is also the HostDockSite for the control.
</short>
</element>

<element name="TControl.Dragging">
<short>Returns <b>True</b> if the control is being dragged.</short>
</element>
<element name="TControl.Dragging.Result">
<short>Returns <b>True</b> if the control is being dragged.</short>
</element>

<element name="TControl.GetAccessibleObject">
<short>Returns <b>True</b> if the control is being dragged.</short>
</element>

<element name="TControl.CreateAccessibleObject">
<short>
Creates a TLazAccessibleObject instance for this control.
</short>
<descr>
<p>
CreateAccessibleObject should just create and return the object instance. It 
is useful for classes derived from a descendant of TLazAccessibleObject 
(instead of the base class).
</p>
</descr>
<seealso>
<link id="TLazAccessibleObject"/>
<link id="TControl.GetAccessibleObject"/>
</seealso>
</element>

<element name="TControl.GetSelectedChildAccessibleObject">
<short>
Returns the currently selected child accessibility object.
</short>
<descr>
<p>
GetSelectedChildAccessibleObject is provided for controls which wish to 
override this behavior without sub-classing TLazAccessibleObject.
</p>
</descr>
<seealso>
<link id="TLazAccessibleObject"/>
<link id="TLazAccessibleObject.GetSelectedChildAccessibleObject"/>
<link id="TControl.CreateAccessibleObject"/>
<link id="TControl.GetAccessibleObject"/>
</seealso>
</element>

<element name="TControl.GetChildAccessibleObjectAtPos">
<short>
Returns the child accessibility object at the given position for the control.
</short>
<descr>
<p>
GetChildAccessibleObjectAtPos returns the accessibility object at the 
position expressed in client coordinates. This method is provided for 
controls which wish to override this behavior without sub-classing 
TLazAccessibleObject.
</p>
</descr>
<seealso>
<link id="TLazAccessibleObject"/>
<link id="TLazAccessibleObject.GetChildAccessibleObjectAtPos"/>
<link id="TControl.CreateAccessibleObject"/>
<link id="TControl.GetAccessibleObject"/>
</seealso>
</element>

<element name="TControl.ScaleDesignToForm">
<short>
Scales a size value from the design-time PPI to the run-time PPI for the 
parent form.
</short>
<descr>
</descr>
<seealso/>
</element>
<element name="TControl.ScaleDesignToForm.Result">
<short>Scaled sized value.</short>
</element>
<element name="TControl.ScaleDesignToForm.ASize">
<short>Original size value scaled in the method.</short>
</element>

<element name="TControl.ScaleFormToDesign">
<short>
Scales a size value from the run-time PPI for the parent form to the 
design-time PPI.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ScaleFormToDesign.Result">
<short>Scaled sized value.</short>
</element>
<element name="TControl.ScaleFormToDesign.ASize">
<short>Original size value scaled in the method.</short>
</element>

<element name="TControl.Scale96ToForm">
<short>
Scales a size value from 96 PPI to the run-time PPI for the Screen.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.Scale96ToForm.Result">
<short>
Scaled size value.
</short>
</element>
<element name="TControl.Scale96ToForm.ASize">
<short>
Original size value scaled in the method.
</short>
</element>

<element name="TControl.ScaleFormTo96">
<short>
Scales a size value from the PPI for the Parent form (or designer control) to 
96 PPI.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ScaleFormTo96.Result">
<short>
Scaled size value.
</short>
</element>
<element name="TControl.ScaleFormTo96.ASize">
<short>
Original size value scaled in the method.
</short>
</element>

<element name="TControl.Scale96ToFont">
<short>
Scales a size value from 96 PPI to the PPI setting for the Font in the 
control.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.Scale96ToFont.Result">
<short>
Scaled sized value.
</short>
</element>
<element name="TControl.Scale96ToFont.ASize">
<short>
Original size value scaled in the method.
</short>
</element>

<element name="TControl.ScaleFontTo96">
<short>
Scales a size value from the PPI setting in the Font for the control to 96 
PPI.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ScaleFontTo96.Result">
<short>
Scaled size value.
</short>
</element>
<element name="TControl.ScaleFontTo96.ASize">
<short>
Original size value scaled in the method.
</short>
</element>

<element name="TControl.ScaleScreenToFont">
<short>
Scales a size value from the PPI setting for the Screen to the PPI setting 
for the Font in the control.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ScaleScreenToFont.Result">
<short>
Scaled size value.
</short>
</element>
<element name="TControl.ScaleScreenToFont.ASize">
<short>
Original size value scaled in the method.
</short>
</element>

<element name="TControl.ScaleFontToScreen">
<short>
Scales a size value from the PPI setting for the Font to the PPI setting for 
the Screen.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ScaleFontToScreen.Result">
<short>
Scaled size value.
</short>
</element>
<element name="TControl.ScaleFontToScreen.ASize">
<short>
Size value scaled in the method.
</short>
</element>

<element name="TControl.Scale96ToScreen">
<short>
Scales a size value from 96 PPI to the PPI setting for the Screen.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.Scale96ToScreen.Result">
<short>
Scaled size value.
</short>
</element>
<element name="TControl.Scale96ToScreen.ASize">
<short>
Size value scaled in the method.
</short>
</element>

<element name="TControl.ScaleScreenTo96">
<short>
Scales a size value from the PPI setting for the Screen to 96 PPI.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ScaleScreenTo96.Result">
<short>
Scaled size value.
</short>
</element>
<element name="TControl.ScaleScreenTo96.ASize">
<short>
Size value scaled in the method.
</short>
</element>

<element name="TControl.AdjustSize">
<short>Smart way to <var>DoAutoSize</var>.
</short>
<descr>
<p>
<var>AdjustSize</var> is the same as Delphi the 
<var>TWinControl.DoAutoSize</var> method. But since <var>DoAutoSize</var> is 
commonly overridden in descendent components, it is not useful to perform all 
tests, which can result in too much overhead. To reduce this the LCL calls 
<var>AdjustSize</var> instead.
</p>
<p>
During loading and handle creation the calls are delayed.
</p>
</descr>
<seealso>
<link id="TControl.AutoSize"/>
</seealso>
</element>

<element name="TControl.AutoSizePhases">
<short>Auto-sizing phases enabled for the control.</short>
<descr>
<p>
<var>AutoSizePhases</var> is a <var>TControlAutoSizePhases</var> function 
used to get the <var>Autosizing</var> phases enabled for the control. In 
general, the values in AutoSizePhases depend on the 
<var>TWinControlFlag</var> values enabled for the control.
</p>
<p>
For <var>TControl</var>, the values from the Parent control are used. If the 
Parent control is unassigned, the value is an empty set (<b>[]</b>).
</p>
<p>
For <var>TWinControl</var>, the value from the Parent control are used (when 
a Parent has been assigned). Otherwise, the windows control flags are used to 
get the return value. For example:
</p>
<dl>
<dt>wcfCreatingHandle,wcfCreatingChildHandles</dt>
<dd>Includes caspCreatingHandles in the set</dd>
<dt>wcfRealizingBounds</dt>
<dd>Includes caspRealizingBounds in the set</dd>
<dt>wcfUpdateShowing</dt>
<dd>Includes caspShowing in the set</dd>
</dl>
<p>
In addition, <var>AutoSizingAll</var> forces <var>caspComputingBounds</var> 
to be included in the set. <var>caspChangingProperties</var> is included when 
the internal auto-sizing lock count has a value greater than zero (<b>0</b>).
</p>
</descr>
<seealso>
<link id="TWinControlFlags"/>
<link id="TControlAutoSizePhase"/>
</seealso>
</element>
<element name="TControl.AutoSizePhases.Result">
<short>Set with the TControlAutoSizePhase values.</short>
</element>

<element name="TControl.AutoSizeDelayed">
<short>
Returns <b>True</b> if auto-sizing has been delayed until some other process 
is complete.
</short>
</element>
<element name="TControl.AutoSizeDelayed.Result">
<short><b>True</b> if auto-sizing has been delayed.</short>
</element>

<element name="TControl.AutoSizeDelayedReport">
<short>
Returns a string with a debugging message for delayed auto-size requests.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AutoSizeDelayedReport.Result">
<short>
Formatted message with flag, counter, or property values related to delayed 
auto-sizing in the control.
</short>
</element>

<element name="TControl.AutoSizeDelayedHandle">
<short>
Returns <b>True</b> if AutoSize should be skipped or delayed because of its 
handle.
</short>
<descr>
<p>
A TControl instance does not have a handle, so it needs a parent control.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.AutoSizeDelayedHandle.Result">
<short>
<b>True</b> if AutoSize should be skipped or delayed because of its handle.
</short>
</element>

<element name="TControl.AnchorToNeighbour">
<short>Anchor to Sibling at Side.</short>
<descr>
<p>
Setup <var>AnchorSide</var> to anchor a side to a neighboring sibling 
control. For example: Right side to Left side, or Top side to Bottom.
</p>
</descr>
</element>
<element name="TControl.AnchorToNeighbour.Side">
<short>The side to be anchored to Sibling.</short>
</element>
<element name="TControl.AnchorToNeighbour.Space">
<short>The minimum space to Sibling.</short>
</element>
<element name="TControl.AnchorToNeighbour.Sibling">
<short>The sibling control to which we should anchor.</short>
</element>

<element name="TControl.AnchorParallel">
<short>Anchor parallel to Sibling, at Side.</short>
<descr/>
</element>
<element name="TControl.AnchorParallel.Side">
<short>The side to anchor to the sibling.</short>
</element>
<element name="TControl.AnchorParallel.Space">
<short>The minimum space to Sibling.</short>
</element>
<element name="TControl.AnchorParallel.Sibling">
<short>The sibling control to which we should anchor.</short>
</element>

<element name="TControl.AnchorHorizontalCenterTo">
<short>
Anchors the horizontal center of the control to the center of the specified 
sibling.
</short>
</element>
<element name="TControl.AnchorHorizontalCenterTo.Sibling">
<short>The sibling control to which we should anchor.</short>
</element>

<element name="TControl.AnchorVerticalCenterTo">
<short>
Anchors the vertical center of the control to the center of the specified 
Sibling.
</short>
</element>
<element name="TControl.AnchorVerticalCenterTo.Sibling">
<short>The sibling control to which we should anchor.</short>
</element>

<element name="TControl.AnchorToCompanion">
<short>
Anchor to Sibling at Side, with the same extent.
</short>
<descr>
<p>
Table or tree style anchoring, into a neighbor cell of Sibling. Obtain the 
row height (or column width) from <var>Sibling</var>.
</p>
</descr>
</element>
<element name="TControl.AnchorToCompanion.Side">
<short>The side to anchor to the sibling.</short>
</element>
<element name="TControl.AnchorToCompanion.Space">
<short>The minimum space to Sibling.</short>
</element>
<element name="TControl.AnchorToCompanion.Sibling">
<short>The sibling control to which we should anchor.</short>
</element>
<element name="TControl.AnchorToCompanion.FreeCompositeSide">
<short/>
</element>

<element name="TControl.AnchorSame">
<short>Copy Sibling's anchoring for Side.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AnchorSame.Side">
<short>The side to anchor like the sibling does.</short>
</element>
<element name="TControl.AnchorSame.Sibling">
<short>The sibling control from which to inherit anchoring.</short>
</element>

<element name="TControl.AnchorAsAlign">
<short>
Anchor to the Parent using the Align value for the control.
</short>
<descr>
<p>
The anchor control used in the TAnchorSide instances is always the Parent 
control.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.AnchorAsAlign.TheAlign">
<short>
Indicates the position in AnchorAlign with the anchored edges for the 
alignment value.
</short>
</element>
<element name="TControl.AnchorAsAlign.Space">
<short>
Border spacing between the control and its anchored edges.
</short>
</element>

<element name="TControl.AnchorClient">
<short>Anchor to Parent's full client area.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AnchorClient.Space">
<short>The around space.</short>
</element>

<element name="TControl.AnchoredControlCount">
<short>The number of controls anchored to the current control.</short>
</element>
<element name="TControl.AnchoredControlCount.Result">
<short>
Number of controls anchored to the current control.
</short>
</element>

<element name="TControl.AnchoredControls">
<short>
Provides indexed access to controls which are anchored to the current control 
by their ordinal position.
</short>
<descr>
<p>
<var>AnchoredControls</var> is a read-only indexed <var>TControl</var> 
property which allows access to controls which which are anchored to the 
control instance. Anchored controls are indexed by their ordinal position in 
the list used to store the values.
</p>
</descr>
</element>
<element name="TControl.AnchoredControls.Index">
<short>
Ordinal position for the anchored control in the property value.
</short>
</element>

<element name="TControl.SetBounds">
<short>Sets the bounds (Left, Top, Width, Height) of the control.</short>
<descr>
<p>
<var>SetBounds</var> can be used to change the <var>Left</var>, 
<var>Top</var>, <var>Width</var>, and <var>Height</var> properties as a 
single action. This reduces the overhead required for the common operation. 
Use <var>DisableAutoSize</var> and <var>EnableAutoSize</var> to reduce the 
overhead for recomputing/moving/resizing even further.
</p>
<p>
<var>SetBounds</var> is also called when any one of these properties, or the 
BoundsRect property is set. SetBounds updates BaseBounds and 
BaseParentClientSize, which are used by the anchoring mechanism to keep the 
spacing between controls. For example loading a Form with TMemo and the .lfm 
contains TMemo's Left and Width, then SetBounds is called two times for the 
memo.
</p>
<p>
When the user maximizes a window, SetBounds is called for the form, but not 
for the Memo, keeping the BaseBounds of the Memo. If the Memo is anchored to 
the right, the Width of the Memo is changed based on the BaseBounds and 
BaseParentClientSize.
</p>
<p>
Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid 
and will be changed by the LCL before applied.
</p>
<p>
Delphi calls SetBounds more often. SetBounds calls ChangeBounds with the 
KeepBase argument set to <b>False</b>.
</p>
</descr>
</element>
<element name="TControl.SetBounds.aLeft">
<short>The X coordinate of the left side of the control.</short>
</element>
<element name="TControl.SetBounds.aTop">
<short>The Y coordinate of the top of the control.</short>
</element>
<element name="TControl.SetBounds.aWidth">
<short>The width of the control.</short>
</element>
<element name="TControl.SetBounds.aHeight">
<short>The height of the control.</short>
</element>

<element name="TControl.SetInitialBounds">
<short>Sets the bounds of the control initially, when it is created.</short>
<descr>Does nothing while the control is loaded.</descr>
<seealso>
<link id="TControl.SetBounds"/>
</seealso>
</element>
<element name="TControl.SetInitialBounds.aLeft">
<short>X coordinate for the top, left pixel.</short>
</element>
<element name="TControl.SetInitialBounds.aTop">
<short>Y coordinate for the top, left pixel.</short>
</element>
<element name="TControl.SetInitialBounds.aWidth">
<short>Width of control.</short>
</element>
<element name="TControl.SetInitialBounds.aHeight">
<short>Height of control.</short>
</element>

<element name="TControl.SetBoundsKeepBase">
<short>Set the bounds, keeping the base values.</short>
<descr>
<p>
SetBoundsKeepBase is a procedure used to set the bounds for a Control to the 
specified values without affecting the bounds in a Parent control.
</p>
<p>
SetBoundsKeepBase calls the ChangeBounds method to update the sized and 
position for the control to the specified values. If you use this in a custom 
control, disable LCL auto-sizing for this control prior to calling the method.
</p>
<p>
SetBoundsKeepBase is used in the implementation for several methods, 
including:
</p>
<ul>
<li>WMSize</li>
<li>WMMove</li>
<li>WMWindowPosChanged</li>
<li>DoAutoSize</li>
<li>DoAutoAdjustLayout</li>
<li>DoUndock</li>
<li>Loaded</li>
</ul>
</descr>
<seealso>
<link id="TControl.WMSize"/>
<link id="TControl.WMMove"/>
<link id="TControl.DoAutoSize"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TWinControl.WMWindowPosChanged"/>
<link id="TWinControl.DoUndock"/>
<link id="TControl.Loaded"/>
</seealso>
</element>
<element name="TControl.SetBoundsKeepBase.aLeft">
<short>New Left coordinate for the control.</short>
</element>
<element name="TControl.SetBoundsKeepBase.aTop">
<short>New Right coordinate for the control.</short>
</element>
<element name="TControl.SetBoundsKeepBase.aWidth">
<short>New Width for the control.</short>
</element>
<element name="TControl.SetBoundsKeepBase.aHeight">
<short>New Height for the control.</short>
</element>

<element name="TControl.GetPreferredSize">
<short>
Returns default/preferred height and width, for use in auto-sizing.
</short>
<descr>
<p>
Called during AutoSize calculations. Only positive values are valid. Negative 
or 0 are treated as undefined and the LCL uses other sizes instead.
</p>
<p>
WithThemeSpace: If <b>True</b>, adds space for stacking.
</p>
<p>
For example: <var>TRadioButton</var> has a minimum size. But for stacking 
multiple TRadioButtons there should be some space around. This space is theme 
dependent, so the parameter is passed to the widgetset
</p>
<p>
<var>TWinControl</var> overrides this and asks the interface for theme 
dependent values. See <link id="TWinControl.CalculatePreferredSize"/> for 
more information.
</p>
</descr>
</element>
<element name="TControl.GetPreferredSize.PreferredWidth">
<short>
Default width for a new instance of the control.
</short>
</element>
<element name="TControl.GetPreferredSize.PreferredHeight">
<short>
Default height for a new instance of the control.
</short>
</element>
<element name="TControl.GetPreferredSize.Raw">
<short>
When <b>False</b>, the values will be adjusted by the constraints, and 
undefined values will be replaced by GetDefaultWidth/GetDefaultHeight.
</short>
</element>
<element name="TControl.GetPreferredSize.WithThemeSpace">
<short>If <b>True</b>, adds space for stacking.</short>
</element>

<element name="TControl.GetCanvasScaleFactor">
<short>
Gets the scaling factor for the canvas used to render the control.
</short>
<descr>
<p>
<var>GetCanvasScaleFactor</var> is a Double function used to get the scaling 
factor for the Canvas in the control.
</p>
<p>
GetCanvasScaleFactor calls the corresponding method in the widgetset class to 
get the return value. For TControl and TWSControl, the return value is always 
1.0. It may be overridden in descendent classes to use a value appropriate to 
the implementation.
</p>
<p>
GetCanvasScaleFactor is used in descendent classes when selecting a scalable 
image resolution for images and glyphs associated with a control.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.GetCanvasScaleFactor.Result">
<short>
Scaling factor applied to images drawn on the control Canvas.
</short>
</element>

<element name="TControl.GetDefaultWidth">
<short>
The default width for the control independent of any calculated values like 
Width and GetPreferredSize.
</short>
<descr>
</descr>
</element>
<element name="TControl.GetDefaultWidth.Result">
<short>
Default width for the control when preferred size is not defined and it is 
anchored or auto-sized.
</short>
</element>

<element name="TControl.GetDefaultHeight">
<short>
The default height for the control independent of any calculated values like 
Height and GetPreferredSize.
</short>
<descr>
</descr>
</element>
<element name="TControl.GetDefaultHeight.Result">
<short>
Default width for the control when preferred size is not defined and it is 
anchored or auto-sized.
</short></element>

<element name="TControl.GetDefaultColor">
<short>Gets the default color for the control.</short>
<descr>
<p>
<var>GetDefaultColor</var> is a <var>TColor</var> function used to resolve 
the default color (<var>clDefault</var>) to a TColor value for the control. 
GetDefaultColor can return a color value for either the control background or 
its text. The <var>DefaultColorType</var> argument identifies which value is 
needed in the return value. In TControl, the following color types and values 
are used:
</p>
<dl>
<dt>dctBrush</dt>
<dd>
Background or fill color for the control (Color). Returns the clWindow system 
color.
</dd>
<dt>dctFont</dt>
<dd>
Text color for the control (Font.Color). Returns the clWindowText system 
color.
</dd>
</dl>
<p>
GetDefaultColor uses the value provided by the corresponding method in the 
widgetset class instance when a value other than clDefault is returned. When 
not resolved in the widgetset class, the return value is retrieved using the 
Parent color or the local values in the class instance. If 
<var>ParentColor</var> is <b>True</b> (and <var>Parent</var> is assigned), 
the GetDefaultColor method in the Parent control is called to get the 
specified color type. Otherwise, one of the values from the preceding list is 
used for the color type.
</p>
<p>
GetDefaultColor is a virtual method and can be overridden in descendent 
classes to use the colors needed for a specific control.
</p>
<p>
GetDefaultColor is used in the implementation of the GetColorResolvingParent 
and GetRGBColorResolvingParent methods. It is also called from the SetColor 
and CreateBrush methods in the TWinControl descendant.
</p>
</descr>
<seealso>
<link id="TControl.Color"/>
<link id="TControl.Font"/>
<link id="TControl.ParentColor"/>
<link id="TControl.Parent"/>
<link id="TControl.GetColorResolvingParent"/>
<link id="TControl.GetRGBColorResolvingParent"/>
<link id="TWinControl.SetColor"/>
<link id="TWinControl.CreateBrush"/>
<link id="#lcl.graphics.TColor">TColor</link>
<link id="#lcl.graphics.TDefaultColorType">TDefaultColorType</link>
</seealso>
</element>
<element name="TControl.GetDefaultColor.Result">
<short>TColor value for the specified color type.</short>
</element>
<element name="TControl.GetDefaultColor.DefaultColorType">
<short>
Identifies the color type needed in the return value (brush or font).
</short>
</element>

<element name="TControl.GetColorResolvingParent">
<short>
Returns the color of the control while resolving clDefault and ParentColor.
</short>
<descr>
<p>
<var>GetColorResolvingParent</var> is a convenience routine used to obtain 
the Color for the control while resolving clDefault. It will never return 
clDefault, but it might return a non-RGB color. To obtain a purely RGB result 
use GetRGBColorResolvingParent.
</p>
</descr>
<seealso>
<link id="TControl.Color"/>
<link id="TControl.GetDefaultColor"/>
<link id="TControl.ParentColor"/>
<link id="TControl.GetRGBColorResolvingParent"/>
</seealso>
</element>

<element name="TControl.GetRGBColorResolvingParent">
<short>Returns a RGB value for the color used on the control.</short>
<descr>
<p>
<var>GetRGBColorResolvingParent</var> is a convenience routine used to get an 
RGB color value for the background on the control. It calls 
GetColorResolvingParent to translate the clDefault color value to the Brush 
color in a Parent control. It calls ColorToRGB to convert a color constant to 
its numeric equivalent and to remove any alpha channel information in the 
color value.
</p>
</descr>
<seealso>
<link id="TControl.Color"/>
<link id="TControl.ParentColor"/>
<link id="TControl.GetDefaultColor"/>
<link id="TControl.GetColorResolvingParent"/>
<link id="#lcl.graphics.ColorToRGB">ColorToRGB</link>
</seealso>
</element>

<element name="TControl.GetSidePosition">
<short>
Gets the client coordinate for the specified side.
</short>
<descr>
<p>
The return value contains the coordinate for the anchor side indicated in the 
Side argument. For example:
</p>
<dl>
<dt>akLeft</dt>
<dd>Returns the value in the Left property.</dd>
<dt>akTop</dt>
<dd>Returns the value in the Top property.</dd>
<dt>akRight</dt>
<dd>Returns the value in the Right property.</dd>
<dt>akBottom</dt>
<dd>Returns the value in the Bottom property.</dd>
</dl>
</descr>
</element>
<element name="TControl.GetSidePosition.Result">
<short>Value for the specified anchor side.</short>
</element>
<element name="TControl.GetSidePosition.Side">
<short>TAnchorSide value which coordinate value is returned.</short>
</element>

<element name="TControl.CNPreferredSizeChanged">
<short>Message handler for preferred size changed.</short>
<descr>
<p>
Called by the LCL interface, when something changed that effects the 
interface values for GetPreferredSize.
</p>
</descr>
</element>

<element name="TControl.InvalidatePreferredSize">
<short>
Marks the preferred size as invalid for this control and all parents (implies 
that we will look for another).
</short>
</element>

<element name="TControl.GetAnchorsDependingOnParent">
<short>Returns the sides which are anchored to the Parent.</short>
</element>
<element name="TControl.GetAnchorsDependingOnParent.Result">
<short/>
</element>
<element name="TControl.GetAnchorsDependingOnParent.WithNormalAnchors">
<short/>
</element>

<element name="TControl.DisableAutoSizing">
<short>
Disables automatic sizing; implies that the default size is accepted, or 
sizing is done manually.
</short>
</element>

<element name="TControl.EnableAutoSizing">
<short>Enables automatic sizing for the control.</short>
<descr>
<p>
<var>EnableAutoSizing</var> is used along with <var>DisableAutoSizing</var> 
to suspend and restore auto-sizing when the Parent, alignment, layout, 
visibility, or state for the control is updated. An exception is raised if 
EnableAutoSizing is called when DisableAutoSizing has not been called.
</p>
<p>
EnableAutoSizing decrements the internal counter used to track auto-sizing 
locks. When the counter reaches 0 (zero), the EnableAutoSizing method in the 
Parent control is called (when assigned). Otherwise, the DoAllAutoSize method 
is called to trigger the OnResize event handlers for the control.
</p>
<p>
It is not generally used in application code, but is needed by component 
developers.
</p>
</descr>
<seealso>
<link id="TControl.DisableAutoSizing"/>
<link id="TControl.Parent"/>
<link id="TControl.DoAllAutoSize"/>
</seealso>
</element>

<element name="TControl.UpdateBaseBounds">
<short>
Updates the base bounds for the control; essential if there has been a lot of 
resizing.
</short>
</element>
<element name="TControl.UpdateBaseBounds.StoreBounds">
<short>
<b>True</b> if the BoundsRect is retrieved and used as the value in 
BaseBounds. <b>False</b> if the existing value in BaseBounds is used.
</short>
</element>
<element name="TControl.UpdateBaseBounds.StoreParentClientSize">
<short>
<b>True</b> if the ClientWidth and ClientHeight in the Parent control is 
retrieved and used. <b>False</b> if the existing value in BaseParentClientSize 
is used.
</short>
</element>
<element name="TControl.UpdateBaseBounds.UseLoadedValues">
<short>
<b>True</b> if the client size retrieved during LCL component streaming is 
used in the BaseParentClientSize. <b>False</b> if the calculated value is used.
</short>
</element>

<element name="TControl.BaseBounds">
<short>The rectangle with the designed bounds for the control.</short>
<descr>
<p>
The current Bounds can change, due to scaling, anchoring or auto-sizing.
</p>
</descr>
<seealso>
<link id="TControl.Anchors"/>
<link id="TControl.AnchorSide"/>
<link id="TControl.AutoSize"/>
<link id="TControl.SetBoundsKeepBase"/>
</seealso>
</element>

<element name="TControl.ReadBounds">
<short>
Reflects the Bounds for the Control read during LCL component streaming.
</short>
<descr>
<p>
<var>ReadBounds</var> is a read-only <var>TRect</var> property used when the 
values for the Top, Left, Height and Width properties are set during LCL 
component streaming. When ComponentState contains <var>csLoading</var>, 
changes to these properties cause the new values to be applied to ReadBounds 
prior to calling the SetBounds method. The internal ControlFlags are also 
updated to indicate that the property value has been loaded using LCL 
component streaming.
</p>
</descr>
<seealso>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.Width"/>
<link id="TControl.Height"/>
<link id="TControl.SetBounds"/>
<link id="TControl.BaseBounds"/>
<link id="TControlFlag"/>
</seealso>
</element>

<element name="TControl.BaseParentClientSize">
<short>
The client size for the Parent, for which the BaseBounds are valid.
</short>
<descr>
<p>
BaseBounds and BaseParentClientSize determine the distance to keep from 
Parent's sides, when a side is anchored to the Parent (akLeft...), and the 
Parent is resized.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.WriteLayoutDebugReport">
<short>Used for debugging.</short>
<descr>
<p>
Formats and outputs bounds, alignment, and anchor information for the 
debugger.
</p>
</descr>
</element>
<element name="TControl.WriteLayoutDebugReport.Prefix">
<short>
Prefix value inserted at the start of the first line in the debug report.
</short>
</element>

<element name="TControl.AutoAdjustLayout">
<short>
Applies an automatic adjustment layout policy to the control.
</short>
<descr>
<p>
<var>AutoAdjustLayout</var> can be used to alter PPI settings, scale the 
control, or apply changes to height or width without scaling.
</p>
<p>
<var>AMode</var> indicates the layout policy applied in the method, and the 
actions performed to achieve the task.
</p>
<p>
Scaling factors are calculated (when needed) for both horizontal (X-axis) and 
vertical (Y-axis ) adjustments. The factors may represent changes to the PPI 
settings, or changes in the width for the control.
</p>
<p>
AutoAdjustLayout temporarily disables auto-sizing, and calls 
DoAutoAdjustLayout to apply the scaling factors or size changes.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.AutoAdjustLayout.AMode">
<short>
Layout policy applied in the method. Controls the actions performed to scale 
and / or position the control.
</short>
</element>
<element name="TControl.AutoAdjustLayout.AFromPPI">
<short>
Design-time Pixels per Inch setting. Used to derive scaling factors applied in 
the method.
</short>
</element>
<element name="TControl.AutoAdjustLayout.AToPPI">
<short>
Run-time Pixels per Inch setting for the current monitor. Used to derive 
scaling factors applied in the method.
</short>
</element>
<element name="TControl.AutoAdjustLayout.AOldFormWidth">
<short>
Form width prior to applying the auto-adjustment policy. Used to calculate an 
x-axis scaling factor applied in the method.
</short>
</element>
<element name="TControl.AutoAdjustLayout.ANewFormWidth">
<short>
Form width after the auto-adjustment policy is applied. Used to calculate an 
x-axis scaling factor applied in the method.
</short>
</element>

<element name="TControl.ShouldAutoAdjust">
<short>
Indicates whether the height and/or width for a control can be automatically 
adjusted.
</short>
<descr>
<p>
In TControl, both AWidth and AHeight are set to <b>True</b> when the AutoSize 
property has not been enabled.
</p>
</descr>
<seealso>
<link id="TControl.AutoSize"/>
</seealso>
</element>
<element name="TControl.ShouldAutoAdjust.AWidth">
<short><b>True</b> if the width can be auto-adjusted.</short>
</element>
<element name="TControl.ShouldAutoAdjust.AHeight">
<short><b>True</b> if the height can be auto-adjusted.</short>
</element>

<element name="TControl.FixDesignFontsPPI">
<short>
Corrects the font size for High-DPI-aware applications.
</short>
<descr>
<p>
FixDesignFontsPPI is a method used to adjust the font size when the 
design-time PPI (Pixels per Inch) setting differs from the run-time PPI 
setting for the font in the control. It calls DoFixDesignFontPPI to restore 
the value in ADesignTimePPI to the Font reference passed as an argument to to 
the method. The font height is scaled using the factor represented by 
TFont.PixelsPerInch/ADesignTimePPI.
</p>
<p>
This method does not trigger a CM_PARENTFONTCHANGED message in the Parent 
control.
</p>
<p>
In TControl, this action is performed for the Font property. In descendent 
class, additional properties with a font reference may also be adjusted using 
the method.
</p>
<p>
FixDesignFontsPPI is called when scaling is enabled, and the Form which hosts 
the control calls its Loaded method when LCL streaming is completed.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.FixDesignFontsPPI.ADesignTimePPI">
<short>Design-time PPI setting applied for the font size adjustment.</short>
</element>

<element name="TControl.ScaleFontsPPI">
<short>Resizes a font to the specified Pixels per Inch setting.</short>
<descr>
<p>
ScaleFontsPPI is a method used to resize a font in the control to the 
specified display density (Pixels per Inch) using the scaling factor in 
AProportion (when needed).
</p>
<p>
A font may need to be scaled when the run-time PPI setting for the screen 
differs from the design-time value applied to the font. If the font height is 
not assigned at run-time, its height is set to the value in 
TFont.PixelsPerInch / Screen.PixelsPerInch.
</p>
<p>
When AToPPI has a positive non-zero value, it is stored in the 
TFont.PixelsPerInch property for the font. Otherwise, the existing 
TFont.PixelsPerInch value is adjusted using the scaling factor in AProportion.
</p>
<p>
ScaleFontsPPI may be overridden in descendent controls to call the method for 
its child controls.
</p>
<p>
ScaleFontsPPI is called form the AutoAdjustLayout method.
</p>
</descr>
<seealso>
<link id="TControl.AutoAdjustLayout"/>
<link id="TControl.ShouldAutoAdjust"/>
</seealso>
</element>
<element name="TControl.ScaleFontsPPI.AToPPI">
<short>PPI setting to apply to the font.</short>
</element>
<element name="TControl.ScaleFontsPPI.AProportion">
<short>Scaling factor applied to the font height.</short>
</element>

<element name="TControl.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
Create is the overridden constructor for the class instance. Create calls the 
inherited constructor using TheOwner as the owner for the class instance. 
Resources are allocated in the method for members in the class instance, and 
the default values are set for the following properties:
</p>
<ul>
<li>Align</li>
<li>Anchors</li>
<li>BaseBounds</li>
<li>CaptureMouseButtons</li>
<li>Color</li>
<li>ControlStyle</li>
<li>Cursor</li>
<li>DesktopFont</li>
<li>DragCursor</li>
<li>Enabled</li>
<li>FloatingDockSiteClass</li>
<li>Font</li>
<li>HelpType</li>
<li>IsControl</li>
<li>ParentBidiMode</li>
<li>ParentColor</li>
<li>ParentFont</li>
<li>ParentShowHint</li>
<li>Visible</li>
<li>WindowProc</li>
</ul>
<remark>
Create ensures that auto-sizing is disabled until the class instance is fully 
realized. Auto-sizing is re-enabled on exit from the method.
</remark>
</descr>
<seealso>
<link id="TControl.Destroy"/>
</seealso>
</element>
<element name="TControl.Create.TheOwner">
<short>The owning component.</short>
</element>

<element name="TControl.Destroy">
<short>Removes the control from its Parent.</short>
<descr>
<p>
Detaches the control from Parent, removes graphics, frees memory and 
Operating System handles, pointers etc.
</p>
</descr>
<seealso>
<link id="#lcl.lclclasses.TLCLComponent.Destroy">TLCLComponent.Destroy</link>
<link id="#rtl.classes.TComponent.Destroy">TComponent.Destroy</link>
</seealso>
</element>

<element name="TControl.BeforeDestruction">
<short>
Performs notifications before the control is destroyed.
</short>
<descr>
<p>
BeforeDestruction is a method which performs notifications when an object 
instance is about to be freed. It allows tasks to be performed which maintain 
a persistent object instance and its observers before it is destroyed.
</p>
<p>
BeforeDestruction is an overridden method in TControl, and calls the 
inherited method on entry to ensure that csDestroying is included in the 
ComponentState property for the control and any of its child components. It 
extends the inherited method by calling DoCallNotifyHandler for any handler 
routines using the chtOnBeforeDestruction type.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TComponent.BeforeDestruction">TComponent.BeforeDestruction</link>
<link id="#rtl.classes.TComponent.Destroying">TComponent.Destroying</link>
</seealso>
</element>

<element name="TControl.EditingDone">
<short>Signals the <var>OnEditingDone</var> event handler.</short>
<descr>
<p>
Called when user has finished editing using the control. This procedure can 
be used by data links to commit the changes.
</p>
<p>For example:</p>
<ul>
<li>When focus switches to another control (default).</li>
<li>When user selected another item.</li>
</ul>
<p>
Each control class can determine which events cause the value(s) to be 
committed.
</p>
</descr>
</element>

<element name="TControl.ExecuteDefaultAction">
<short>
Called when the Return key is pressed, signifying the default action.
</short>
<descr>
<p>
<var>ExecuteDefaultAction</var> has an empty implementation in 
<var>TControl</var>. It can be overridden in descendent classes to perform 
any actions needed for the class type.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.ExecuteCancelAction">
<short>
Called when the Escape key is pressed or the Cancel button is clicked.
</short>
<descr>
<p>
<var>ExecuteCancelAction</var> has an empty implementation in 
<var>TControl</var>. It can be overridden in descendent classes to perform 
any actions needed for the class type.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.BeginDrag">
<short>
Starts a drag operation for the control (programmatically).
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.BeginDrag.Immediate">
<short>If <b>False</b>, start dragging only after the mouse has moved.</short>
</element>
<element name="TControl.BeginDrag.Threshold">
<short>
Minimum mouse movement before delayed dragging starts (in pixels); -1 causes 
the DragManager default to be used. Ignored when Immediate is set to 
<b>True</b>.
</short>
</element>

<element name="TControl.EndDrag">
<short>
Ends a drag operation by notifying the drag manager.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.EndDrag.Drop">
<short>
<b>True</b> when a drag and drop operation is being completed. <b>False</b> 
if a drag and dock operation is ending.
</short>
</element>

<element name="TControl.BringToFront">
<short>Brings the control in front of other sibling controls.</short>
<descr>
<p>
<var>BringToFront</var> is a method used to move the control to the top of 
the Z-Order for its sibling controls. BringToFront calls SetZOrder to change 
the display order for controls which share a common Parent. BringToFront has 
no effect when Parent has not been assigned.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TControl.SetZOrder"/>
<link id="TWinControl.SetChildZPosition"/>
</seealso>
</element>

<element name="TControl.HasParent">
<short>
Returns <b>True</b> if there is a Parent component responsible for streaming.
</short>
<descr>
<p>
HasParent is called during streaming to decide if a component has to be 
streamed by its owner or Parent.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TComponent.HasParent">TComponent.HasParent</link>
</seealso>
</element>
<element name="TControl.HasParent.Result">
<short><b>True</b> if there is a Parent.</short>
</element>

<element name="TControl.GetParentComponent">
<short>Returns the value in the Parent property.</short>
<descr>
<p>
<var>GetParentComponent</var> gets the component / control which has the 
current class instance in its <var>Components</var> property. 
GetParentComponent is an overridden method in TControl, and re-implements the 
inherited method. It uses the value in the Parent property as the return 
value for the method. The inherited method always returns <b>Nil</b>.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="#rtl.classes.TComponent.Components">TComponent.Components</link>
</seealso>
</element>
<element name="TControl.GetParentComponent.Result">
<short>Value in the Parent property.</short>
</element>

<element name="TControl.IsParentOf">
<short>Determines whether this control is a parent of AControl.</short>
<descr>
<p>
<var>IsParentOf</var> is a <var>Boolean</var> function used to determine if 
the current control instance is ultimately a parent of the control specified 
in AControl. No actions are performed in the method when AControl has not 
been assigned (<b>Nil</b>), and the return value is set to <b>False</b>.
</p>
<p>
IsParentOf visits each control in the Parent control hierarchy, and returns 
<b>True</b> if the current class instance (Self) is found in the tree. The 
return value is <b>False</b> if the current control instance is not found in 
the Parent control tree.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
</seealso>
</element>
<element name="TControl.IsParentOf.Result">
<short><b>True</b> if this control is a parent of AControl.</short>
</element>
<element name="TControl.IsParentOf.AControl">
<short>The initial control examined in the parent control hierarchy.</short>
</element>

<element name="TControl.GetTopParent">
<short>
Finds the control that is the top-most Parent in the control hierarchy.
</short>
<descr>
<p>
GetTopParent is a TControl function used to get the control which is the 
top-most or initial Parent in the control hierarchy.
</p>
<p>
GetTopParent visits each of the control instances in the Parent property. The 
return value is set to control where Parent is unassigned (<b>Nil</b>). The 
return value is the current control instance (Self) if Parent has not been 
assigned.
</p>
<p>
GetTopParent is used in methods like ChangeBounds where the parent handles 
layout or sizing for its child controls. The method is also used in 
descendent classes, like TWinControl, when messages are handled which 
resized, move, or otherwise reposition the windowed control.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.GetTopParent.Result">
<short>
TControl instance which is the top-most Parent in the control hierarchy, or 
Self.
</short>
</element>

<element name="TControl.FindSubComponent">
<short>
Finds the sub-component with the specified name in the Components property.
</short>
<descr>
<p>
<var>FindSubComponent</var> is a <var>TComponent</var> function used to get 
the sub-component with the name specified in AName. FindSubComponent is 
similar to TComponent.FindComponent, but accepts a prefixed component name in 
AName. For example: 'LabeledEdit1.EditLabel'.
</p>
<p>
FindSubComponent separates the value in AName into the owner and 
sub-component names. When a prefix is used, the FindComponent method is 
called to locate the TComponent instance with the owner name. Its 
FindComponent method is called to get the component with the sub-component 
name that is used in the return value. If a prefix is not used, the initial 
component is used as the return value.
</p>
<p>
The return value is <b>Nil</b> if a component is not found with the specified 
name.
</p>
</descr>
<seealso>
<link id="#rtl.classes.TComponent.FindComponent">TComponent.FindComponent</link>
<link id="#rtl.classes.TComponent.Components">TComponent.Components</link>
</seealso>
</element>
<element name="TControl.FindSubComponent.Result">
<short>
The component with the specified name, or <b>Nil</b> when not found.
</short>
</element>
<element name="TControl.FindSubComponent.AName">
<short>Parentage/path for the sub-component to retrieve in the method.</short>
</element>

<element name="TControl.IsVisible">
<short>
Gets the effective visibility for the control and all of its Parent controls.
</short>
<descr>
<p>
<var>IsVisible</var> calls <var>IsControlVisible</var> to determine if the 
control has its Visible property set to <b>True</b>. At design-time, 
ControlStyle is also checked to ensure that csNoDesignVisible is not used in 
the style flags. Each of the Parent controls in the hierarchy call their 
IsVisible method to determine the return value for the method.
</p>
<p>
Use IsEnabled to get the effective enabled state for the control and all of 
its Parent controls.
</p>
</descr>
<seealso>
<link id="TControl.Visible"/>
<link id="TControl.Parent"/>
<link id="TControl.IsControlVisible"/>
<link id="TControl.IsEnabled"/>
</seealso>
</element>
<element name="TControl.IsVisible.Result">
<short>
<b>True</b> when the control and and all Parent controls are Visible.
</short>
</element>

<element name="TControl.IsControlVisible">
<short>
<b>True</b> if the control is Visible, or is in design mode.
</short>
<descr>
<p>
The return value is <b>True</b> when the Visible property is set to 
<b>True</b>. The value is <b>False</b> at design-time if the ControlStyle 
property includes the value csNoDesignVisible. IsControlVisible does not 
check the visibility for parent controls in the control hierarchy.
</p>
<p>
Use IsVisible to consider the visibility for any Parent controls.
</p>
</descr>
<seealso>
<link id="TControl.Visible"/>
<link id="TControl.IsVisible"/>
<link id="TControl.Parent"/>
</seealso>
</element>
<element name="TControl.IsControlVisible.Result">
<short>
<b>True</b> if the Visible property is set and the control is not disabled on 
the design surface at design-time.
</short>
</element>

<element name="TControl.IsEnabled">
<short>
Returns <b>True</b> if both the control and all of its Parent controls are 
Enabled.
</short>
<descr>
<p>
Returns <b>True</b> when both the control instance and its parent control 
hierarchy are enabled. Used internally by TGraphicControls for painting and 
various states during run-time.
</p>
</descr>
</element>
<element name="TControl.IsEnabled.Result">
<short>
<b>True</b> when the control and all Parent controls are enabled.
</short>
</element>

<element name="TControl.IsParentColor">
<short>
Provides access to the value in the protected ParentColor property.
</short>
<descr>
<p>
Returns the value for the protected ParentColor property. Used in places 
where we need to check ParentColor property from within the TControl. Needed 
for widgetset classes.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.IsParentColor.Result">
<short><b>True</b> when ParentColor is set to <b>True</b>.</short>
</element>

<element name="TControl.IsParentFont">
<short>
Provides access to the value in the protected ParentFont property.
</short>
<descr>
<p>
Checks the value for the protected ParentFont property. Used in places where 
we need to check ParentFont from within TControl. Needed for widgetset 
classes.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.IsParentFont.Result">
<short><b>True</b> when ParentFont is set to <b>True</b>.</short>
</element>

<element name="TControl.FormIsUpdating">
<short><b>True</b> if the form is being updated.</short>
<descr>
<p>
The return value is <b>True</b> when a value has been assigned to Parent, and 
its FormIsUpdating method returns <b>True</b>. This causes all assigned 
Parent controls in the hierarchy to be examined to determine the return value.
</p>
<p>
Eventually, one of the Parent controls will be the TCustomForm instance which 
hosts all of the controls. It sets the return value to <b>True</b> when its 
internal update counter has a non-zero value. This occurs when the form has 
called BeginFormUpdate, but has not called EndFormUpdate to complete an 
update.
</p>
</descr>
<seealso>
<link id="#lcl.forms.TCustomForm.FormIsUpdating">TCustomForm.FormIsUpdating</link>
<link id="#lcl.forms.TCustomForm.BeginFormUpdate">TCustomForm.BeginFormUpdate</link>
<link id="#lcl.forms.TCustomForm.EndFormUpdate">TCustomForm.EndFormUpdate</link>
</seealso>
</element>
<element name="TControl.FormIsUpdating.Result">
<short><b>True</b> if the form is being updated.</short>
</element>

<element name="TControl.IsProcessingPaintMsg">
<short><b>True</b> while painting the control.</short>
<descr>
<p>
As the name implies, the cfProcessingWMPaint flag in FControlFlags is set 
while a LM_PAINT message is processed, and IsProcessingPaintMsg checks this 
flag.
</p>
</descr>
</element>
<element name="TControl.IsProcessingPaintMsg.Result">
<short>
<b>True</b> when the control flags contain a value for paint methods.
</short>
</element>

<element name="TControl.Hide">
<short>
Hides the control by setting the Visible property to <b>False</b>.
</short>
<seealso>
<link id="TControl.Visible"/>
<link id="TControl.Show"/>
</seealso>
</element>

<element name="TControl.Refresh">
<short>Causes the control to be redrawn.</short>
<descr>
<p>
Calls the Repaint method to either draw the clipping rectangle for the 
control to the handle in the Parent, or invalidate the control area for the 
next paint operation that occurs when the Parent controls are Visible.
</p>
</descr>
<seealso>
<link id="TControl.Repaint"/>
</seealso>
</element>

<element name="TControl.Repaint">
<short>
Immediately redraws the control when visible, bypassing the message queue.
</short>
<descr>
<p>
Repaint is a method called redraw the control when it is visible. No actions 
are performed in the method when:
</p>
<ul>
<li>Parent has not been assigned.</li>
<li>Parent does not have a valid handle.</li>
<li>ComponentState contains the value csDestroying.</li>
<li>The effective visibility from IsVisible is <b>False</b>.</li>
</ul>
<p>
When the control is Parented, it is redrawn using the style indicated in 
ControlStyle. When csOpaque is included, a device context is retrieved and 
the PaintControl method is called for the clipping rectangle in the Parent 
control. When csOpaque is omitted, the Invalidate and Update methods are 
called to request the control to redrawn.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TControl.IsVisible"/>
<link id="TControl.ControlStyle"/>
<link id="TControl.Invalidate"/>
<link id="TControl.Update"/>
<link id="TWinControl.PaintControls"/>
<link id="#rtl.classes.TComponent.ComponentState">TComponent.ComponentState</link>
</seealso>
</element>

<element name="TControl.Invalidate">
<short>
Causes a delayed Repaint of the control by marking its visible area of the 
control as invalid.
</short>
<descr>
<p>
Calls the <var>InvalidateControl</var> method to invalidate the bounds 
rectangle for the control using the clipping rectangle for the Parent. The 
control is redrawn when there are no pending messages in the message queue.
</p>
</descr>
<seealso>
<link id="TControl.InvalidateControl"/>
<link id="TControl.IsVisible"/>
<link id="TControl.ControlStyle"/>
<link id="TControl.Parent"/>
</seealso>
</element>

<element name="TControl.CheckChildClassAllowed">
<short>Returns <b>True</b> if the class is allowed for child controls.</short>
<descr>
<p>
Only few controls restrict the class of acceptable child controls. E.g. a 
PageControl only accepts TTabSheet descendants as children.
</p>
</descr>
<errors>
An EInvalidOperation can be generated (see ExceptionOnInvalid).
</errors>
</element>
<element name="TControl.CheckChildClassAllowed.Result">
<short><b>True</b> if the class is allowed for child controls.</short>
</element>
<element name="TControl.CheckChildClassAllowed.ChildClass">
<short>The class of the intended child control.</short>
</element>
<element name="TControl.CheckChildClassAllowed.ExceptionOnInvalid">
<short>
When <b>True</b>, raise an exception when the class is not allowed.
</short>
</element>

<element name="TControl.CheckNewParent">
<short>Checks if this control can become a child of AParent.</short>
<descr>
<p>
This check is performed during SetParent. It calls CheckChildClassAllowed and 
whether AParent is the current class instance (Self).
</p>
</descr>
<errors>
An EInvalidOperation occurs when any test fails.
</errors>
</element>
<element name="TControl.CheckNewParent.AParent">
<short>The new Parent for this control.</short>
</element>

<element name="TControl.SendToBack">
<short>Moves all sibling controls in front of this control.</short>
<descr>
<p>
Use <var>SendToBack</var> to move the control beneath all other sibling 
controls on the Parent. Only those portions of the control not covered by 
other controls will be visible.
</p>
<p>
Calls SetZOrder to move the position for the control on the z-axis (depth) to 
the maximum Integer value for the platform.
</p>
<p>
Use BringToFront to move a control to the top of the Z-axis on the Parent 
control.
</p>
<p>
Use SetChildZPosition in TWinControl to move a child control to a specific 
position on the Z-axis where 0 is the top and MaxInt is the bottom of the 
Z-order.
</p>
</descr>
<seealso>
<link id="TControl.BringToFront"/>
<link id="TWinControl.SetChildZPosition"/>
</seealso>
</element>

<element name="TControl.SetTempCursor">
<short>
Changes the cursor shape temporarily, preserving the original <link 
id="TControl.Cursor"/>
</short>
<descr>
<p>
<var>SetTempCursor</var> is a method used to temporarily change the cursor 
shape to the <var>TCursor</var> value specified in <var>Value</var>. 
SetTempCursor calls the overridden method in the <var>Parent</var> control to 
apply the cursor shape in Value.
</p>
<p>
No actions are performed in the method when Parent has not been assigned.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TWinControl.SetTempCursor"/>
<link id="TCursor"/>
</seealso>
</element>
<element name="TControl.SetTempCursor.Value">
<short>The temporary cursor shape for the control.</short>
</element>

<element name="TControl.UpdateRolesForForm">
<short>
Internal method called by a Form when its DefaultControl or CancelControl has 
changed.
</short>
<descr>
<p>
This method is overridden in TCustomButton, where it updates the Cancel and 
Default properties for the control.
</p>
</descr>
<seealso>
<link id="TControl.ActiveDefaultControlChanged"/>
</seealso>
</element>

<element name="TControl.ActiveDefaultControlChanged">
<short>
Notification of a changed active DefaultControl of a form.
</short>
<descr>
<p>
When the user pressed ENTER in a form, its DefaultControl will receive a 
Click event.
</p>
</descr>
<errors>
Currently NewControl can be <b>Nil</b>, even if it should not be.
</errors>
</element>
<element name="TControl.ActiveDefaultControlChanged.NewControl">
<short>The new DefaultControl.</short>
</element>

<element name="TControl.GetTextBuf">
<short>
Copy the <link id="TControl.Text">Text</link> property into Buffer.
</short>
<descr>
<p>This method only exists for Delphi compatibility.
</p>
<p>Don't use or override it, unless really necessary.
</p>
</descr>
<seealso>
<link id="TControl.RealGetText"/>
</seealso>
</element>
<element name="TControl.GetTextBuf.Result">
<short>Length of the copied text.</short>
</element>
<element name="TControl.GetTextBuf.Buffer">
<short>Pointer to the buffer receiving the string.</short>
</element>
<element name="TControl.GetTextBuf.BufSize">
<short>Length of the buffer.</short>
</element>

<element name="TControl.GetTextLen">
<short>The length of the Text for the control.</short>
<descr>
<p>
In TControl, the value indicates the size for the Caption property.
Descendent classes may use a different a different property as the basis for 
the return value.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.GetTextLen.Result">
<short>
Length of the text for the control.
</short>
</element>

<element name="TControl.SetTextBuf">
<short>
Updates the <link id="TControl.Text">Text</link> property from a PChar buffer.
</short>
<descr>
<p>This method only exists for Delphi compatibility.</p>
<p>Don't use or override it, unless really necessary.</p>
</descr>
<seealso>
<link id="TControl.RealSetText"/>
</seealso>
</element>
<element name="TControl.SetTextBuf.Buffer">
<short>Pointer to the buffer containing the zero-terminated text.</short>
</element>

<element name="TControl.Perform">
<short>
Calls a message handler directly, bypassing the message queue.
</short>
<descr>
<p>
<var>Perform</var> is a method used to pass a message to the processing loop 
for the control.
</p>
<p>
Values in the Msg, WParam, and LParam arguments are stored in a 
<var>TLMessage</var> instance and passed as an argument to the routine in the 
<var>WindowProc</var> property. The return value is the <var>LRESULT</var> 
returned from the WindowProc routine.
</p>
</descr>
<seealso>
<link id="TControl.WindowProc"/>
<link id="TWndMethod"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
<link id="#lcl.lcltype.LRESULT">LRESULT</link>
</seealso>
</element>
<element name="TControl.Perform.Result">
<short>Result value from the WindowProc routine.</short>
</element>
<element name="TControl.Perform.Msg">
<short>
Control message constant for the message executed in the method.
</short>
</element>
<element name="TControl.Perform.WParam">
<short>
Parameter with a handle or Integer value (not necessarily 16-bits any more).
</short>
</element>
<element name="TControl.Perform.LParam">
<short>
Parameter with a Pointer to its value (not necessarily 32-bits any more).
</short>
</element>

<element name="TControl.ScreenToClient">
<short>
Converts absolute screen coordinates into client-relative coordinates.
</short>
<descr>
<p>
The <var>APoint</var> argument contains the screen coordinates which are 
converted to client-relative coordinates in the method. The X member has the 
horizontal coordinate, and the Y member has the vertical coordinate.
</p>
<p>
The return value is a <var>TPoint</var> type which contains the coordinates 
from APoint with the X and Y members decremented by the corresponding values 
found in the ClientOrigin for the control.
</p>
<remark>
Accessing the ClientOrigin property raises an EInvalidOperation exception if 
Parent has not been assigned for the control.
</remark>
<p>
ScreenToClient is used in the implementation of methods like ClientToParent, 
ParentToClient, and GetMousePosFromMessage. It is also used to convert mouse 
coordinates during drag and drop, docking, and context menu operations.
</p>
<p>
Use ScreenToControl to convert absolute screen coordinate to control-relative 
values.
</p>
<p>
Use ClientToScreen to convert client-relative coordinates to absolute screen 
coordinates. Use ControlToScreen to convert the coordinates in the control to 
absolute screen coordinates.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TControl.ClientOrigin"/>
<link id="TControl.ScreenToControl"/>
<link id="TControl.ClientToScreen"/>
<link id="TControl.ControlToScreen"/>
<link id="#rtl.types.TPoint">TPoint</link>
</seealso>
</element>
<element name="TControl.ScreenToClient.Result">
<short>
TPoint instance with the client-relative coordinates for the specified screen 
coordinates.
</short>
</element>
<element name="TControl.ScreenToClient.APoint">
<short>
TPoint instance with the screen coordinates converted in the method.
</short>
</element>

<element name="TControl.ClientToScreen">
<short>
Converts client-relative coordinates to absolute screen coordinates.
</short>
<seealso>
<link id="TControl.ScreenToClient"/>
<link id="TControl.ClientOrigin"/>
</seealso>
</element>
<element name="TControl.ClientToScreen.Result">
<short>
TPoint instance with the screen coordinates for the specified client 
coordinates.
</short>
</element>
<element name="TControl.ClientToScreen.APoint">
<short>
TPoint instance with the client-relative coordinates converted in the method.
</short>
</element>

<element name="TControl.ScreenToControl">
<short>
Converts absolute screen coordinates to control-relative coordinates.
</short>
<seealso>
<link id="TControl.ControlOrigin"/>
<link id="TControl.ControlToScreen"/>
<link id="TControl.ScreenToClient"/>
<link id="TControl.ClientToScreen"/>
</seealso>
</element>
<element name="TControl.ScreenToControl.Result">
<short>
TPoint instance with the client coordinates relative to its Parent control.
</short>
</element>
<element name="TControl.ScreenToControl.APoint">
<short>
Screen coordinates converted to client coordinates in the method.
</short>
</element>

<element name="TControl.ControlToScreen">
<short>
Converts control-relative coordinates to absolute screen coordinates.
</short>
<descr>
<p>
Screen coordinates in the return value are determined by adding the values in 
APoint and the ClientOrigin for the control.
</p>
</descr>
<seealso>
<link id="TControl.ControlOrigin"/>
<link id="TControl.ScreenToControl"/>
<link id="TControl.ScreenToClient"/>
<link id="TControl.ClientToScreen"/>
</seealso>
</element>
<element name="TControl.ControlToScreen.Result">
<short>
TPoint instance with the Screen coordinates for the specified control coordinates.
</short>
</element>
<element name="TControl.ControlToScreen.APoint">
<short>
TPoint instance with the control-relative coordinates converted in the 
method.
</short>
</element>

<element name="TControl.ClientToParent">
<short>
Converts the specified client coordinates to the screen coordinates for the 
specified parent control.
</short>
<descr>
<p>
<var>ClientToParent</var> is a <var>TPoint</var> function used to convert the 
client-relative coordinates specified in <var>Point</var> to the screen 
coordinates for the parent control in <var>AParent</var>. If AParent is 
unassigned (<b>Nil</b>), the Parent property for the control is used in the 
method.
</p>
<p>
ClientToParent calls the IsParentOf method in AParent to determine if the 
control is a child control for AParent. An EInvalidOperation exception is 
raised if the return value from IsParentOf is <b>False</b>.
</p>
<p>
ClientToParent calls ClientToScreen to get the absolute screen coordinates 
for the values in Point. The return value is the TPoint instance returned by 
converting the client coordinates to screen coordinates, and asking the 
parent control to convert the values back to client-relative coordinates for 
the parent control.
</p>
<p>
ClientToParent is used, for instance, in the 
TScrollingWinControl.ScrollInView method.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.ClientToParent.Result">
<short>
TPoint instance with the client coordinates adjusted to the parent control.
</short>
</element>
<element name="TControl.ClientToParent.Point">
<short>TPoint instance with the client coordinates for the control.</short>
</element>
<element name="TControl.ClientToParent.AParent">
<short>Parent control with the bounds for the adjusted coordinates.</short>
</element>

<element name="TControl.ParentToClient">
<short>
Converts the specified client coordinates on a parent control to the client 
coordinates for the control instance.
</short>
<descr>
<p>
<var>Point</var> contains the client coordinates relative the parent control 
<var>AParent</var>. If AParent is not assigned (<b>Nil</b>), the value in the 
<var>Parent</var> property is used as the value for the argument.
</p>
<p>
ParentToClient calls the <var>IsParentOf</var> method in AParent to determine 
if the current control is hosted on AParent. An <var>EInvalidOperation</var> 
exception is raised if the IsParentOf method returns <b>False</b>.
</p>
<p>
The return value is a <var>TPoint</var> instance with client coordinates for 
the control relative to the client coordinates on AParent.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.ParentToClient.Result">
<short>
TPoint instance with the client coordinates relative the client origin in a 
parent control.
</short>
</element>
<element name="TControl.ParentToClient.Point">
<short>
TPoint instance with the coordinates examined and adjusted in the method.
</short>
</element>
<element name="TControl.ParentToClient.AParent">
<short>
Parent control with the origin used to adjust the client coordinates.
</short>
</element>

<element name="TControl.GetChildrenRect">
<short>Get the visible part of a possibly scrolled client area.</short>
<descr>
<p>
If <var>Scrolled</var> is <b>False</b>, the ScrollOffset is ignored, so that 
the ClientRect is returned. Returns the Client rectangle relative to the left 
and top for the control. If Scrolled is <b>True</b>, the rectangle is moved 
by the current scrolling values (for an example see TScrollingWincontrol).
</p>
</descr>
</element>
<element name="TControl.GetChildrenRect.Result">
<short>The visible part of the client area.</short>
</element>
<element name="TControl.GetChildrenRect.Scrolled">
<short><b>True</b> forces scrolling taken into account.</short>
</element>

<element name="TControl.Show">
<short>
Makes the control visible by setting Visible to <b>True</b>.
</short>
<descr>
<p>
Show calls the ShowControl method in the Parent control (when assigned) to 
ensure that the control instance is visible on the Parent control. Show sets 
the value in the Visible property to <b>True</b>. The value in the Visible 
property is not changed at design-time or when csNoDesignVisible has not been 
included in the ControlStyle property.
</p>
<p>
Use the Hide method to hide the control on its Parent.
</p>
<p>
Use ShowControl to display a specific sibling control on the Parent.
</p>
</descr>
<seealso>
<link id="TControl.Visible"/>
<link id="TControl.Hide"/>
<link id="TWinControl.ShowControl"/>
</seealso>
</element>

<element name="TControl.Update">
<short>Redraws invalidated parts of the control immediately.</short>
<descr>
<p>
<var>Update</var> calls the Update method in the Parent control to refresh 
the window where the control is hosted. No actions are performed in the 
method when Parent has not been assigned.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TWinControl.Update"/>
<link id="TWinControl.Handle"/>
</seealso>
</element>

<element name="TControl.HandleObjectShouldBeVisible">
<short>
<b>True</b> if the control should be visible, unless it's being destroyed.
</short>
<descr>
<p>
HandleObjectShouldBeVisible is a Boolean function which indicates if the 
control requires a valid handle in its widgetset class instance and should be 
visible. The return value is set to <b>True</b> when the following conditions 
are satisfied:
</p>
<ul>
<li>
Neither the control nor its Handle is being destroyed.
</li>
<li>
IsControlVisible returns <b>True</b> indicating the control is both Visible 
and not disabled on the form designer at design-time.
</li>
<li>
Parent has been assigned and its HandleObjectShouldBeVisible method returns 
<b>True</b>.
</li>
</ul>
<p>
HandleObjectShouldBeVisible is used frequently in widgetset class methods, 
and indicates that actions like allocating or freeing a handle should be 
performed. It determined the value for the Visible property in the widget. It 
also indicates whether the actions in the class method can be performed, or 
should be ignored.
</p>
</descr>
<seealso>
<link id="TControl.IsVisible"/>
<link id="TControl.ControlState"/>
<link id="TControl.Parent"/>
<link id="#rtl.classes.TComponent.ComponentState">TComponent.ComponentState</link>
</seealso>
</element>
<element name="TControl.HandleObjectShouldBeVisible.Result">
<short>
<b>True</b> if the control is visible and needs a handle object.
</short>
</element>

<element name="TControl.ParentDestroyingHandle">
<short>
Returns <b>True</b> if any parent control is destroying its Handle (or handles 
for its children).
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ParentDestroyingHandle.Result">
<short>
Returns <b>True</b> if any parent control is destroying its Handle (or handles 
for its children).
</short>
</element>

<element name="TControl.ParentHandlesAllocated">
<short>
Returns <b>True</b> if all Parents have allocated handles, and are not being 
destroyed.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.ParentHandlesAllocated.Result">
<short>
Returns <b>True</b> if all Parents have allocated handles, and are not being 
destroyed.
</short>
</element>

<element name="TControl.InitiateAction">
<short>
Updates the action associated with the control using its action link.
</short>
<descr>
<p>
Calls the Update method in ActionLink to signal the OnUpdate event handler 
for the linked TBasicAction instance. No actions are performed in the method 
when ActionLink has not been assigned.
</p>
</descr>
<seealso>
<link id="TControl.ActionLink"/>
<link id="#rtl.classes.TBasicActionLink.Update">TBasicActionLink.Update</link>
<link id="#rtl.classes.TBasicAction.OnUpdate">TBasicActionLink.OnUpdate</link>
</seealso>
</element>

<element name="TControl.ShowHelp">
<short>Displays the help associated with the control.</short>
<descr>
<p>
<var>ShowHelp</var> is a method used to display help for the control. Values 
in HelpType, HelpContext, and HelpKeyword are used to determine which method 
is called in the Application singleton to display the help content.
</p>
<dl>
<dt>HelpType</dt>
<dd>
When set to htContext, the HelpContext method is called for the value in the 
HelpContext property.
</dd>
<dt>HelpKeyword</dt>
<dd>
A non-empty value causes the HelpKeyword method to be called using the value 
in the HelpKeyword property.
</dd>
<dt>Default Action</dt>
<dd>
Calls the ShowHelp method in the Parent control when none of the other 
conditions are satisfied.
</dd>
</dl>
<p>
ShowHelp is called from methods in the TApplication instance. It occurs 
when the F1 key is pressed when the control has focus, or when its 
ShowHelpForObject method is called for a specific control instance.
</p>
<p>
Use the HelpFile property, found on the parent form or in a 
TApplicationProperties instance, to set the help file with the content 
displayed in the method.
</p>
</descr>
<seealso>
<link id="TControl.HelpType"/>
<link id="TControl.HelpContext"/>
<link id="TControl.HelpKeyword"/>
<link id="#lcl.forms.TApplication.HelpContext">TApplication.HelpContext</link>
<link id="#lcl.forms.TApplication.HelpKeyword">TApplication.HelpKeyword</link>
<link id="#lcl.forms.TApplication.ShowHelpForObject">TApplication.ShowHelpForObject</link>
<link id="#lcl.forms.TApplicationProperties.HelpFile">TApplicationProperties.HelpFile</link>
<link id="#lcl.forms.TCustomForm.HelpFile">TCustomForm.HelpFile</link>
</seealso>
</element>

<element name="TControl.HasHelp">
<short>
Indicates whether a HelpKeyword or HelpContext identifier is assigned for the 
control.
</short>
<descr/>
<seealso>
<link id="TControl.HelpType"/>
<link id="TControl.HelpContext"/>
<link id="TControl.HelpKeyword"/>
</seealso>
</element>
<element name="TControl.HasHelp.Result">
<short>
<b>True</b> when a HelpKeyword or HelpContext has been assigned.
</short>
</element>

<element name="TControl.RemoveAllHandlersOfObject">
<short>
Removes all control handler types for the specified object.
</short>
<descr>
<p>
<var>RemoveAllHandlersOfObject</var> is an overridden method in 
<var>TControl</var> used to remove all handler routines for the specified 
object instance found in the internal storage for the control handler types.
</p>
<p>
<var>AnObject</var> is the control associated with handler routines located 
and removed in the method. It allows handler routines added at run-time to be 
removed prior to destroying the object instance in AnObject.
</p>
<p>
RemoveAllHandlersOfObject visits each of the <var>TMethodList</var> instances 
used for each of the <var>TControlHandlerType</var> values. It calls the 
RemoveAllMethodsOfObject method in the TMethodList instance to remove 
associations where AnObject is the target.
</p>
<p>
The method can be overridden in descendent classes to provide additional 
functionality needed for derived controls.
</p>
</descr>
<seealso>
<link id="TControl.AddHandler"/>
<link id="TControlHandlerType"/>
<link id="#lazutils.lazmethodlist.TMethodList">TMethodList</link>
<link id="#lcl.lclclasses.TLCLComponent.RemoveAllHandlersOfObject">TLCLComponent.RemoveAllHandlersOfObject</link>
</seealso>
</element>
<element name="TControl.RemoveAllHandlersOfObject.AnObject">
<short>
Object (TControl) associated with the handler routine removed in the method.
</short>
</element>

<element name="TControl.AddHandlerOnResize">
<short>
Adds or inserts the specified <var>OnResize</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnResize.OnResizeEvent">
<short>
Handler routine added or inserted in the method.
</short>
</element>
<element name="TControl.AddHandlerOnResize.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list. 
<b>False</b> to append the handler to the end of the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnResize">
<short>
Removes the specified <var>OnResize</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnResize.OnResizeEvent">
<short>
Handler routine to locate and remove in the method.
</short>
</element>

<element name="TControl.AddHandlerOnChangeBounds">
<short>
Adds or inserts the specified <var>OnChangeBounds</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnChangeBounds.OnChangeBoundsEvent">
<short>
Handler routine added or inserted in the method.
</short>
</element>
<element name="TControl.AddHandlerOnChangeBounds.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list. 
<b>False</b> to append the handler to the end of the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnChangeBounds">
<short>
Removes the specified <var>OnChangeBounds</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnChangeBounds.OnChangeBoundsEvent">
<short>
Handler routine to locate and remove from the list of handlers.
</short>
</element>

<element name="TControl.AddHandlerOnVisibleChanging">
<short>
Adds or inserts the specified <var>OnVisibleChanging</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnVisibleChanging.OnVisibleChangingEvent">
<short>
TNotifyEvent handler routine added in the method.
</short>
</element>
<element name="TControl.AddHandlerOnVisibleChanging.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list of 
handlers for the chtOnVisibleChanging type. <b>False</b> if the routine is 
appended to the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnVisibleChanging">
<short>
Removes the specified <var>OnVisibleChanging</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnVisibleChanging.OnVisibleChangingEvent">
<short>
TNotifyEvent handler routine removed from the chtOnVisibleChanging handler 
type.
</short>
</element>

<element name="TControl.AddHandlerOnVisibleChanged">
<short>
Adds or inserts the specified <var>OnVisibleChanged</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnVisibleChanged.OnVisibleChangedEvent">
<short>
TNotifyEvent handler routine added in the method.
</short>
</element>
<element name="TControl.AddHandlerOnVisibleChanged.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list of 
handlers for the chtOnVisibleChanged type. <b>False</b> if the routine is 
appended to the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnVisibleChanged">
<short>
Removes the specified <var>OnVisibleChanged</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnVisibleChanged.OnVisibleChangedEvent">
<short>
TNotifyEvent handler routine removed from the chtOnVisibleChanged handler 
type.
</short>
</element>

<element name="TControl.AddHandlerOnEnabledChanging">
<short>
Adds the specified OnEnabledChanging handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnEnabledChanging.OnEnabledChangingEvent">
<short>
TNotifyEvent handler routine added in the method.
</short>
</element>
<element name="TControl.AddHandlerOnEnabledChanging.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list of 
handlers for the chtOnVisibleChanging type. <b>False</b> if the routine is 
appended to the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnEnabledChanging">
<short>
Removes the specified OnEnabledChanging event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnEnabledChanging.OnEnabledChangingEvent">
<short>
TNotifyEvent handler routine removed from the chtOnEnabledChanging handler 
type.
</short>
</element>

<element name="TControl.AddHandlerOnEnabledChanged">
<short>Adds an <var>OnEnabledChanged</var> handler.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnEnabledChanged.OnEnabledChangedEvent">
<short>
TNotifyEvent handler routine added in the method.
</short>
</element>
<element name="TControl.AddHandlerOnEnabledChanged.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list of 
handlers for the chtOnEnabledChanged type. <b>False</b> if the routine is 
appended to the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnEnabledChanged">
<short>
Removes the specified <var>OnEnabledChanged</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnEnabledChanged.OnEnabledChangedEvent">
<short>
TNotifyEvent handler routine removed from the chtOnEnabledChanged handler 
type.
</short>
</element>

<element name="TControl.AddHandlerOnKeyDown">
<short>Adds the specified <var>OnKeyDown</var> event handler.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnKeyDown.OnKeyDownEvent">
<short>
TKeyEvent handler routine added to the chtOnKeyDown handler type.
</short>
</element>
<element name="TControl.AddHandlerOnKeyDown.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list of 
handlers for the chtOnKeyDown type. <b>False</b> if the routine is appended to 
the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnKeyDown">
<short>Removes the specified <var>OnKeyDown</var> event handler.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnKeyDown.OnKeyDownEvent">
<short>
TKeyEvent handler routine removed from the list of handlers for the 
chtOnKeyDown handler type.
</short>
</element>

<element name="TControl.AddHandlerOnBeforeDestruction">
<short>
Adds or inserts the specified <var>OnBeforeDestruction</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnBeforeDestruction.OnBeforeDestructionEvent">
<short>
TNotifyEvent handler routine added to the list of handlers for the 
chtOnBeforeDestruction handler type.
</short>
</element>
<element name="TControl.AddHandlerOnBeforeDestruction.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list of 
handlers. <b>False</b> if the routine is appended to the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnBeforeDestruction">
<short>
Removes the specified <var>OnBeforeDestruction</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnBeforeDestruction.OnBeforeDestructionEvent">
<short>
TNotifyEvent handler routine removed from the list for the 
chtOnBeforeDestruction handler type.
</short>
</element>

<element name="TControl.AddHandlerOnMouseWheel">
<short>
Adds or inserts the specified <var>OnMouseWheel</var> event handler.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.AddHandlerOnMouseWheel.OnMouseWheelEvent">
<short>
TMouseWheelEvent handler routine added to the list for the chtOnMouseWheel 
handler type.
</short>
</element>
<element name="TControl.AddHandlerOnMouseWheel.AsFirst">
<short>
<b>True</b> if the routine is inserted as the first handler in the list of 
handlers. <b>False</b> if the routine is appended to the list.
</short>
</element>

<element name="TControl.RemoveHandlerOnMouseWheel">
<short>Removes the specified OnMouseWheel event handler.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.RemoveHandlerOnMouseWheel.OnMouseWheelEvent">
<short>
TMouseWheelEvent handler routine removed from the list for the chtOnMouseWheel 
handler type.
</short>
</element>

<element name="TControl.AccessibleName">
<short>
Contains the accessible name for the control, like the value for its Caption 
or Name property.
</short>
<descr/>
<seealso/>
</element>

<element name="TControl.AccessibleDescription">
<short>
Provides the accessibility description for the control, like "a text 
caption", etc.
</short>
<descr>
The accessible description of the control. This should describe the role of 
the control, for example for TLabel it could be "a text caption".
</descr>
<seealso>
<link id="TLazAccessibleObject.AccessibleDescription"/>
</seealso>
</element>

<element name="TControl.AccessibleValue">
<short>
The accessibility value for the control.
</short>
<descr>
<p>
The accessible value of the control. For example, for <var>TLabel</var> it 
would be the same as the <var>Caption</var> property.
</p>
</descr>
<seealso>
<link id="TLazAccessibleObject.AccessibleValue"/>
</seealso>
</element>

<element name="TControl.AccessibleRole">
<short>
The accessibility role for the control which classifies what kind of object 
in the class instance.
</short>
<descr>
<p>
See TLazAccessibilityRole for a list of possible values.
</p>
</descr>
<seealso>
<link id="TLazAccessibilityRole"/>
<link id="TLazAccessibleObject.AccessibleRole"/>
</seealso>
</element>

<element name="TControl.Action">
<short>The Action associated with the control.</short>
<descr>
<p>
<var>Action</var> is a <var>TBasicAction</var> property with the action 
assigned to the control. The value for the property is read from the Action 
property in ActionLink (when assigned). If ActionLink has not been assigned, 
the property value is <b>Nil</b>.
</p>
<p>
Assigning an action to the property causes ActionLink to be updated. If the 
new property value is <b>Nil</b>, the TControlActionLink instance in 
ActionLink is freed and control style flags are updated to remove the value 
csActionClient.
</p>
<p>
Conversely, a TControlActionLink instance is created for a non-empty action 
assignment. Its OnChange event handler is set to the private DoActionChange 
method in the class instance. Control style flags are updated to include the 
value csActionClient.
</p>
<p>
Action is used in the Click method to signal its OnExecute event handler when 
assigned and enabled. Preference is given to the OnClick in the control (when 
assigned).
</p>
<p>
Values in the Caption, Enabled, HelpType, and Hint properties can be linked 
to the Action through the property values in the ActionLink.
</p>
<p>
Use AssignTo to copy property values in the control to a TCustomAction 
instance.
</p>
</descr>
<seealso>
<link id="TControl.ActionLink"/>
<link id="TControl.Enabled"/>
<link id="TControl.Hint"/>
<link id="TControl.Click"/>
<link id="TControl.OnClick"/>
<link id="TControlActionLink"/>
<link id="#rtl.classes.TBasicAction">TBasicAction</link>
</seealso>
</element>

<element name="TControl.Align">
<short>
Specifies the placement of the control on its Parent control.
</short>
<descr>
<p>
<var>Align</var> is a <var>TAlign</var> property which specifies how the 
control is aligned to its parent control. The default value for the property 
is <var>alNone</var>.
</p>
<dl>
<dt>alNone</dt>
<dd>
The control is not aligned. It uses it Top, Left, Height, and Width to place 
the control in the Parent.
</dd>
<dt>alTop</dt>
<dd>
Aligns the control to the top of the parent control, and adjusts it Width to 
fill the Parent control.
</dd>
<dt>alBottom</dt>
<dd>
Aligns the control to the bottom of the Parent control, and adjusts its Width 
to fill the Parent control.
</dd>
<dt>alLeft</dt>
<dd>
Aligns the control to the left edge of the Parent control, and adjusts its 
Height to fill the Parent control.
</dd>
<dt>alRight</dt>
<dd>
Aligns the control to the right edge of the Parent control, and adjusts its 
Height to fill the Parent control.
</dd>
<dt>alClient</dt>
<dd>
Aligns the control to fill the unused Height and Width for the Parent control.
</dd>
<dt>alCustom</dt>
<dd>
Aligns the control by calling the OnAlignInsertBefore or OnAlignPosition 
event handlers in the Parent control.
</dd>
</dl>
</descr>
<seealso>
<link id="TAlign"/>
</seealso>
</element>

<element name="TControl.Anchors">
<short>The set of anchor definitions for this control.</short>
<descr>
<p>
Anchors is a TAnchors property which contains the edges used to align the 
position of the control relative to its Parent. Anchors allow the control to 
be repositioned and/or resized when the parent control is resized. Coordinate 
values in the control - like Left, Top, Bottom, and Right properties - are 
updated when the corresponding edge is anchored to its Parent.
</p>
<p>
The default value for the property is [akLeft, akTop], and indicates that 
only the Top and Left coordinates are anchored in the parent control.
</p>
<p>
For example:
</p>
<dl>
<dt>
[akLeft, akRight]
</dt>
<dd>
Causes the relative width for the control to be adjusted when the width of 
the parent control is changed.
</dd>
<dt>
[akTop, akBottom]
</dt>
<dd>
Causes the relative height for the control to be adjusted when the height of 
the parent control is changed.
</dd>
<dt>
[akTop, akLeft, akRight]
</dt>
<dd>
Causes the relative width (but not the height) for the control to be adjusted 
when the parent is resized. Like using the Align property.
</dd>
<dt>
[akTop, akLeft, akBottom, akRight]
</dt>
<dd>
Causes both the height and width to be adjusted when the parent control is 
resized. Like using alCustom in Align.
</dd>
</dl>
<p>
Setting a new value for the property causes the UpdateAnchorRules and 
AdjustSize methods to be called.
</p>
<p>
Values in Anchors are used (along with Align) in the DoAutoAdjustLayout 
method. They control whether values in Left, Top, Bottom, and Right are 
calculated using the ClientWidth and ClientHeight for the Parent control. The 
values in Anchors also used in the HeightIsAnchored and WidthIsAnchored 
methods.
</p>
<p>
Values in Anchors may be updated when a new value is assigned to the Align 
property which conflicts with the existing values in the property. They may 
also be updated when values are assigned to AnchorSide which cause vertical 
or horizontal centering to a sibling control (AnchorVerticalCenterTo, 
AnchorHorizontalCenterTo) or alignment to a companion control 
(AnchorToCompanion).
</p>
</descr>
<seealso>
<link id="TAnchors"/>
<link id="TAnchorKind"/>
<link id="TControl.Align"/>
<link id="TControl.AnchorSide"/>
<link id="TControl.AdjustSize"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TControl.ClientHeight"/>
<link id="TControl.ClientWidth"/>
<link id="TControl.Parent"/>
</seealso>
</element>

<element name="TControl.AnchorSide">
<short>Array of anchor definitions, indexed by the control sides.</short>
<descr>
<p>
Valid anchor definitions are flagged in <link 
id="TControl.Anchors">Anchors</link>.
</p>
<p>
AnchorSide specifies how a side is anchored to other controls (siblings or 
Parent).
</p>
<p>
Various AnchorAs and AnchorTo methods simplify the establishment of anchors.
</p>
</descr>
<seealso>
<link id="TAnchorSide"/>
<link id="TControl.AnchorAsAlign"/>
<link id="TControl.AnchorToNeighbour"/>
</seealso>
</element>
<element name="TControl.AnchorSide.Kind">
<short>The anchored side of the control.</short>
</element>

<element name="TControl.AutoSize">
<short>
Allows automatic adjustment of the size for the control, according to its 
content.
</short>
<descr>
<p>
The action performed depends on the concrete control type. For example, a 
label or button can become bigger or smaller to accommodate a longer or 
shorter caption.
</p>
<p>
Default value for the property is <b>False</b>, and disables auto-sizing for 
the control instance.
</p>
</descr>
<seealso>
<link id="#lcl.controls.Autosize">Using AutoSize</link>
</seealso>
</element>

<element name="TControl.BorderSpacing">
<short>Determines the inner and outer border spacing for this control.</short>
<descr>
<p>
The outer border determines the minimum distance to sibling controls. The 
inner border is the space between the BoundsRect and ClientRect for the 
control.
</p>
<p>
When a control sits in a cell of a table (Grid) control, its horizontal and 
vertical alignment inside the cell can be specified, too.
</p>
</descr>
</element>

<element name="TControl.BoundsRect">
<short>
The Top, Left and Bottom, Right for the control, in client coordinates.
</short>
<descr>
<p>
The BoundsRect rectangle describes the Top, Left and Bottom, Right 
coordinates for the control, relative to its parent.
</p>
<p>
The values are based on the Top, Left, Width and Height properties of the 
control.
</p>
<p>
Set BoundsRect to move and/or resize the control. This can reduce flicker, 
occurring otherwise when Top, Width etc. are set individually.
</p>
</descr>
</element>

<element name="TControl.BoundsRectForNewParent">
<short>
Temporary BoundsRect, used when the control e.g. is docked into a different 
Parent.
</short>
<descr>
<p>
The rectangle describes the placement of the control when its Parent is 
changed later.
</p>
<p>
Setting the rectangle also sets a flag, that indicates the values are 
available.
</p>
</descr>
</element>

<element name="TControl.Caption">
<short>
The text displayed for the control.
</short>
<descr>
<p>
Caption is a TCaption property with the text displayed for the control. By 
default, <var>Caption</var> has the same value as the <var>Name</var> 
property used for the control. An explicit value can be assigned at 
design-time using the Object Inspector, or by the developer in program code.
</p>
<p>
Controls normally use the Caption or Text properties (they are equivalent in 
TControl) to read or write their textual value. The property value is 
retrieved using either the RealGetText method, or the GetTextBuf method when 
it has been overridden in a descendent class. Conversely, the property value 
is stored using either RealSetText, or an overridden SetTextBuf method in a 
descendent class.
</p>
<p>
When the value in Caption is changed, a CM_TEXTCHANGED message is performed 
for the control. Changing the value for the property causes the caption for 
the HostDockSite to be updated (when assigned).
</p>
<p>
Caption can be used to display an accelerator (or shortcut) key which allows 
the control (or an associate) to be given focus or executed. The shortcut key 
is identified by placing an Ampersand (&amp;) character in front of the 
character used as the accelerator key. Use two Ampersand characters to 
display a single Ampersand which is not a shortcut key. For example:
</p>
<code>
{
  var
    ALabel: TLabel;
    Form1: TForm;
    Memo1: TMemo;
    ...
}
ALabel := TLabel.Create(Form1);
ALabel.ShowAccelerator := True;
ALabel.FocusControl := Memo1;
ALabel.Caption := '&amp;Notes &amp;&amp; Comments';
</code>
<p>
Displays the 'N' character with an underline indicating the accelerator key. 
Pressing Alt+N activates the shortcut key and causes the associated TMemo 
control to be given focus.
</p>
<p>
Caption can also contain multiline text. In TControl descendants, this is 
achieved by setting Caption to a value which contains embedded LineEnding 
sequence(s). For example:
</p>
<code>
Button1.Caption := 'Pass' + LineEnding + 'and' + LineEnding + 'Stowe';
</code>
<p>
In descendant controls, like TSpeedButton or TToggleBox, a multiline value 
can be assigned in the Object Inspector using its Strings property editor.
</p>
<p>
Enable AutoSize to automatically resize the control to its Caption value 
(including multiline text).
</p>
<p>
Set values in Font to specify the typeface, size, color, and style used to 
display the Caption text.
</p>
</descr>
<seealso>
<link id="TControl.RealGetText"/>
<link id="TControl.RealSetText"/>
<link id="TControl.GetTextBuf"/>
<link id="TControl.SetTextBuf"/>
<link id="TControl.Text"/>
<link id="TControl.Font"/>
</seealso>
</element>

<element name="TControl.CaptureMouseButtons">
<short>
Indicates the mouse button(s) which are captured for the control.
</short>
<descr>
<p>
CaptureMouseButtons is a TCaptureMouseButtons property with the set of mouse 
buttons which capture events for the control. It contains zero or more values 
from the TMouseButton enumeration. Up, down, click, double click, triple 
click, and quad click messages are handled for a mouse button when its value 
is included in the property.
</p>
<p>
The default value for the property is <b>[mbLeft]</b> and causes events to be 
handled for the Left mouse button.
</p>
<p>
Mouse capture is enabled for the button(s) when csCaptureMouse is included in 
the ControlStyle property.
</p>
<p>
ControlStyle and CaptureMouseButtons are used in message handlers which 
respond to mouse events, like: WMLButtonDDown, WMLButtonUp, WMLButtonDblClk, 
WMLButtonTripleClk, WMLButtonQuadClk, et. al.
</p>
</descr>
<seealso/>
</element>

<element name="TControl.ClientHeight">
<short>The height for the client area on the control.</short>
<descr>
<p>
<var>ClientHeight</var> is an <var>Integer</var> property with the number of 
pixels needed for the vertical client area on the control. The property 
contains the value from the Bottom member in ClientRect. Changing the value for 
ClientHeight causes SetClientSize to be called to apply the existing 
ClientWidth and the new value for the property.
</p>
<p>
The value for ClientHeight is not stored or used to set the Height for the 
control during LCL component streaming. It is used, however, when AutoSizing 
is restored and when auto-layout policies using Anchors are applied to the 
control. For example, when Anchors is set to [akBottom] the value in 
ClientHeight is needed / used.
</p>
<remark>
In the LCL, ClientHeight has the same value as Height. Derived classes (like 
TCustomForm or TForm) may implement a ClientHeight property that differs from 
Height - but in the current LCL version, they do not. This differs from the 
behavior in the Delphi VCL where a TForm instance adjusts the value in 
ClientHeight to remove pixels used in non-client areas like the title bar, 
borders, frames, and scroll bars. LCL uses this approach because there is no 
reliable way to determine the sizes for all of the non-client areas on all of 
the platforms where LCL is supported. Without a reliable way, the LCL would 
needlessly move the forms around on the screen or resize them endlessly. In the 
LCL, neither Height nor ClientHeight include the non-client area on a form 
instance. The height of a TMainMenu instance is omitted from both values as 
well.
</remark>
<p>
Use ClientWidth to access the number of pixels needed for the horizontal client 
area on the control.
</p>
</descr>
<seealso>
<link id="TControl.ClientRect"/>
<link id="TControl.ClientWidth"/>
<link id="TControl.Height"/>
<link id="TControl.AutoSizing"/>
<link id="TControl.EnableAutoSizing"/>
<link id="TControl.AutoAdjustLayout"/>
<link id="TControl.Resize"/>
<link id="TControl.Anchors"/>
</seealso>
</element>

<element name="TControl.ClientOrigin">
<short>
Screen coordinates of the Top, Left pixel (in the client area) of the control.
</short>
<descr>
<p>
Only <var>TWinControl</var> has a client area. For other controls, 
ClientOrigin is the same as <var>ControlOrigin</var>. Uses the corresponding 
property in the <var>Parent</var> control to get the property value, and 
includes the values in <var>Left</var> and <var>Top</var> to get the 
effective origin for the control.
</p>
<p>
An <var>EInvalidOperation</var> exception is raised if Parent has not been 
assigned when reading the value for the property.
</p>
<p>
Note that this value is the position as stored in the object, not always in 
sync with the widget.
</p>
</descr>
<errors>
Raises an EInvalidOperation exception with the message in sParentRequired if 
Parent has not been assigned when reading the value for the property.
</errors>
<seealso>
<link id="TControl.Parent"/>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.ControlOrigin"/>
<link id="TControl.GetClientOrigin"/>
</seealso>
</element>

<element name="TControl.ClientRect">
<short>Size of the client area for the control.</short>
<descr>
<p>
Contains the size for the visual client area in the control. For example, the 
inner size of a TGroupBox. For a TScrollBox it is the visual size, and not 
the logical size.
</p>
<p>
The property value is a TRect instance with the Top and Left members set to 
0, and the Height and Width members set to the corresponding property values 
for the control.
</p>
</descr>
<seealso>
<link id="TControl.GetClientRect"/>
<link id="TControl.GetLogicalClientRect"/>
<link id="#rtl.classes.TRect">TRect</link>
</seealso>
</element>

<element name="TControl.ClientWidth">
<short>The width of the client area for the control.</short>
<descr>
<p>
<var>ClientWidth</var> is an <var>Integer</var> property with the number of 
pixels need for the horizontal client area on the control. The property 
contains the value from the Right member in ClientRect. Changing the value
for ClientWidth causes SetClientSize to be called to apply the new property 
value and the existing ClientHeight for the control.
</p>
<p>
The value for ClientWidth is not stored or used to set the Width for the 
control during LCL component streaming. It is used, however, when AutoSizing 
is restored and when auto-layout policies using Anchors are applied to the 
control. For example, when Anchors is set to [akRight] the value in 
ClientWidth is needed / used.
</p>
<remark>
In the LCL, ClientWidth has the same value as Width. Derived classes (like 
TCustomForm or TForm) may implement a ClientWidth property that differs from 
Width - but in the current LCL version, they do not. This differs from the 
behavior in the Delphi VCL where a TForm instance adjusts the value in 
ClientWidth to remove pixels used in non-client areas like the borders, frames, 
and scroll bars. LCL uses this approach because there is no reliable way to 
determine the sizes for all of the non-client areas on all of the platforms 
where LCL is supported. Without a reliable way, the LCL would needlessly move 
the forms around on the screen or resize them endlessly. In the LCL, neither 
Width nor ClientWidth include the non-client area on a form instance.
</remark>
<p>
Use ClientHeight to access the number of pixels needed for the vertical client 
area on the control.
</p>
</descr>
<seealso>
<link id="TControl.ClientRect"/>
<link id="TControl.ClientHeight"/>
<link id="TControl.Width"/>
<link id="TControl.AutoSizing"/>
<link id="TControl.EnableAutoSizing"/>
<link id="TControl.AutoAdjustLayout"/>
<link id="TControl.Resize"/>
<link id="TControl.Anchors"/>
</seealso>
</element>

<element name="TControl.Color">
<short>The background color for the control.</short>
<descr>
<p>
The default value in <var>Color</var> is the same as the value in the parent 
window <var>Color</var>. If the color is <var>clDefault</var>, the result 
will need to be passed through <var>GetDefaultColor</var> to resolve 
<var>clDefault</var>. Convenience routines which obtain the color by 
resolving <var>clDefault</var> and <var>ParentColor</var> are also provided 
as <var>TControl.GetColorResolvingParent</var> and 
<var>TControl.GetRGBColorResolvingParent</var>.
</p>
<remark>
For the macOS Carbon widgetset, setting Color to clBtnFace causes the 
background for the control to become transparent.
</remark>
</descr>
<seealso>
<link id="TControl.ParentColor"/>
<link id="TControl.GetDefaultColor"/>
<link id="TControl.GetColorResolvingParent"/>
<link id="TControl.GetRGBColorResolvingParent"/>
<link id="#lcl.graphics.TColor">TColor</link>
</seealso>
</element>

<element name="TControl.Constraints">
<short>
Contains the minimum and maximum Width and Height for the control.
</short>
<descr>
<p>
<var>Constraints</var> is a <var>TSizeConstraints</var> property with the 
sizing constraints used for the control. Constraints contains properties like 
MinHeight, MaxHeight, MinWidth, and MaxWidth. They are applied (when 
assigned) to the corresponding control properties when its bounds or 
preferred size is changed, and during scaling operations.
</p>
</descr>
<seealso>
<link id="TControl.ChangeScale"/>
<link id="TControl.ChangeBounds"/>
<link id="TControl.GetPreferredSize"/>
<link id="TSizeConstraints"/>
</seealso>
</element>

<element name="TControl.ControlOrigin">
<short>
The top, left pixel for the control in screen coordinates.
</short>
<descr>
<p>
<var>ControlOrigin</var> is a read-only <var>TPoint</var> property with the 
screen-relative coordinates where the control is located.
</p>
<p>
The X and Y members in the property represent the Left and Top coordinates for 
the control after they are converted to screen coordinates. The values are 
derived by adding the TPoint values for the Left and Top coordinates to the 
ClientOrigin property for the Parent control. The return value contains the 
unmodified values in Left and Top when a Parent control has not been assigned.
</p>
<p>
ControlOrigin is used to implement the ScreenToControl and ControlToScreen 
methods.
</p>
</descr>
<seealso>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.Parent"/>
<link id="TControl.ClientOrigin"/>
<link id="TControl.ControlToScreen"/>
<link id="TControl.ScreenToControl"/>
<link id="TControl.ScreenToClient"/>
<link id="TControl.BoundsRect"/>
</seealso>
</element>

<element name="TControl.ControlState">
<short>
Contains state flags which indicate whether the control has been clicked, 
data is being read, or the control is being re-drawn, etc.
</short>
<descr>
<p>
<var>ControlState</var> is a <var>TControlState</var> property which contains 
flags that indicate when actions are detected or handled for the control. It 
is a set type which contains zero or more values from the TControlStateType 
enumeration.
</p>
<p>
Values are added to the property when an event is detected. Values are 
removed from the property in methods which handle the event by performing 
some action on the control.
</p>
<p>
For more information about the values in the enumeration and their uses and 
meanings, please refer to <link 
id="TControlStateType">TControlStateType</link>.
</p>
</descr>
<seealso>
<link id="TControl.ReadState"/>
<link id="TControl.Dock"/>
<link id="TControl.WMLButtonDown"/>
<link id="TControl.WMLButtonUp"/>
<link id="TControl.WndProc"/>
<link id="TControlState"/>
<link id="TControlStateType"/>
</seealso>
</element>

<element name="TControl.ControlStyle">
<short>
Contains style flags which control the features or behaviors enabled for the 
control.
</short>
<descr>
<p>
<var>ControlStyle</var> is a <var>TControlStyle</var> property used to enable 
features or behaviors for a control. Values from the 
<var>TControlStyleType</var> enumeration are added to the property to enable 
the corresponding feature supported in the control.
</p>
<p>
Values in ControlStyle are normally assigned in the constructor for a given 
control class.
</p>
<p>
Some controls implement properties which cause the values in the set to be 
changed when a new value is assigned to the property. For example, 
TToolBar.Transparent includes or excludes csOpaque in ControlStyle as needed 
to reflect the value for the property. Values in the property may also be 
read and/or updated when methods in the control are called.
</p>
<p>
The visibility for the ControlStyle property is public, so it does not appear 
in the Lazarus Object Inspector. But it can be updated in program code as 
needed.
</p>
<p>
See TControlStyleType for more information about values in the enumeration 
and their intended usage.
</p>
</descr>
<seealso>
<link id="TControlStyleType"/>
<link id="TControlStyle"/>
</seealso>
</element>

<element name="TControl.Enabled">
<short>
Determines whether the control responds to mouse or keyboard input.
</short>
<descr>
<p>
<var>Enabled</var> is a <var>Boolean</var> property which indicates whether 
the control can respond to focus, input, or mouse events. The default value 
for the property is <b>True</b>. When Enabled is set to <b>False</b>, the 
control is displayed with a "grayed-out" appearance. It is unable to receive 
input focus, handle keyboard navigation or input, respond to mouse click 
events, or execute its Action.
</p>
<p>
Changing the value for the property causes additional actions to be 
performed. EnabledChanging is called to signal any chtOnEnabledChanging 
control handlers assigned for the control. The property value is updated, and 
a CM_ENABLEDCHANGED control message is dispatched for the control. The 
EnabledChanged method is called to signal any chtOnEnabledChanged control 
handlers for the control.
</p>
<p>
Use IsEnabled to check the effective enabled state for both the control and 
its Parent control (when assigned).
</p>
</descr>
<seealso>
<link id="TControl.EnabledChanging"/>
<link id="TControl.EnabledChanged"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="TControl.IsEnabled"/>
</seealso>
</element>

<element name="TControl.Font">
<short>
The <link id="#lcl.graphics.TFont">font</link> to be used for text display in 
this control.
</short>
<descr>
<p>
<var>Font</var> is a <var>TFont</var> property with the typeface and display 
attributes used for textual values on the control. Use properties in the 
TFont instance to change attributes like Name (for the typeface), Charset, 
Color, Height, Orientation (rotation degrees), Pitch, Quality, Size, and 
Style. Assigning a new TFont instance to the property causes the control to 
be redrawn.
</p>
<remark>
Some Font attributes may be ignored in TControl descendants. It depends on 
the drawing style for the specific control, and whether theme services are 
enabled for text on the control.
</remark>
<remark>
For the macOS Carbon widgetset, Font does not support use of the fsStrikeOut 
attribute in its Style property.
</remark>
<p>
The PixelsPerInch property in Font is used to perform font size scaling in 
methods like Scale96ToFont, ScaleFontTo96, ScaleScreenToFont, and 
ScaleFontToScreen.
</p>
</descr>
<seealso>
<link id="#lcl.graphics.TFont">TFont</link>
</seealso>
</element>

<element name="TControl.IsControl">
<short>Not used in the current LCL implementation.</short>
<descr>
<p>
IsControl is provided for Delphi code compatibility. It is not used in the 
current LCL implementation.
</p>
</descr>
</element>

<element name="TControl.MouseEntered">
<short>
<b>True</b> when the mouse has entered the control. (Deprecated)
</short>
<descr>
Deprecated. Use MouseInClient instead.
</descr>
<seealso>
<link id="TControl.MouseInClient"/>
</seealso>
</element>

<element name="TControl.MouseInClient">
<short>
<b>True</b> when the mouse is in the client area for the control.
</short>
<descr>
<p>
<var>MouseInClient</var> is a read-only <var>Boolean</var> property which 
indicates if the mouse pointer has entered the client area for the control. 
The value for the property is updated when CM_MOUSEENTER or CM_MOUSELEAVE 
messages are handled for the control. The property value is set to 
<b>True</b> in CMMouseEnter, and set to <b>False</b> in CMMouseLeave.
</p>
<p>
Use the OnMouseEnter or OnMouseLeave event handlers to perform actions needed 
when the mouse control messages are handled for the control.
</p>
</descr>
<seealso>
<link id="TControl.ClientRect"/>
<link id="TControl.CMMouseEnter"/>
<link id="TControl.CMMouseLeave"/>
<link id="TControl.MouseEnter"/>
<link id="TControl.OnMouseEnter"/>
<link id="TControl.MouseLeave"/>
<link id="TControl.OnMouseLeave"/>
</seealso>
</element>

<element name="TControl.OnChangeBounds">
<short>
Event handler signalled when the Bounds for the control have been changed.
</short>
<descr>
<p>
<var>OnChangeBounds</var> is signalled from the DoOnChangeBounds method (when 
assigned). It occurs after the internal control flags have been updated to 
exclude cfOnChangeBoundsNeeded, and before DoCallNotifyHandler is called to 
notify handlers for the chtOnChangeBounds type.
</p>
</descr>
<seealso>
<link id="TControl.ChangeBounds"/>
<link id="TControl.CheckOnChangeBounds"/>
<link id="TControl.DoOnChangeBounds"/>
<link id="TControl.DoCallNotifyHandler"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnClick">
<short>Notification handler for mouse clicks.</short>
<descr>
<p>
A mouse click is associated with the default action for a control, and is 
often the only event handled in user code.
</p>
<p>
The action performed for a click can be specified by a user supplied method, 
or by selecting an <var>Action</var> from a supplied <var>ActionList</var>.
</p>
<p>
OnClick is signalled (when assigned) from the Click method. It occurs when an 
Action has not been assigned using the ActionLink for the control. When 
Action is assigned, the Execute method in the ActionLink is called.
</p>
</descr>
<seealso>
<link id="TControl.Action"/>
<link id="TControl.ActionLink"/>
<link id="#rtl.classes.TBasicAction">TBasicAction</link>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnResize">
<short>Notification handler for a resize of the control.</short>
<descr>
<p>
This event is triggered after the Width, Height, ClientWidth or ClientHeight 
of the control has changed, and before the LCL sends the new size to the 
widgetset. The size of the underlying widget (e.g. unit LCLIntf function 
GetWindowSize and GetClientRect) may differ from the control's 
Width/Height/ClientRect during OnResize. During auto-size the size can change 
multiple times, but only the last change triggers the OnResize.
</p>
<p>
Use OnResize to react on size changes. To also react on moves, use the 
OnChangeBounds event.
</p>
<p>
If you want to customize the resize behavior, use OnConstrainedResize instead.
</p>
<p>
Common mistake: Keep in mind that ClientWidth and ClientHeight can change 
even when Width and Height stay the same. For example when the theme changes, 
the Width and Height remain the same, but the changed frame reduces the 
ClientWidth and ClientHeight. This does not happen that often under Windows, 
but it happens quite often on other platforms.
</p>
<p>
Especially it is not sufficient to write only a TForm.OnResize handler to 
resize all controls on the form. This is a common bug in Delphi applications.
</p>
</descr>
<seealso>
<link id="TControl.OnConstrainedResize"/>
<link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
</seealso>
</element>

<element name="TControl.OnShowHint">
<short>
Event handler signalled when a hint window is displayed for the control.
</short>
<descr>
<p>
OnShowHint is a TControlShowHintEvent property with the event handler 
signalled when a hint window is displayed for the control. Arguments to the 
event handler include the control instance for the event notification, and a 
pointer to the structure with the Hint details for the control.
</p>
<p>
OnShowHint has public visibility in TControl, but may be redeclared in 
descendent classes to make it visible in the object inspector. An application 
must implement and assign a handler routine to respond to the event 
notification.
</p>
<p>
OnShowHint is signalled from the DoOnShowHint method (when assigned), and 
occurs when the CM_HINTSHOW control message is handled for the control.
</p>
<p>
Set ShowHint to <b>True</b> to enable hint window display using the value(s) 
in the Hint property.
</p>
</descr>
<seealso>
<link id="TControl.Hint"/>
<link id="TControl.ShowHint"/>
<link id="TControl.DoOnShowHint"/>
<link id="TControlShowHintEvent"/>
<link id="THintInfo"/>
<link id="PHintInfo"/>
</seealso>
</element>

<element name="TControl.Parent">
<short>The control within which the control is shown.</short>
<descr>
<p>
When the Parent moves or hides, all its children move or hide together with 
it.
</p>
<p>
Every TControl must have a Parent, else it is never shown.
</p>
<p>
The Parent of a floating form is <b>Nil</b>.
</p>
<p>
Set the parent last to reduce updates. For example:
</p>
<code>
Button1 := TButton.Create(Self);
Button1.Name := 'Button1';
Button1.Caption := 'Click me'; // parent is not set, so it does not update the whole form
Button1.Parent := Form1; // set parent as last, the LCL now applies all properties
</code>
<p>
Delphi/VCL: Parent must be set first under Delphi, because many properties 
work differently if they are set before or after Handle creation. The LCL 
applies the properties when the Handle is created.
</p>
</descr>
</element>

<element name="TControl.PopupMenu">
<short>
A context-sensitive menu that pops up when the right mouse button is clicked 
over this control.
</short>
<descr/>
<seealso>
<link id="TControl.OnContextPopup"/>
<link id="TContextPopupEvent"/>
<link id="#lcl.menus.TPopupMenu">TPopupMenu</link>
</seealso>
</element>

<element name="TControl.ShowHint">
<short>Enables Hint display for the control.</short>
<descr>
<p>
<var>ShowHint</var> is a <var>Boolean</var> property used to enable or 
disable display of pop-up Hint text for the control. When set to <b>True</b>, 
the Hint text is shown when the mouse is hovered over the control. The 
default value for the property is <b>False</b> and disables Hint text in a 
pop-up window.
</p>
<p>
Changing the value in ShowHint causes the ParentShowHint property to be set 
to <b>False</b>. A CM_SHOWHINTCHANGED is performed to apply the new value for 
the property.
</p>
<p>
Use the Hint property to set the text displayed in the pop-up hint window 
when ShowHint is enabled. Use the OnShowHint event handler to provide custom 
text uses in the Hint display.
</p>
<p>
Use the ShowHint property in a TForm instance to enable or disable pop-up 
hint display for all controls on a given form. Use the ShowHint property in 
TApplication to enable or disable pop-up hint display for all forms and 
controls in an application.
</p>
</descr>
<seealso>
<link id="TControl.Hint"/>
<link id="TControl.OnShowHint"/>
<link id="TControl.ParentShowHint"/>
<link id="#lcl.forms.TForm.ShowHint">TForm.ShowHint</link>
<link id="#lcl.forms.TApplication.ShowHint">TApplication.ShowHint</link>
</seealso>
</element>

<element name="TControl.Visible">
<short>
Allows the control, and all of its children, to be displayed or hidden.
</short>
<descr>
<p>
Visible is set to <b>True</b> by <var>Show</var>, or to <b>False</b> by 
<var>Hide</var>. Calling these methods is equivalent to setting the Visible 
property.
</p>
<remark>
Reading the Visible property does not take into account control's parent 
visibility. Use the IsVisible method to get the real visibility.
</remark>
</descr>
<seealso>
<link id="TControl.IsVisible"/>
<link id="TControl.Show"/>
<link id="TControl.Hide"/>
</seealso>
</element>

<element name="TControl.WndProc">
<short>The general message handler for this control.</short>
<descr>
<p>
Preprocesses several messages, then calls Dispatch to invoke the applicable 
message handler.
</p>
</descr>
<seealso/>
</element>
<element name="TControl.WndProc.TheMessage">
<short>The message to handle.</short>
</element>

<element name="TControl.WindowProc">
<short>The handler for all messages.</short>
<descr>
<p>
WindowProc is set to <link id="TControl.WndProc"/> by default.
</p>
<p>
When you ever change WindowProc, then remember the previous setting and 
delegate all unhandled messages to that method.
</p>
</descr>
<seealso>
<link id="TWndMethod"/>
<link id="#lcl.lmessages.TLMessage">TLMessage</link>
<link id="TControl.Perform"/>
</seealso>
</element>

<element name="TControl.DockOrientation">
<short>
How the control is currently docked. (horizontally, vertically, in a 
notebook, or not at all).
</short>
<descr>
<p>
The property value is assigned when the control is inserted into a docking 
tree during a drag and dock operation. Its value is used when 
CalculateDockSizes is called to adjust the height or width for the host dock 
site.
</p>
</descr>
<seealso>
<link id="TControl.CalculateDockSizes"/>
<link id="#lcl.ldocktree.TLazDockTree.InsertControl">TLazDockTree.InsertControl</link>
</seealso>
</element>

<element name="TControl.Floating">
<short>
Determines whether the control is floating (not part of a form).
</short>
<descr/>
<seealso>
<link id="TControl.FloatingDockSiteClass"/>
</seealso>
</element>

<element name="TControl.FloatingDockSiteClass">
<short>The class for a floating host dock site for this control.</short>
<descr/>
<seealso>
<link id="TControl.Floating"/>
</seealso>
</element>

<element name="TControl.HostDockSite">
<short>
The host site (TWinControl) into which this control is docked. <b>Nil</b> if 
not docked.
</short>
<descr/>
<seealso/>
</element>

<element name="TControl.LRDockWidth">
<short>
The Width when last docked with siblings to the left or right.
</short>
<descr/>
<seealso/>
</element>

<element name="TControl.TBDockHeight">
<short>
The Height when last docked with siblings above or below.
</short>
<descr/>
<seealso/>
</element>

<element name="TControl.UndockHeight">
<short>Height for the control when undocked.</short>
<descr/>
<seealso/>
</element>

<element name="TControl.UndockWidth">
<short>Width for the control when undocked.</short>
<descr/>
<seealso/>
</element>

<element name="TControl.UseRightToLeftAlignment">
<short><b>True</b> when BiDiMode is bdRightToLeft.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.UseRightToLeftAlignment.Result">
<short><b>True</b> when BiDiMode is bdRightToLeft.</short>
</element>

<element name="TControl.UseRightToLeftReading">
<short><b>True</b> when BiDiMode is not bdLeftToRight.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.UseRightToLeftReading.Result">
<short><b>True</b> when BiDiMode is not bdLeftToRight.</short>
</element>

<element name="TControl.UseRightToLeftScrollBar">
<short>
<b>True</b> when BiDiMode indicates right-to-left reading is in use.
</short>
<descr/>
<seealso/>
</element>
<element name="TControl.UseRightToLeftScrollBar.Result">
<short>
<b>True</b> when BiDiMode indicates right-to-left reading is in use.
</short>
</element>

<element name="TControl.IsRightToLeft">
<short><b>True</b> when BiDiMode is not bdLeftToRight.</short>
<descr/>
<seealso/>
</element>
<element name="TControl.IsRightToLeft.Result">
<short><b>True</b> when BiDiMode is not bdLeftToRight.</short>
</element>

<element name="TControl.BiDiMode">
<short>
Indicates whether text controls use in bi-directional reading.
</short>
<descr>
<p>
In "normal" reading mode (left-to-right, LTR) text entry starts at the left, 
text is almost left justified, and vertical scrollbars sit at the right side 
of the control.
</p>
<p>
In right-to-left mode text entry starts at the right, text is almost right 
justified, and vertical scrollbars sit at the left side of the control.
</p>
<p>
In a bidirectional environment these different placements and adjustments can 
be configured (swapped) in various (but not all) ways.
</p>
<p>
(Allows RTL languages such as Arabic and Hebrew to be used)
</p>
<p>
Wild guess: The default mode is established by the platform, RTL reading is 
not supported on all (Windows) platforms.
</p>
</descr>
<seealso>
<link id="TControl.UseRightToLeftAlignment"/>
<link id="TControl.UseRightToLeftReading"/>
<link id="TControl.UseRightToLeftScrollBar"/>
<link id="TControl.IsRightToLeft"/>
</seealso>
</element>

<element name="TControl.ParentBiDiMode">
<short>
Indicates whether the BiDiMode settings in the Parent control are used.
</short>
<descr>
<p>
When set to <b>True</b>, the BidiMode property from the Parent control is 
copied into the BiDiMode property for the control. The default value for 
ParentBiDiMode is <b>True</b>.
</p>
<p>
Changing the value for the property causes a CM_PARENTBIDIMODECHANGED message 
to be performed to update the control.
</p>
<p>
See BiDiMode or UseRightToLeftAlignment for more information about the use of 
bidrectional text on the control.
</p>
</descr>
<seealso>
<link id="TControl.BiDiMode"/>
</seealso>
</element>

<element name="TControl.AnchorSideLeft">
<short>
Contains anchor alignment information used to position the control with its 
left edge anchored to another control.
</short>
<descr>
<p>
AnchorSideLeft is a TAnchorSide property with information about the side, 
type, alignment, and control used to anchor align the class instance. 
AnchorSideLeft provides access to the array element in AnchorSide stored at 
the position in akLeft.
</p>
</descr>
<seealso>
<link id="TControl.AnchorSide"/>
<link id="TControl.AnchorSideRight"/>
<link id="TControl.AnchorSideTop"/>
<link id="TControl.AnchorSideBottom"/>
<link id="TAnchorKind"/>
</seealso>
</element>

<element name="TControl.AnchorSideTop">
<short>
Contains anchor alignment information used to position the control with its 
top edge anchored to another control.
</short>
<descr>
<p>
AnchorSideTop is a TAnchorSide property with information about the side, 
type, alignment, and control used to anchor align the class instance. 
AnchorSideTop provides access to the array element in AnchorSide stored at 
the position in akTop.
</p>
</descr>
<seealso>
<link id="TControl.AnchorSide"/>
<link id="TControl.AnchorSideLeft"/>
<link id="TControl.AnchorSideRight"/>
<link id="TControl.AnchorSideBottom"/>
<link id="TAnchorKind"/>
</seealso>
</element>

<element name="TControl.AnchorSideRight">
<short>
Contains anchor alignment information used to position the control with its 
right edge anchored to another control.
</short>
<descr>
<p>
AnchorSideRight is a TAnchorSide property with information about the side, 
type, alignment, and control used to anchor align the class instance. 
AnchorSideRight provides access to the array element in AnchorSide stored at 
the position in akRight.
</p>
</descr>
<seealso>
<link id="TControl.AnchorSide"/>
<link id="TControl.AnchorSideLeft"/>
<link id="TControl.AnchorSideTop"/>
<link id="TControl.AnchorSideBottom"/>
<link id="TAnchorKind"/>
</seealso>
</element>

<element name="TControl.AnchorSideBottom">
<short>
Contains anchor alignment information used to position the control with its 
bottom edge anchored to another control.
</short>
<descr>
<p>
AnchorSideTop is a TAnchorSide property with information about the side, 
type, alignment, and control used to anchor align the class instance. 
AnchorSideTop provides access to the array element in AnchorSide stored at 
the position in akTop.
</p>
</descr>
<seealso>
<link id="TControl.AnchorSide"/>
<link id="TControl.AnchorSideLeft"/>
<link id="TControl.AnchorSideRight"/>
<link id="TControl.AnchorSideTop"/>
<link id="TAnchorKind"/>
</seealso>
</element>

<element name="TControl.Cursor">
<short>
Contains the shape for the mouse pointer when the mouse is over the control.
</short>
<descr>
<p>
<var>Cursor</var> is a <var>TCursor</var> property with the cursor shape 
displayed when the mouse pointer is hovered over the control. The default 
value for the property is crDefault.
</p>
<p>
Changing the value for the property causes a CM_CURSORCHANGED message to be 
performed to update the control. The value is applied at run-time when the 
CMCursorChanged method handles the control message.
</p>
<p>
Use SetTempCursor to display a temporary cursor shape when an action is in 
progress for the control.
</p>
</descr>
<seealso>
<link id="TControl.SetTempCursor"/>
<link id="TControl.DragCursor"/>
<link id="#lcl.forms.TScreen.Cursors">TScreen.Cursors</link>
<link id="#lcl.forms.TScreen.RealCursor">TScreen.RealCursor</link>
</seealso>
</element>

<element name="TControl.Left">
<short>The client coordinate with the left edge for the control.</short>
<descr>
<p>
<var>Left</var> is an <var>Integer</var> property with the coordinate for the 
left edge of the control relative to its Parent. Changing the value for the 
property causes SetBounds to be called to apply the new value for the 
property along with the existing values in Top, Width, and Height.
</p>
</descr>
<seealso>
<link id="TControl.Height"/>
<link id="TControl.Top"/>
<link id="TControl.Width"/>
<link id="TControl.Parent"/>
<link id="TControl.SetBounds"/>
<link id="TControl.ChangeBounds"/>
</seealso>
</element>

<element name="TControl.Height">
<short>
The vertical size for the control.
</short>
<descr>
<p>
<var>Height</var> is an <var>Integer</var> property with the vertical size for 
the control in pixels.
</p>
<p>
Setting a negative value in Height is not allowed, and the property defaults 
to <b>0</b> (zero). At design-time, setting Height to a value not in the 
range 0..9999 causes an ELayoutException to be raised (and handled in the 
IDE).
</p>
<p>
Setting a new value for the property causes SetBounds and ChangeBounds to be 
called. This ensures that the new value is in the range allowed in Constraints, 
and that the control is aligned on its Parent using the Anchors for the control.
</p>
<p>
A value assigned to Height is ignored when AutoSize is set to <b>True</b>; 
the control is automatically adjusted to the size needed for its aligned 
content.
</p>
<p>
Values in Top, Left, Width, and Height are used to calculate the display area 
for the control in GetClientRect. They determine the clipping rectangle used 
when the control is drawn on its Parent.
</p>
<remark>
In the LCL, Height has the same value as ClientHeight. Derived classes (like 
TCustomForm or TForm) may implement a ClientHeight property that differs from 
Height - but in the current LCL version, they do not. This differs from the 
behavior in the Delphi VCL where the value in Height includes pixels used in 
non-client areas like the title bar, borders, frames, and scroll bars. LCL 
uses  this approach because there is no reliable way to determine the sizes for 
all of the non-client areas on all of the platforms where LCL is supported. 
Without a reliable way, the LCL would needlessly move the forms around on the 
screen or resize them endlessly. In the LCL, neither Height nor ClientHeight 
include the non-client area on a form instance. The height of a TMainMenu 
instance is omitted from both values as well.
</remark>
</descr>
<seealso>
<link id="TControl.ClientHeight"/>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.Width"/>
<link id="TControl.Parent"/>
<link id="TControl.GetClientRect"/>
<link id="TControl.SetBounds"/>
<link id="TControl.ChangeBounds"/>
</seealso>
</element>

<element name="TControl.Hint">
<short>The text to show in the Hint window for the control.</short>
<descr>
<p>
Hint is a TTranslateString property with hint text displayed in a pop-up 
window when the mouse is hovered over the control. The pop-up window is 
displayed when the ShowHint property is set to <b>True</b>.
</p>
<p>
Assign a value to Hint to describe the usage or formatting conventions used 
for the value entered in the control. For example:
</p>
<code>Edit1.Hint := 'Start Date in MM/DD/YYYY format';</code>
<p>
Hint can be given a value that includes both short and long variants of the 
hint text. The values are separated by a '|' (Vertical Bar) character in the 
property. For example:
</p>
<code>Edit1.Hint := 'Start Date | Start Date in MM/DD/YYYY format';</code>
<p>
The short variant is used in the pop-up hint window for the control. The long 
variant is assigned to the Application.Hint property, or displayed on a form 
status bar when its AutoHint property is set to <b>True</b>.
</p>
<p>
As a TTranslateString type, Hint can be localized using the translation 
facilities built into the LCL and the Lazarus IDE. The property value is 
written using LCL component streaming when the hint text for the control is 
not linked to an assigned Action.
</p>
<remark>
Hint is not the same value as the placeholder introduced as the TextHint 
property in descendent controls.
</remark>
</descr>
<seealso>
<link id="TControl.ShowHint"/>
<link id="TControl.ParentShowHint"/>
<link id="TControl.ActionLink"/>
<link id="TControlActionLink.IsHintLinked"/>
</seealso>
</element>

<element name="TControl.Top">
<short>The client coordinate for the top edge of the control.</short>
<descr>
<p>
<var>Top</var> is an <var>Integer</var> property with the coordinate for the 
top edge of the control relative to its Parent. Changing the value for the 
property causes SetBounds to be called to apply the new value for the 
property along with the existing values in Left, Width, and Height.
</p>
</descr>
<seealso>
<link id="TControl.Height"/>
<link id="TControl.Left"/>
<link id="TControl.Width"/>
<link id="TControl.Parent"/>
<link id="TControl.SetBounds"/>
<link id="TControl.ChangeBounds"/>
</seealso>
</element>

<element name="TControl.Width">
<short>
The horizontal size for the control.
</short>
<descr>
<p>
<var>Width</var> is an <var>Integer</var> property with the horizontal size 
for the control in pixels.
</p>
<p>
Setting a negative value in Width is not allowed, and the property defaults 
to <b>0</b> (zero). At design-time, setting Width to a value not in the range 
0..9999 causes an ELayoutException to be raised (and handled in the IDE).
</p>
<p>
Setting a new value for the property causes SetBounds and ChangeBounds to be 
called. This ensures that the new value is in the range allowed in Constraints, 
and that the control is aligned on its Parent using the Anchors for the control.
</p>
<p>
A value assigned to Width is ignored when AutoSize is set to <b>True</b>; the 
control is automatically adjusted to the size needed for its aligned content.
</p>
<p>
Values in Top, Left, Width, and Height are used to calculate the display area 
for the control in GetClientRect. They determine the clipping rectangle used 
when the control is drawn on its Parent.
</p>
<remark>
In the LCL, Width has the same value as ClientWidth. Derived classes (like 
TCustomForm or TForm) may implement a ClientWidth property that differs from 
Width - but in the current LCL version, they do not. This differs from the 
behavior in the Delphi VCL where the value in Width includes pixels used in 
non-client areas like the borders, frames, and scroll bars. LCL uses this 
approach because there is no reliable way to determine the sizes for all of the 
non-client areas on all of the platforms where LCL is supported. Without a 
reliable way, the LCL would needlessly move the forms around on the screen or 
resize them endlessly. In the LCL, neither Width nor ClientWidth include the 
non-client area on a form instance.
</remark>
</descr>
<seealso>
<link id="TControl.ClientWidth"/>
<link id="TControl.Height"/>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.Parent"/>
<link id="TControl.GetClientRect"/>
<link id="TControl.SetBounds"/>
<link id="TControl.ChangeBounds"/>
</seealso>
</element>

<element name="TControl.HelpType">
<short>
Indicates whether context-sensitive Help is selected by numeric ID or keyword.
</short>
<descr>
<p>
<var>HelpType</var> is a <var>THelpType</var> property which indicates the 
mechanism used to locate and display a help topic for the control.
</p>
<dl>
<dt>htKeyword</dt>
<dd>
Uses the value in HelpKeyword to locate help content for the control.
</dd>
<dt>htContext</dt>
<dd>
Uses the numeric identifier in the HelpContext property to locate help 
content for the control.
</dd>
</dl>
<p>
The default value for the property is htContext.
</p>
<p>
The value in HelpType is updated when an explicit value is assigned to the 
HelpKeyword or HelpContext properties.
</p>
<p>
HelpType is used in the ShowHelp method to select the TApplication method 
called to display the help content. When set to htContext, the HelpContext 
method in Application is called. When set to htKeyword, the HelpKeyword 
method in Application is called. If the help request cannot be handled using 
the values assigned to the control, the ShowHelp method in Parent is called 
(when assigned).
</p>
</descr>
<seealso>
<link id="TControl.HelpContext"/>
<link id="TControl.HelpKeyword"/>
<link id="#lcl.forms.TApplication.HelpContext">TApplication.HelpContext</link>
<link id="#lcl.forms.TApplication.HelpKeyword">TApplication.HelpKeyword</link>
<link id="#lcl.forms.TApplicationProperties.HelpFile">TApplicationProperties.HelpFile</link>
<link id="#lcl.forms.TCustomForm.HelpFile">TCustomForm.HelpFile</link>
<link id="#rtl.classes.THelpType">THelpType</link>
</seealso>
</element>

<element name="TControl.HelpKeyword">
<short>The context-sensitive Help keyword for the control.</short>
<descr>
<p>
<var>HelpKeyword</var> is a <var>String</var> type with the context-sensitive 
keyword used to locate and display a help topic for the control. When an 
value is assigned to the property, the HelpType property is set to htKeyword.
</p>
<p>
HelpKeyword is used in the ShowHelp method, and passed as an argument to the 
HelpKeyword method in the Application singleton.
</p>
<p>
Use HelpContext to specify a numeric context identifier for the help topic 
displayed for the control.
</p>
<p>
Use the HelpFile property, found on the parent form or in a 
TApplicationProperties instance, to set the help file with the content for 
the help topic.
</p>
</descr>
<seealso>
<link id="TControl.HelpContext"/>
<link id="TControl.HelpType"/>
<link id="TControl.ShowHelp"/>
<link id="#lcl.forms.TApplication.HelpKeyword">TApplication.HelpKeyword</link>
<link id="#lcl.forms.TApplicationProperties.HelpFile">TApplicationProperties.HelpFile</link>
<link id="#lcl.forms.TCustomForm.HelpFile">TCustomForm.HelpFile</link>
</seealso>
</element>

<element name="TControl.HelpContext">
<short>The numeric context-sensitive Help identifier for the control.</short>
<descr>
<p>
HelpContext is an Integer property with the numeric identifier used to locate 
and display a context-sensitive help topic for the control. The default value 
for the property is <b>0</b> (zero).
</p>
<p>
Setting a new value for the property causes HelpType to be changed to 
htContext.
</p>
<p>
HelpContext is used in the ShowHelp method, and passed as an argument to the 
HelpContext method in the Application singleton.
</p>
<p>
Use HelpKeyword to specify a string value with the help topic displayed for 
the control.
</p>
<p>
Use the HelpFile property, found on the parent form or in a 
TApplicationProperties instance, to set the help file with the content for 
the help topic.
</p>
</descr>
<seealso>
<link id="TControl.HelpKeyword"/>
<link id="TControl.HelpType"/>
<link id="TControl.ShowHelp"/>
<link id="#lcl.forms.TApplication.HelpKeyword">TApplication.HelpKeyword</link>
<link id="#lcl.forms.TApplicationProperties.HelpFile">TApplicationProperties.HelpFile</link>
<link id="#lcl.forms.TCustomForm.HelpFile">TCustomForm.HelpFile</link>
</seealso>
</element>

<element name="TBorderWidth">
<short>
Integer type used for <link id="TWinControl.BorderWidth"/>.
</short>
<descr>
<p>
<var>TBorderWidth</var> is an <var>Integer</var> type with the range of 
values that can be used as the width for a border on a control. TBorderWidth 
is the type used to implement the <var>BorderWidth</var> property in 
<var>TWinControl</var> and descendent classes.
</p>
</descr>
<seealso>
<link id="TWinControl.BorderWidth"/>
</seealso>
</element>

<element name="TGetChildProc">
<short>
Type used for a callback method, to be called for all children of a control.
</short>
<descr/>
<seealso>
<link id="TWinControl.GetChildren"/>
</seealso>
</element>
<element name="TGetChildProc.Child">
<short>The child control.</short>
</element>

<element name="TChildControlResizeStyle">
<short>
Defines how child controls are resized / aligned.
</short>
<descr>
<p>
<var>TChildControlResizeStyle</var> is an enumerated type with values that 
represent the resizing styles used to resize and position child controls in a 
grid (table) layout.
</p>
<p>
TChildControlResizeStyle the type used for the EnlargeHorizontal, 
EnlargeVertical, ShrinkHorizontal, and ShrinkVertical properties in 
TControlChildSizing.
</p>
<p>
The enumeration values identify the algorithm used to resize and position the 
child controls on a parent when its ChildSizing.Layout property set to a value 
other than clNone. The resizing algorithms apply to child controls which do 
<b>not</b> have settings in their Align, Anchors, or AnchorSide properties 
which determine the position / alignment for the child control. Anchored or 
aligned controls are excluded from the grid layout.
</p>
<p>
There are different algorithm for sizing the rows and columns in the grid. All 
algorithms base their calculations on the "PreferredSize" of the 
child-controls. This is usually the size to which the controls would autosize. 
For controls that have constraints, the PreferredSize is the size after 
applying those constraints. (E.g., a TLabel with 20 pixel of text, but a 
MinSize of 50 will report a PreferredSize of 50).
</p>
<p>
For each column or row in the grid, all child-controls in that column/row are 
checked for their PreferredSize. Each columns/rows size is then based on the 
largest PreferredSize it contains.
</p>
<p>
Rows/Columns will not shrink below the MinWidth/MinHeight of any child that 
they contain, even if the algorithm would compute a lower value. Any algorithm 
will instead shrink other Rows/Columns more aggressively. As a result other row
/columns can become invisible due to being zero sized. Also the grid may 
become wider than the control in which it is shown and will be cut off or need 
scrolling.
</p>
<p>
Rows/Columns will shrink (even if being otherwise enlarged) to the smallest 
MaxWidth/MaxHeight of any child they contain, if - and only if - that child 
has CellAlignHorizontal/CellAlignVertical = ccaFill. For other alignments rows/
cells will grow based on the PreferredSize. If the PreferredSize is the 
constrained Maximum, then the cell will still be scaled according to the 
algorithm, but the child will not fill the entire cell. If rows/columns are 
constrained by maximum values, then the grid may not fill the entire control 
in which it is shown.
</p>
<p>
All algorithms (except crsAnchorAligning) distribute the entire available 
parent's ClientArea to the grid for the children. Space for each 
child-controls' BorderSpacing and the parent's ChildSizing's spacing will be 
put around and between the cells.
</p>
<p>
See TControl.BorderSpacing and TControl.ChildSizing for more information.
</p>
<p>
When Constraints.MinWidth/MinHeight is used, the grid can become larger than 
the ClientArea. And when Constraints.MaxWidth/MaxHeight is used together with 
ccaFill, then the grid may end up smaller.
</p>
<p>
Conflicts between MaxWidth and MinWidth are solved by using the MaxWidth.
</p>
<p>
Child-controls will be sized to their cells dimension if they have 
BorderSpacing.CellAlignHorizontal/CellAlignVertical = ccaFill. Otherwise they 
will keep their preferred size and be placed inside the cell according to the 
specified position in CellAlign.
</p>
<dl>
<dt>crsAnchorAligning</dt>
<dd>
<p>
Uses a static layout for the child-controls. Each cell will have exactly the size of the 
largest PreferredWidth and largest PreferredHeight of any child in its row or column.
There is no scaling taking place.
</p>
<p>
crsAnchorAligning will not shrink any controls, since each cell will always be big enough to hold
the control at its preferred size.
crsAnchorAligning may grow a control, if other controls in the same row/column have a bigger preferred size 
and the control itself has an CellAlign of ccaFill. 
Cells will not grow past the biggest preferred size of any control in each cells' column or row.
</p>
<p>
The derived sizes for child controls and their positions do not change when the 
parent control is resized. This algorithm does not try to fill unused 
space on the parent control. Unused space is displayed to right of or beneath 
the control grid. The grid may also exceed the available space of the parent control.
</p>
</dd>
<dt>crsScaleChilds</dt>
<dd>
<p>
Scales child keeps the relative proportion between the children sizes. 
</p>
<p>
crsScaleChilds scales the size of each column or row to 
fit the space in the parent, while keeping the ratio of the rows/columns 
equal to the ratio of the PreferredSizes
</p>
<p>
The proportional ratio may not be kept, if child controls are limited by size constraints.
</p>
<p>
For a horizontal left-to-right layout with 3 controls A, B, and C:
</p>
<code>
Parent.ClientWidth = 120
A Preferred Width = 10
B Preferred Width = 20
C Preferred Width = 30
A, B, C are scaled by a factor of 2.0 (120/60) for scaled widths of 20, 40 and 
60 respectively.
</code>
<p>
If B has a maximum width constraint of 30, then A and C are resized equally 
with the remaining space made available by the size constraint. Scaling factor 
for A and C is (120-30)/40 or 2.25.
</p>
<code>
Parent.ClientWidth = 120
A.Width = 23
B.Width = 30
C.Width = 67
</code>
</dd>
<dt>crsHomogenousChildResize</dt>
<dd>
<p>
Enlarge or shrink child controls equally, i.e. by the same number of pixels.
</p>
<p>
crsHomogenousChildResize applies a homogenous size to child controls in the 
grid layout. All children are grown/shrunk by the same number of pixels.
</p>
<p>
The algorithm takes the difference between the parents ClientSize and the sum 
of all PreferredSizes. This difference (free or missing space in the parent 
control) is then divided by the number of rows/columns and the correct 
fraction of the space is added/subtracted to/from the size of each cell.
</p>
<p>
For a horizontal left-to-right layout with 3 controls A, B, and C:
</p>
<code>
Parent.ClientWidth = 120
A Preferred Width = 10
B Preferred Width = 20
C Preferred Width = 30
A, B, C are resized to include 20 additional pixels per child control (120-60)/3.
A.Width = 30
B.Width = 40
C.Width = 50
</code>
<p>
If B has a maximum width constraint of 30, then the size made available by the 
constraint is allocated equally to A and C. 120-30-10-30/2=25 pixels.
</p>  
<code>
A.Width = 35
B.Width = 30
C.Width = 55
</code>
</dd>
<dt>crsHomogenousSpaceResize</dt>
<dd>
<p>
Enlarges the space between child controls equally.
</p>
<p>
crsHomogenousSpaceResize applies a uniform number of pixels as horizontal or 
vertical spacing between child controls on the same column or row. 
</p>
<p>
The algorithm takes the difference between the parents ClientSize and the sum 
of all PreferredSizes. This difference (free or missing space in the parent 
control) is then divided by the number of rows/columns and the correct 
fraction of the space is added/subtracted to/from the spacing between the 
cells and the spacing at the border of the grid.
</p>
<p>
For a horizontal left-to-right layout with 3 controls A, B, and C:
</p>
<code>
Parent.ClientWidth = 120
A Preferred Width = 10
B Preferred Width = 20
C Preferred Width = 30
Unused space (120-60)/4=15 is allocated equally as Left, Right, and Horizontal spacing.
</code>
<p>
Column widths do not change when the parent control is resized; only the 
spacing between edges and columns is affected.
</p>
</dd>
<dt>crsSameSize</dt>
<dd>
<p>
Each child gets the same size (maybe one pixel difference due to rounding).
</p>
<p>
crsSameSize applies a uniform size to all columns or rows in the tabular 
layout. The unused space on the parent control, after BorderSpacing and 
ChildSizing spacings are applied, is allocated equally for the number of 
controls per line in the columns or rows. Size constraints (minimum or maximum) 
for child controls are enforced if a constraint would be enabled for the 
derived size. All child controls in the same column or row are given the same 
derived size.
</p>
<p>
For a horizontal left-to-right layout with 3 controls A, B, and C:
</p>
<code>
Parent.ClientWidth = 120
A Preferred Width = 10
B Preferred Width = 20
C Preferred Width = 30
Each column is given a width of 40 pixels (120/3).
A.Width = 40
B.Width = 40
C.Width = 40
</code>
<p>
If B has a maximum width constraint of 30, then the space made available by the 
size constraint is allocated equally to A and C.
</p>  
<code>
A.Width = 45
B.Width = 30
C.Width = 45
</code>
<p>
Column widths are recalculated when the parent control is resized.
</p>
</dd>
</dl>
<p>
Please note that the differences between the crsScaleChilds, 
crsHomogenousChildResize, and crsSameSize algorithms largely disappear when one 
or more of the child controls have a minimum or maximum size constraint applied.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.EnlargeHorizontal"/>
<link id="TControlChildSizing.EnlargeVertical"/>
<link id="TControlChildSizing.ShrinkHorizontal"/>
<link id="TControlChildSizing.ShrinkVertical"/>
<link id="TWinControl.ChildSizing"/>
<link id="TWinControl.CalculatePreferredSize"/>
<link id="TControl.GetPreferredSize"/>
<link id="TSizeConstraints"/>
<link id="TControlBorderSpacing"/>
</seealso>
</element>
<element name="TChildControlResizeStyle.crsAnchorAligning">
<short>
Uses a static layout for normally anchored controls.
</short>
</element>
<element name="TChildControlResizeStyle.crsScaleChilds">
<short>
Scale children keeping fixed space between children.
</short>
</element>
<element name="TChildControlResizeStyle.crsHomogenousChildResize">
<short>
Enlarge children equally, i.e. by the same number of pixels.
</short>
</element>
<element name="TChildControlResizeStyle.crsHomogenousSpaceResize">
<short>
Enlarge space between children equally.
</short>
</element>
<element name="TChildControlResizeStyle.crsSameSize">
<short>
Each child gets the same size (maybe one pixel difference).
</short>
</element>

<element name="TControlChildrenLayout">
<short>
Defines the logic used to arrange child controls.
</short>
<descr>
<p>
<var>TControlChildrenLayout</var> is an enumerated type with values that 
control the order of processing and arrangement of child controls. It is the 
type used to implement the Layout property in TControlChildSizing.
</p>
</descr>
<seealso>
<link id="TControlChildSizing"/>
<link id="TWinControl.ChildSizing"/>
</seealso>
</element>
<element name="TControlChildrenLayout.cclNone">
<short>
Child controls not arranged in a tabular layout. Child controls are positioned 
and sized using the Align and Anchors settings in the controls.
</short>
</element>
<element name="TControlChildrenLayout.cclLeftToRightThenTopToBottom">
<short>
Arranges controls in a row filled from left to right, and then top to bottom. 
The number of controls per line in TControlChildSizing determines when a new 
row is started. Uses the value in BiDiMode; when it contains bdRightToLeft the 
horizontal direction is reversed (Right to Left).
</short>
</element>
<element name="TControlChildrenLayout.cclTopToBottomThenLeftToRight">
<short>
Arranges controls in columns, from top to bottom and then left to right.
The number of controls per line in TControlChildSizing determines when a new 
column is started.
</short>
</element>

<element name="TControlChildSizing">
<short>
Provides settings to layout child-controls into a grid (table) layout.
</short>
<descr>
<p>
<var>TControlChildSizing</var> is a <var>TPersistent</var> descendant which 
provides properties and methods used to layout, align, and resize child 
controls fitting into a grid on their parent control.
</p>
<p>
<var>TControlChildSizing</var> also provided "Spacing" settings. 
Those are applied to the grid <b>and also</b> to anchored or aligned controls
outside the grid.
</p>
<p>
<var>Layout</var> and <var>ControlsPerLine</var> control if the grid is used,
how it is sized and in which order the child-controls are placed into the grid.
</p>
<p>
<var>EnlargeHorizontal</var>, <var>EnlargeVerticalHorizontal</var>, 
<var>ShrinkHorizontal</var>, <var>ShrinkVerticalHorizontal</var> define
how the cells of the grid are sized. Child-controls are then adjusted to that 
size depending on their BorderSpacing.CellAlignHorizontal/CellAlignVertical 
properties. 
</p>
<p>
<var>HorizontalSpacing</var>, <var>VerticalSpacingHorizontalSpacing</var>, 
<var>LeftRightSpacing</var>, <var>TopBottomSpacing</var> can be used to add
space between and around the cells.
</p>
<p>
See <link id="TChildControlResizeStyle"/> and <link 
id="TControlChildrenLayout"/> for details about the enumeration values used 
in the properties.
</p>
<p>
Additional information about child sizing and layout can be found on the 
Lazarus Wiki at:
</p>
<p>
<url href="https://wiki.lazarus.freepascal.org/Autosize_/_Layout">
Autosize / Layout
(https://wiki.lazarus.freepascal.org/Autosize_/_Layout)
</url>
</p>
<p>
<url href="https://wiki.lazarus.freepascal.org/LCL_AutoSizing">
LCL AutoSizing
(https://wiki.lazarus.freepascal.org/LCL_AutoSizing)
</url>
</p>
</descr>
<seealso>
<link id="TChildControlResizeStyle"/>
<link id="TControlChildrenLayout"/>
</seealso>
</element>

<element name="TControlChildSizing.FControl"/>
<element name="TControlChildSizing.FControlsPerLine"/>
<element name="TControlChildSizing.FEnlargeHorizontal"/>
<element name="TControlChildSizing.FEnlargeVertical"/>
<element name="TControlChildSizing.FHorizontalSpacing"/>
<element name="TControlChildSizing.FLayout"/>
<element name="TControlChildSizing.FLeftRightSpacing"/>
<element name="TControlChildSizing.FOnChange"/>
<element name="TControlChildSizing.FShrinkHorizontal"/>
<element name="TControlChildSizing.FShrinkVertical"/>
<element name="TControlChildSizing.FTopBottomSpacing"/>
<element name="TControlChildSizing.FVerticalSpacing"/>
<element name="TControlChildSizing.SetControlsPerLine" link="#lcl.controls.TControlChildSizing.ControlsPerLine"/>
<element name="TControlChildSizing.SetControlsPerLine.AValue"/>
<element name="TControlChildSizing.SetEnlargeHorizontal" link="#lcl.controls.TControlChildSizing.EnlargeHorizontal"/>
<element name="TControlChildSizing.SetEnlargeHorizontal.AValue"/>
<element name="TControlChildSizing.SetEnlargeVertical" link="#lcl.controls.TControlChildSizing.EnlargeVertical"/>
<element name="TControlChildSizing.SetEnlargeVertical.AValue"/>
<element name="TControlChildSizing.SetHorizontalSpacing" link="#lcl.controls.TControlChildSizing.HorizontalSpacing"/>
<element name="TControlChildSizing.SetHorizontalSpacing.AValue"/>
<element name="TControlChildSizing.SetLayout" link="#lcl.controls.TControlChildSizing.Layout"/>
<element name="TControlChildSizing.SetLayout.AValue"/>
<element name="TControlChildSizing.SetLeftRightSpacing" link="#lcl.controls.TControlChildSizing.LeftRightSpacing"/>
<element name="TControlChildSizing.SetLeftRightSpacing.AValue"/>
<element name="TControlChildSizing.SetShrinkHorizontal" link="#lcl.controls.TControlChildSizing.ShrinkHorizontal"/>
<element name="TControlChildSizing.SetShrinkHorizontal.AValue"/>
<element name="TControlChildSizing.SetShrinkVertical" link="#lcl.controls.TControlChildSizing.ShrinkVertical"/>
<element name="TControlChildSizing.SetShrinkVertical.AValue"/>
<element name="TControlChildSizing.SetTopBottomSpacing" link="#lcl.controls.TControlChildSizing.TopBottomSpacing"/>
<element name="TControlChildSizing.SetTopBottomSpacing.AValue"/>
<element name="TControlChildSizing.SetVerticalSpacing" link="#lcl.controls.TControlChildSizing.VerticalSpacing"/>
<element name="TControlChildSizing.SetVerticalSpacing.AValue"/>

<element name="TControlChildSizing.Change">
<short>
Notifies the Control of the child sizing changes and signals the OnChange 
event handler.
</short>
<descr>
<p>
The DoChildSizingChange method in Control is called to recalculate the size 
for its child controls and to realign them. The OnChange event handler is 
signalled (when assigned) to resize and realign the parent Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.OnChange"/>
<link id="TControlChildSizing.Control"/>
<link id="TWinControl.DoChildSizingChange"/>
</seealso>
</element>

<element name="TControlChildSizing.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the constructor for the class instance. Create calls the 
inherited constructor, and sets the default values for properties including:
</p>
<dl>
<dt>Control</dt>
<dd>Set to the value in the OwnerControl argument.</dd>
<dt>Layout</dt>
<dd>Set to cclNone.</dd>
<dt>EnlargeHorizontal, EnlargeVertical, ShrinkHorizontal, ShrinkVertical</dt>
<dd>Set to crsAnchorAligning.</dd>
</dl>
</descr>
</element>
<element name="TControlChildSizing.Create.OwnerControl">
<short>Control which owns the class instance.</short>
</element>

<element name="TControlChildSizing.Assign">
<short>
Copies property values from the specified persistent object into the current 
class instance.
</short>
<descr>
<p>
<var>Assign</var> is an overridden method in <var>TControlChildSizing</var> 
used to copy property values from the persistent object in <var>Source</var> 
to the corresponding properties in the current class instance. 
</p>
<p>
When Source is derived from TControlChildSizing, the properties specific to 
the class type are examined and copied. The Change method is called prior to 
exiting from the procedure.
</p>
<p>
The following property values are copied from Source:
</p>
<ul>
<li>EnlargeHorizontal</li>
<li>EnlargeVertical</li>
<li>ShrinkHorizontal</li>
<li>ShrinkVertical</li>
<li>ControlsPerLine</li>
<li>Layout</li>
<li>LeftRightSpacing</li>
<li>TopBottomSpacing</li>
<li>HorizontalSpacing</li>
<li>VerticalSpacing</li>
</ul>
<p>
No actions are performed in the method if the property values from Source have 
the same values as the properties in the class instance.
</p>
<p>
If Source is not derived from TControlChildSizing, the inherited Assign method 
is called to copy the values in Source.
</p>
</descr>
<seealso/>
</element>
<element name="TControlChildSizing.Assign.Source">
<short>
Persistent object with the property values copied in the method.
</short>
</element>

<element name="TControlChildSizing.AssignTo">
<short>
Copies property values from the current class instance to the specified 
persistent object.
</short>
<descr>
<p>
<var>AssignTo</var> calls the Assign method for the object instance in 
<var>Dest</var> using the current class instance as the source of the values 
copied in the method.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Assign"/>
<link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
</seealso>
</element>
<element name="TControlChildSizing.AssignTo.Dest">
<short>
Persistent object where the property values are stored.
</short>
</element>

<element name="TControlChildSizing.IsEqual">
<short>
Determines whether the specified sizing contains the same values as the 
current class instance.
</short>
<descr>
<p>
<var>IsEqual</var> is a <var>Boolean</var> function used to determine whether 
the <var>TControlChildSizing</var> instance in <var>Sizing</var> contains the 
same values as the current class instance. <var>IsEqual</var> compares the 
following properties to determine the return value:
</p>
<ul>
<li>EnlargeHorizontal</li>
<li>EnlargeVertical</li>
<li>ShrinkHorizontal</li>
<li>EnlargeHorizontal</li>
<li>ShrinkVertical</li>
<li>EnlargeVertical</li>
<li>ShrinkHorizontal</li>
<li>ShrinkVertical</li>
<li>ControlsPerLine</li>
<li>Layout</li>
<li>LeftRightSpacing</li>
<li>TopBottomSpacing</li>
<li>HorizontalSpacing</li>
<li>VerticalSpacing</li>
</ul>
<p>
The return value is <b>True</b> when the properties contain equivalent values 
in both class instances.
</p>
</descr>
<seealso/>
</element>
<element name="TControlChildSizing.IsEqual.Result">
<short>
<b>True</b> when the specified sizing contains the same values as the current 
class instance.
</short>
</element>
<element name="TControlChildSizing.IsEqual.Sizing">
<short>TControlChildSizing class instance compared in the method.</short>
</element>

<element name="TControlChildSizing.SetGridSpacing">
<short>
Sets spacing properties in the class instance to the specified value.
</short>
<descr>
<p>
<var>SetGridSpacing</var> is a convenience method used to set the values for 
the spacing properties to a uniform value. The properties are used when child 
controls are arranged into rows and columns when the Layout property has a 
value other than cclNone. 
</p>
<p>
The value in the <var>Spacing</var> argument is stored to the following 
properties:
</p>
<ul>
<li>LeftRightSpacing</li>
<li>TopBottomSpacing</li>
<li>HorizontalSpacing</li>
<li>VerticalSpacing</li>
</ul>
</descr>
<seealso>
<link id="TControlChildSizing.LeftRightSpacing"/>
<link id="TControlChildSizing.TopBottomSpacing"/>
<link id="TControlChildSizing.HorizontalSpacing"/>
<link id="TControlChildSizing.VerticalSpacing"/>
</seealso>
</element>
<element name="TControlChildSizing.SetGridSpacing.Spacing">
<short>
Integer value applied to each of the spacing properties.
</short>
</element>

<element name="TControlChildSizing.Control">
<short>
The Control where the class instance is used.
</short>
<descr>
<p>
<var>Control</var> is a read-only <var>TWinControl</var> property which 
contains a reference to the control where the TControlChildSizing is used. Its 
value is passed as the OwnerControl argument in the Create constructor. 
Control provides access to properties and methods in the parent control used 
to resize and/or realign its child controls. This occurs in the Change method 
when property value(s) in the class instance have been changed.
</p>
<p>
Control can also be used in the OnChange event handler as needed, but will 
likely need to be cast to a descendant class type to access it 
implementation-specific properties and methods.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Create"/>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.OnChange"/>
</seealso>
</element>

<element name="TControlChildSizing.ControlsPerLine">
<short>
The number of controls displayed per column or row for the orientation / fill 
direction specified in Layout.
</short>
<descr>
<p>
<var>ControlsPerLine</var> is an <var>Integer</var> property which indicates 
the number of child controls displayed in a column or row using the Layout for 
the Control. It is relevant when Layout is set to a value other than cclNone.
</p>
<p>
When Layout is set to cclLeftToRightThenTopToBottomm it indicates the child 
controls displayed per row. When Layout contains clTopToBottomThenLeftToRight, 
it indicates the child controls displayed per column. The default value is 0 
(zero), and indicates that an explicit value has not been assigned to the 
property and causes the grid Layout to act as if 1 was specified in the 
property value.
</p>
<p>
Changing the value in ControlsPerLine causes the Change method to be called to 
resize the child controls on the parent Control and signal the OnChange event 
handler (when assigned).
</p>
<p>
ControlsPerLine is used in controls like TRadioGroup and TCheckGroup to 
arrange the radio buttons or check boxes on the control into columns and rows.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Layout"/>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.OnChange"/>
<link id="TControlChildrenLayout"/>
</seealso>
</element>

<element name="TControlChildSizing.EnlargeHorizontal">
<short>
Indicates how child controls are expanded and aligned horizontally on the 
parent Control.
</short>
<descr>
<p>
<var>EnlargeHorizontal</var> is a <var>TChildControlResizeStyle</var> property 
which indicates how child controls are expanded or aligned horizontally on the 
parent Control. The default value for the property is crsAnchorAligning.
</p>
<p>
Child sizing styles include:
</p>
<dl>
<dt>crsAnchorAligning</dt>
<dd>
<p>
Uses a static layout based on the preferred width and size constraints for the 
child controls. Child controls widths are not changed when the parent Control 
is resized.
</p>
</dd>
<dt>crsHomogenousChildResize</dt>
<dd>
<p>  
Applies a homogenous width to child controls in a given column on the tabular 
layout. The width of child controls is expanded to fill the unused area in the 
parent Control after spacing and size constraints have been applied.
</p>
</dd>
<dt>crsHomogenousSpaceResize</dt>
<dd>
<p>
Applies a uniform number of pixels as horizontal spacing between child 
controls on the same row. The width for controls in a given column are derived 
using the preferred width for the controls and any width constraints (minimum 
or maximum) in the child controls. Any unused horizontal space on the Control 
is allocated equally as spacing before, between, and after each column in the 
tabular layout - including on the left and right edges of the Control.
</p>
<p>
Column widths do not change when the parent Control is resized; only the 
spacing between edges and columns is affected.
</p>
</dd>
<dt>crsScaleChilds</dt>
<dd>
<p>
Scales the width for child controls while keeping the space between them 
fixed. Children are resized so that the control widths are a ratio of their 
preferred widths (or size constraints) relative to the client area on the 
parent Control. Controls are scaled to fill the unused horizontal space. All 
controls in a given column are given the same derived width.
</p>
</dd>
<dt>
crsSameSize
</dt>
<dd>
<p>
Child controls use a uniform size for all controls in the same column for the 
tabular layout. Size constraints (minimum or maximum) for child controls are 
enforced if the constraint would be enabled for the column size. The unused 
space on the parent Control, after spacing, is allocated equally to columns 
where a size constraint is not in effect. Column widths are recalculated when 
the parent Control is resized.
</p>
</dd>
</dl>
<p>
See <link id="TChildControlResizeStyle"/> for more information about the child 
sizing layout algorithms.
</p>
<p>
The styles in EnlargeHorizontal, EnlargeVertical, ShrinkHorizontal, and  
ShrinkVertical are used when Layout is set to a value other than cclNone. The 
styles apply to child controls which have their Anchors set to [akLeft, 
akTop], Align set alNone, and are not anchored to another control using 
AnchorSide. Any control with other Anchors or Align settings cannot be 
displayed in the tabular layout.
</p>
<p>
The child controls are positioned using the BorderSpacing for the control (and 
its parent control) and the spacing values in LeftRightSpacing and 
HorizontalSpacing.
</p>
<p>
Setting a new value for EnlargeHorizontal causes the Change method to be 
called. This invalidate the preferred sizes for the child controls, and causes 
them to be realigned. The OnChange event handler is also signalled (when 
assigned).
</p>
<p>
Use ShrinkHorizontal to specify the child sizing style applied when control 
widths are reduced to fit within the client area for the parent Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Control"/>
<link id="TControlChildSizing.Layout"/>
<link id="TControlChildSizing.ShrinkHorizontal"/>
<link id="TControlChildSizing.LeftRightSpacing"/>
<link id="TControlChildSizing.HorizontalSpacing"/>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.OnChange"/>
<link id="TChildControlResizeStyle"/>
<link id="TControlBorderSpacing"/>
<link id="TSizeConstraints"/>
<link id="TControl.BorderSpacing"/>
<link id="TControl.Constraints"/>
</seealso>
</element>

<element name="TControlChildSizing.EnlargeVertical">
<short>
Indicates how child controls are expanded or aligned vertically on the parent 
Control.
</short>
<descr>
<p>
<var>EnlargeVertical</var> is a <var>TChildControlResizeStyle</var> property 
which indicates how child controls are expanded or aligned vertically on the 
parent Control. The default value for the property is crsAnchorAligning.
</p>
<p>
Child sizing styles include:
</p>
<dl>
<dt>crsAnchorAligning</dt>
<dd>
<p>
Uses a static layout based on the preferred height and size constraints for 
the child controls. Child controls heights are not changed when the parent 
Control is resized.
</p>
</dd>
<dt>crsScaleChilds</dt>
<dd>
<p>
Scales the width for child controls while keeping the space between them 
fixed. Children are resized so that the control heights are a ratio of their 
preferred widths (or size constraints) relative to the client area on the 
parent Control. Controls are scaled to fill the unused vertical space. All 
controls in a given row are given the same derived height.
</p>
</dd>
<dt>crsHomogenousChildResize</dt>
<dd>
<p>
Applies a homogenous height to child controls in a given row on the tabular 
layout. The height of child controls is expanded to fill the unused area in 
the parent Control after spacing and size constraints have been applied.
</p>
</dd>

<dt>crsHomogenousSpaceResize</dt>
<dd>
<p>
Applies a uniform number of pixels as vertical spacing between child controls 
on the same column. The height for controls in a given column are derived 
using the preferred height for the controls and any height constraints (
minimum or maximum) in the child controls. Any unused vertical space on the 
Control is allocated equally as spacing above, between, and below each row in 
the tabular layout - including on the top and bottom edges of the Control.
</p>
<p>
Row heights do not change when the parent Control is resized; only the 
spacing between edges and rows is affected.
</p>
</dd>
<dt>crsSameSize</dt>
<dd>
<p>
Child controls use a uniform size for all controls in the same row for the 
tabular layout. Size constraints (minimum or maximum) for child controls are 
enforced if the constraint would be enabled for the row size. The unused 
space on the parent Control, after spacing, is allocated equally to rows  
where a size constraint is not in effect. Row heights are recalculated when 
the parent Control is resized.
</p>
</dd>
</dl>
<p>
See <link id="TChildControlResizeStyle"/> for more information about the child 
sizing layout algorithms.
</p>
<p>
The styles in EnlargeHorizontal, EnlargeVertical, ShrinkHorizontal, and  
ShrinkVertical are used when Layout is set to a value other than cclNone. The 
styles apply to child controls which have their Anchors set to [akLeft, 
akTop], Align set alNone, and are not anchored to another control using 
AnchorSide. Any control with other Anchors or Align settings cannot be 
displayed in the tabular layout.
</p>
<p>
The child controls are positioned using the BorderSpacing for the control (and 
its parent control) and the spacing values in TopBottomSpacing and 
VerticalSpacing.
</p>
<p>
Setting a new value for EnlargeVertical causes the Change method to be 
called. This invalidate the preferred sizes for the child controls, and causes 
them to be realigned. The OnChange event handler is also signalled (when 
assigned).
</p>
<p>
Use ShrinkVertical to specify the child sizing style applied when control 
heights are reduced to fit within the client area for the parent Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Control"/>
<link id="TControlChildSizing.Layout"/>
<link id="TControlChildSizing.EnlargeHorizontal"/>
<link id="TChildControlResizeStyle"/>
</seealso>
</element>

<element name="TControlChildSizing.HorizontalSpacing">
<short>
Minimum space between child controls which are horizontally adjacent.
</short>
<descr>
<p>
HorizontalSpacing is the number of pixels reserved as space between 
horizontally adjacent child controls. It is used when Layout contains a value 
other than cclNone, but it also affects horizontal control spacing when using 
Anchors for positioning child controls on a parent.
</p>
<p>
Use VerticalSpacing to set the space reserved between vertically adjacent 
child control.
</p>
<p>
Use TopBottomSpacing to set the space reserved at the top or bottom edge for 
the Control.
</p>
<p>
Use LeftRightSpacing to set the space reserved at the left or right edge for 
the Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.VerticalSpacing"/>
<link id="TControlChildSizing.LeftRightSpacing"/>
<link id="TControlChildSizing.TopBottomSpacing"/>
<link id="TControlChildSizing.Layout"/>
</seealso>
</element>

<element name="TControlChildSizing.Layout">
<short>
Indicates the layout direction used when child controls are resized and 
arranged into rows and / or columns.
</short>
<descr>
<p>
<var>Layout</var> is a <var>TControlChildrenLayout</var> property which 
indicates the layout behavior for adjacent controls in the parent Control. 
Layout is used when methods in TControl descendants need to arrange their 
child controls into columns or rows.
</p>
<p>
The default value for the property is cclNone, and indicates that a layout 
direction has not been specified. This causes the design-time positioning in 
the Anchors, Align, and BorderSpacing properties for the child controls to be 
used.
</p>
<p>
Use cclLeftToRightThenTopToBottom or cclTopToBottomThenLeftToRight to 
layout child controls in column / row order using the BiDiMode settings for 
the Control. These values also enable use of the spacing and alignment 
settings in the class including: ControlsPerLine, HorizontalSpacing, 
VerticalSpacing, TopBottomSpacing, LeftRightSpacing, EnlargeHorizontal, and 
EnlargeVertical.
</p>
<p>
Changing the value for the property causes the Change method to be called to 
resize / realign child controls and to signal the OnChange event handler (when 
assigned).
</p>
<p>
Layout is used in TControl methods like WidthIsAnchored and HeightIsAnchored, 
and in the AlignControls method in TWinControl.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.Control"/>
<link id="TControlChildSizing.OnChange"/>
<link id="TControlChildrenLayout"/>
<link id="TWinControl.AlignControls"/>
<link id="TControl.HeightIsAnchored"/>
<link id="TControl.WidthIsAnchored"/>
<link id="TControl.Align"/>
<link id="TControl.Anchors"/>
<link id="TControl.BorderSpacing"/>
</seealso>
</element>

<element name="TControlChildSizing.LeftRightSpacing">
<short>
Minimum distance between the left or right edge for the Control and the left 
or right edge for a child control.
</short>
<descr>
<p>
LeftRightSpacing is an Integer property used to specify the number of pixels 
reserved at the left and right edges of the Control where the class instance 
is used. For example: When LeftRightSpacing is set to 5 for the Control, the 
Left property for a child control cannot be smaller than 5.
</p>
<p>
LeftRightSpacing (and the other spacing properties) are used when Layout 
contains a value other than cclNone.
</p>
<p>
Use TopBottomSpacing to reserve space on the corresponding edges for the 
Control.
</p>
<p>
Use HorizontalSpacing and VerticalSpacing to specify the space between child 
controls when a grid Layout is used.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.TopBottomSpacing"/>
<link id="TControlChildSizing.HorizontalSpacing"/>
<link id="TControlChildSizing.VerticalSpacing"/>
<link id="TControlChildSizing.Layout"/>
</seealso>
</element>

<element name="TControlChildSizing.OnChange">
<short>
Event handler signalled when the size or layout for child controls has been 
changed.
</short>
<descr>
<p>
<var>OnChange</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled (when assigned) from the Change method. It occurs after 
child controls have been resized and/or realigned.
</p>
<p>
The <var>Sender</var> argument is the TControlChildSizing instance for the 
event notification.
</p>
<p>
In a TWinControl instance, its DoChildSizingChange method is assigned as the 
default handler routine used in OnChange. It invalidates the preferred sizes 
for the child controls, and calls their Realign method.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Change"/>
<link id="TWinControl.DoChildSizingChange"/>
<link id="TWinControl.Realign"/>
<link id="TControl.InvalidatePreferredSize"/>
</seealso>
</element>

<element name="TControlChildSizing.ShrinkHorizontal">
<short>
Indicates how child controls are shrunk and aligned horizontally on the parent 
Control.
</short>
<descr>
<p>
<var>ShrinkHorizontal</var> is a <var>TChildControlResizeStyle</var> property 
which indicates how child controls are resized and aligned horizontally on the 
parent control. It can contain one of the values from the 
TChildControlResizeStyle enumeration. The default value for the property is 
<var>crsAnchorAligning</var>.
</p>
<p>
Child sizing styles include:
</p>
<dl>
<dt>crsAnchorAligning</dt>
<dd>
<p>
Uses a static layout based on the preferred width and size constraints for the 
child controls. Child controls widths are not changed when the parent Control 
is resized.
</p>
</dd>
<dt>crsHomogenousChildResize</dt>
<dd>
<p>  
Applies a homogenous width to child controls in a given column on the tabular 
layout. The width of child controls is reduced to fill the client area in the 
parent Control after spacing and size constraints have been applied.
</p>
</dd>
<dt>crsHomogenousSpaceResize</dt>
<dd>
<p>
Applies a uniform number of pixels as horizontal spacing between child 
controls on the same row. The width for controls in a given column are derived 
using the preferred width for the controls and any width constraints (minimum 
or maximum) in the child controls. Any unused horizontal space on the Control 
is allocated equally as spacing before, between, and after each column in the 
tabular layout - including on the left and right edges of the Control.
</p>
<p>
Column widths do not change when the parent Control is resized; only the 
spacing between edges and columns is affected.
</p>
</dd>
<dt>crsScaleChilds</dt>
<dd>
<p>
Scales the width for child controls while keeping the space between them 
fixed. Children are resized so that the control widths are a ratio of their 
preferred widths (or size constraints) relative to the client area on the 
parent Control. Controls are scaled to fill the client width in the parent 
Control. All controls in a given column are given the same derived width.
</p>
</dd>
<dt>
crsSameSize
</dt>
<dd>
<p>
Child controls use a uniform size for all controls in the same column for the 
tabular layout. Size constraints (minimum or maximum) for child controls are 
enforced if the constraint would be enabled for the column size. The client 
width for the parent Control, after spacing, is allocated equally to columns 
where a size constraint is not in effect. Column widths are recalculated when 
the parent Control is resized.
</p>
</dd>
</dl>
<p>
See <link id="TChildControlResizeStyle"/> for more information about the child 
sizing layout algorithms.
</p>
<p>
The styles in EnlargeHorizontal, EnlargeVertical, ShrinkHorizontal, and  
ShrinkVertical are used when Layout is set to a value other than cclNone. The 
styles apply to child controls which have their Anchors set to [akLeft, 
akTop], Align set alNone, and are not anchored to another control using 
AnchorSide. Any control with other Anchors or Align settings cannot be 
displayed in the tabular layout.
</p>
<p>
The child controls are positioned using the BorderSpacing for the control (and 
its parent control) and the spacing values in LeftRightSpacing and 
HorizontalSpacing.
</p>
<p>
Setting a new value for ShrinkHorizontal causes the Change method to be 
called. This invalidate the preferred sizes for the child controls, and causes 
them to be realigned. The OnChange event handler is also signalled (when 
assigned).
</p>
<p>
Use EnlargeHorizontal to specify the child sizing style applied when control 
widths are expanded to fit within the client area for the parent Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Control"/>
<link id="TControlChildSizing.Layout"/>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.OnChange"/>
<link id="TControlChildSizing.EnlargeHorizontal"/>
<link id="TControlChildSizing.LeftRightSpacing"/>
<link id="TControlChildSizing.HorizontalSpacing"/>
<link id="TChildControlResizeStyle"/>
<link id="TControlBorderSpacing"/>
<link id="TSizeConstraints"/>
<link id="TControl.BorderSpacing"/>
<link id="TControl.Constraints"/>
</seealso>
</element>

<element name="TControlChildSizing.ShrinkVertical">
<short>
Indicates how child controls are shrunk and aligned vertically on the parent 
Control.
</short>
<descr>
<p>
<var>ShrinkVertical</var> is a <var>TChildControlResizeStyle</var> property 
which indicates if and how child controls are resized and aligned vertically 
on the parent control. It can contain one of the values from the 
TChildControlResizeStyle enumeration. The default value for the property is 
<var>crsAnchorAligning</var>. 
</p>
<p>
Child sizing styles include:
</p>
<dl>
<dt>crsAnchorAligning</dt>
<dd>
<p>
Uses a static layout based on the preferred height and size constraints for 
the child controls. Child controls heights are not changed when the parent 
Control is resized.
</p>
</dd>
<dt>crsScaleChilds</dt>
<dd>
<p>
Scales the width for child controls while keeping the space between them 
fixed. Children are resized so that the control heights are a ratio of their 
preferred heights (or size constraints) relative to the client area on the 
parent Control. Controls are scaled to fill the client height in the parent 
control. All controls in a given row are given the same derived height.
</p>
</dd>
<dt>crsHomogenousChildResize</dt>
<dd>
<p>
Applies a homogenous height to child controls in a given row on the tabular 
layout. The height of child controls is reduced to fill the client height in 
the parent Control after spacing and size constraints have been applied.
</p>
</dd>
<dt>crsHomogenousSpaceResize</dt>
<dd>
<p>
Applies a uniform number of pixels as vertical spacing between child controls 
in the same column. The height for controls in a given column are derived 
using the preferred height for the controls and any height constraints 
(minimum or maximum) in the child controls. Any unused vertical space on the 
Control is allocated equally as spacing above, between, and below each row in 
the tabular layout - including on the top and bottom edges of the Control.
</p>
<p>
Row heights do not change when the parent Control is resized; only the 
spacing between edges and rows is affected.
</p>
</dd>
<dt>crsSameSize</dt>
<dd>
<p>
Child controls use a uniform height for all controls in the same row for the 
tabular layout. Size constraints (minimum or maximum) for child controls are 
enforced if the constraint would be enabled for the row size. The unused 
space on the parent Control, after spacing, is allocated equally to rows  
where a size constraint is not in effect. Row heights are recalculated when 
the parent Control is resized.
</p>
</dd>
</dl>
<p>
See <link id="TChildControlResizeStyle"/> for more information about the child 
sizing layout algorithms.
</p>
<p>
The styles in EnlargeHorizontal, EnlargeVertical, ShrinkHorizontal, and  
ShrinkVertical are used when Layout is set to a value other than cclNone. The 
styles apply to child controls which have their Anchors set to [akLeft, 
akTop], Align set alNone, and are not anchored to another control using 
AnchorSide. Any control with other Anchors or Align settings cannot be 
displayed in the tabular layout.
</p>
<p>
The child controls are positioned using the BorderSpacing for the control (and 
its parent control) and the spacing values in TopBottomSpacing and 
VerticalSpacing.
</p>
<p>
Changing the value for the ShrinkVertical property causes the Change method 
to be called. This causes child controls to recalculate their preferred size 
and to be realigned on the Control. The OnChange event handler is also 
signalled (when assigned).
</p>
<p>
Use EnlargeVertical to specify the child sizing style applied when control 
heights are expanded to fit within the client area for the parent Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Control"/>
<link id="TControlChildSizing.Layout"/>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.OnChange"/>
<link id="TControlChildSizing.EnlargeHorizontal"/>
<link id="TWinControl.Realign"/>
<link id="TControl.Align"/>
<link id="TControl.Anchors"/>
<link id="TControl.BorderSpacing"/>
<link id="TControl.Constraints"/>
<link id="TChildControlResizeStyle"/>
</seealso>
</element>

<element name="TControlChildSizing.TopBottomSpacing">
<short>
Minimum distance between the top or bottom edge of a Control and the top or 
bottom edge for a child control.
</short>
<descr>
<p>
<var>TopBottomSpacing</var> is an <var>Integer</var> property with the number 
of pixels reserved as spacing between child controls and the top and bottom 
edges of the Control. For example: When TopBottomSpacing is set to 5 for a 
Control, the Top property for a child control starts at 5.
</p>
<p>
The default value for the property is 0 (zero) and indicates that no 
additional space is reserved on the corresponding edges of the Control. 
Changing the value for the property causes the Change method to be called to 
resize/realign child controls. The OnChange event handler is also signalled 
(when assigned).
</p>
<p>
TopBottomSpacing also affects control alignment when using Anchors for 
positioning child controls on a parent.
</p>
<p>
Use VerticalSpacing to reserve space between vertically adjacent child 
controls in a column on the tabular Layout.
</p>
<p>
Use LeftRightSpacing to reserved space on the left and right edges of the 
Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.OnChange"/>
<link id="TControlChildSizing.Layout"/>
<link id="TControlChildSizing.ControlsPerLine"/>
<link id="TControlChildSizing.VerticalSpacing"/>
<link id="TControlChildSizing.LeftRightSpacing"/>
</seealso>
</element>

<element name="TControlChildSizing.VerticalSpacing">
<short>
Minimum space between child controls which are vertically adjacent.
</short>
<descr>
<p>
<var>VerticalSpacing</var> is an <var>Integer</var> property with the number 
of pixels reserved as spacing between vertically adjacent child controls. The 
default value for the property is 0 (zero) and indicates that no additional 
space is reserved on the corresponding edges of the Control. Changing the 
value for the property causes the Change method to be called to resize/realign 
child controls. The OnChange event handler is also signalled (when assigned).
</p>
<p>
VerticalSpacing also affects control spacing when using Anchors for 
positioning child controls on a parent.
</p>
<p>
Use HorizontalSpacing to set the space reserved between horizontally adjacent 
child control.
</p>
<p>
Use TopBottomSpacing to set the space reserved at the top or bottom edge for 
the Control.
</p>
</descr>
<seealso>
<link id="TControlChildSizing.Change"/>
<link id="TControlChildSizing.OnChange"/>
<link id="TControlChildSizing.Layout"/>
<link id="TControlChildSizing.ControlsPerLine"/>
<link id="TControlChildSizing.TopBottomSpacing"/>
<link id="TControlChildSizing.HorizontalSpacing"/>
</seealso>
</element>

<element name="TWinControlActionLink">
<short>Alias for the TControlActionLink type.</short>
<descr>
<p>
Since HelpContext and HelpKeyword are properties of TControl, this class is 
obsolete. To maintain compatibility with existing code, its declaration is 
aliased to TControlActionLink.
</p>
</descr>
<seealso>
<link id="TControlActionLink"/>
</seealso>
</element>

<element name="TWinControlActionLinkClass">
<short>
Class type used to create new instances of TWinControlActionLink.
</short>
<descr/>
<seealso>
<link id="TWinControlActionLink"/>
</seealso>
</element>

<element name="TWinControlFlag">
<short>State flags of TWinControl.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControlFlag.wcfClientRectNeedsUpdate">
<short>Client rectangle has been invalidated and needs to be updated.</short>
</element>
<element name="TWinControlFlag.wcfColorChanged">
<short>The Color property in s control has been changed.</short>
</element>
<element name="TWinControlFlag.wcfFontChanged">
<short>Set when the font was changed before handle creation.</short>
</element>
<element name="TWinControlFlag.wcfAllAutoSizing">
<short>Set during DoAllAutosize.</short>
</element>
<element name="TWinControlFlag.wcfAligningControls">
<short>Set when the AlignControls method is called.</short>
</element>
<element name="TWinControlFlag.wcfEraseBackground">
<short>
Set in the method Paint before the LM_ERASEBKGND message is performed.
</short>
</element>
<element name="TWinControlFlag.wcfCreatingHandle">
<short>Set while constructing the handle of this control.</short>
</element>
<element name="TWinControlFlag.wcfInitializing">
<short>Set while initializing during handle creation.</short>
</element>
<element name="TWinControlFlag.wcfCreatingChildHandles">
<short>Set while constructing the handles of the children.</short>
</element>
<element name="TWinControlFlag.wcfRealizingBounds">
<short>Set inside RealizeBoundsRecursive.</short>
</element>
<element name="TWinControlFlag.wcfBoundsRealized">
<short>
Set before bounds are sent to the widget; used to suppress subsequent size 
messages sent by the widget.
</short>
</element>
<element name="TWinControlFlag.wcfUpdateShowing">
<short>
Set before a visible control and its children are updated during auto-sizing.
</short>
</element>
<element name="TWinControlFlag.wcfHandleVisible">
<short>Set when a control is visible and not obscured on its parent.</short>
</element>
<element name="TWinControlFlag.wcfAdjustedLogicalClientRectValid">
<short>Set when the adjusted ClientRect is valid.</short>
<seealso>
<link id="TWinControl.GetAdjustedLogicalClientRect"/>
</seealso>
</element>
<element name="TWinControlFlag.wcfKillIntfSetBounds">
<short>
Set when the LCL interface has already called SetBounds during size and move 
operations. Prevents a loop.
</short>
</element>
<element name="TWinControlFlag.wcfDesignerDeleting">
<short>Only used for TCustomPairSplitter / TPairSplitter.</short>
</element>
<element name="TWinControlFlag.wcfSpecialSubContro">
<short>Only used for TCustomPairSplitter / TPairSplitter.</short>
</element>

<element name="TWinControlFlags">
<short>
Set type used to store TWinControlFlag enumeration values.
</short>
<descr>
<p>
<var>TWinControlFlags</var> is a set type used to store zero (0) or more 
values from the <var>TWinControlFlag</var> enumeration. TWinControlFlags is 
the type used to implement an internal member in TWinControl. Values are 
added to and removed from the set as needed in <var>TWinControl</var> methods.
</p>
</descr>
<seealso>
<link id="TWinControlFlag"/>
<link id="TWinControl"/>
</seealso>
</element>

<element name="TControlAtPosFlag">
<short>
Flags for finding a control at a given (client) position.
</short>
<descr>
<p>
TControlAtPosFlag is an enumeration type with values that indicate the 
mechanism used to locate a control at a given client position.
</p>
<p>
Values from the enumeration are stored in the TControlAtPosFlags type.
</p>
<p>
TControlAtPosFlag enumeration values are used in the implementation of the 
ControlAtPos method in TWinControl, and in the FindControlAtPosition function.
</p>
</descr>
<seealso>
<link id="TWinControl.ControlAtPos"/>
<link id="FindControlAtPosition"/>
</seealso>
</element>
<element name="TControlAtPosFlag.capfAllowDisabled">
<short>Include disabled controls when set.</short>
</element>
<element name="TControlAtPosFlag.capfAllowWinControls">
<short>Include both TWinControls and TControl instances when set.</short>
</element>
<element name="TControlAtPosFlag.capfOnlyClientAreas">
<short>Checks for hits are limited to the client area when set.</short>
</element>
<element name="TControlAtPosFlag.capfRecursive">
<short>Recurse into grand-children controls when set.</short>
</element>
<element name="TControlAtPosFlag.capfHasScrollOffset">
<short>Scroll offset is already included in the coordinates when set.</short>
</element>
<element name="TControlAtPosFlag.capfOnlyWinControls">
<short>Include only TWinControls (and ignore TControls) when set.</short>
</element>

<element name="TControlAtPosFlags">
<short>
Set type used to store values from the TControlAtPosFlag enumeration.
</short>
<descr>
<p>
Passed as an argument to the ControlAtPos method in TWinControl. Used 
internally in the implementation of the FindControlAtPosition routine.
</p>
</descr>
<seealso>
<link id="TControlAtPosFlag"/>
<link id="TWinControl.ControlAtPos"/>
<link id="FindControlAtPosition"/>
</seealso>
</element>

<element name="TAlignInfo">
<short>Used in custom alignment (alCustom).</short>
<descr>
<p>
This record was added for compatibility with Delphi releases after Version 7. 
It is used in CustomInsertBefore and CustomAlignPosition methods and handlers.
</p>
</descr>
<seealso>
<link id="TWinControl.CustomAlignPosition"/>
<link id="TWinControl.CustomAlignInsertBefore"/>
</seealso>
</element>

<element name="TAlignInfo.AlignList">
<short>The list of controls currently being aligned.</short>
</element>

<element name="TAlignInfo.ControlIndex">
<short>Index of current control.</short>
</element>

<element name="TAlignInfo.Align">
<short>The kind of alignment currently processed (always alCustom).</short>
</element>

<element name="TAlignInfo.Scratch">
<short>For internal use.</short>
</element>

<element name="TAlignInsertBeforeEvent">
<short>Type of an OnAlignInsertBefore handler.</short>
<descr>
The handler determines the order used to align both controls.
</descr>
<seealso>
<link id="TWinControl.CustomAlignInsertBefore"/>
</seealso>
</element>
<element name="TAlignInsertBeforeEvent.Result">
<short>
<b>True</b> if Control2 shall be placed before Control1 is placed.
</short>
</element>
<element name="TAlignInsertBeforeEvent.Sender">
<short>The Parent control.</short>
</element>
<element name="TAlignInsertBeforeEvent.Control1">
<short/>
</element>
<element name="TAlignInsertBeforeEvent.Control2">
<short/>
</element>

<element name="TAlignPositionEvent">
<short>Type of an OnAlignPosition handler.</short>
<descr>
<p>
Specified an event handler which positions the Control using the specified 
coordinates and alignment information.
</p>
</descr>
<seealso>
<link id="TWinControl.CustomAlignPosition"/>
</seealso>
</element>
<element name="TAlignPositionEvent.Sender">
<short>TWinControl generating the event notification.</short>
</element>
<element name="TAlignPositionEvent.Control">
<short>The control to position.</short>
</element>
<element name="TAlignPositionEvent.NewLeft">
<short>New Left coordinate for the control.</short>
</element>
<element name="TAlignPositionEvent.NewTop">
<short>New Top coordinate for the control.</short>
</element>
<element name="TAlignPositionEvent.NewWidth">
<short>New Width for the control.</short>
</element>
<element name="TAlignPositionEvent.NewHeight">
<short>New Height for the control.</short>
</element>
<element name="TAlignPositionEvent.AlignRect">
<short>The remaining ClientRect.</short>
</element>
<element name="TAlignPositionEvent.AlignInfo">
<short>Information about the current align process.</short>
</element>

<element name="TWinControlEnumerator">
<short>Implements an enumerator for TWinControl instances.</short>
<descr>
<p>
<var>TWinControlEnumerator</var> is a class used to implement an enumerator 
for <var>TWinControl</var> class instances. TWinControlEnumerator provides 
support the enumerator interface through its <var>GetCurrent</var> and 
<var>MoveNext</var> methods.
</p>
<p>
<var>TWinControlEnumerator</var> is the type returned by the 
<var>GetEnumeratorControls</var> and <var>GetEnumeratorControlsReverse</var> 
functions in <var>TWinControl</var>.
</p>
</descr>
<seealso>
<link id="TWinControlEnumerator.Current"/>
<link id="TWinControlEnumerator.MoveNext"/>
<link id="TWinControl.GetEnumeratorControls"/>
<link id="TWinControl.GetEnumeratorControlsReverse"/>
</seealso>
</element>

<element name="TWinControlEnumerator.FIndex">
<short>Member with the current position for the enumerator.</short>
</element>
<element name="TWinControlEnumerator.FLowToHigh">
<short>Member which indicates the order for the enumerator.</short>
</element>
<element name="TWinControlEnumerator.FParent">
<short>Member with the Parent for the enumerated values.</short>
</element>

<element name="TWinControlEnumerator.GetCurrent">
<short>Gets the current enumerator value.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControlEnumerator.GetCurrent.Result">
<short>The enumerator instance.</short>
</element>

<element name="TWinControlEnumerator.Create">
<short>Constructor for the class instance.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControlEnumerator.Create.Parent">
<short>Control which is the Parent for the enumerator.</short>
</element>
<element name="TWinControlEnumerator.Create.aLowToHigh">
<short>The enumerator uses ascending order when <b>True</b> (default).</short>
</element>

<element name="TWinControlEnumerator.GetEnumerator">
<short>
Returns the enumerator in the class instance (Self).
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControlEnumerator.GetEnumerator.Result">
<short>
Returns the enumerator in the class instance (Self).
</short>
</element>

<element name="TWinControlEnumerator.MoveNext">
<short>
Moves to the next value using the ordering in effect for the enumerator.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControlEnumerator.MoveNext.Result">
<short>Next value for the enumerator.</short>
</element>

<element name="TWinControlEnumerator.Current">
<short>
Contains the TControl instance which is the current value in the enumerator.
</short>
<descr>
<p>
<var>Current</var> is a read-only <var>TControl</var> property with the 
current value in the enumerator. It represents one of the child controls in 
the TWinControl instance passed as an argument to the Create constructor.
</p>
<p>
Use MoveNext to move the enumerator to the next control in the order used for 
the enumerator.
</p>
</descr>
<seealso>
<link id="TWinControlEnumerator.GetCurrent"/>
<link id="TWinControlEnumerator.MoveNext"/>
<link id="TWinControlEnumerator.Create"/>
</seealso>
</element>

<element name="TWinControl">
<short>
Implements a windowed control which can contain other child controls.
</short>
<descr>
<p>
<var>TWinControl</var> is a <var>TControl</var> descendant which implements a 
base class for controls that can contain child controls. The name reflects 
the fact that (on Windows platforms) the controls are based on OS-provided 
widgets, which have window Handles.
</p>
<p>
TWinControl extends the ancestor class with new properties, methods, and 
events which are specific to the windowed control. It also provides 
overridden methods which re-implement the functionality for some inherited 
methods. The properties, methods, and event fall into categories like:
</p>
<ul>
<li>Hi-DPI Awareness and Scaling</li>
<li>Control, Window, and Notification Message Handlers</li>
<li>Keyboard and Mouse Message Handlers</li>
<li>Drag and Drop, Drag and Dock</li>
<li>Sizing, Positioning, and Alignment</li>
<li>Alternate Constructors and Class Functions used to create TWinControl 
Instances</li>
<li>Forward and Reverse Enumerators for Child Controls</li>
</ul>
<p>
TWinControl is often used as the ancestor for control classes defined in the 
LCL. For example: TButtonControl, TCustomCalendar, TCustomComboBox, 
TCustomControl, TCustomEdit, TCustomGroupBox, TCustomListBox, 
TCustomListView, TCustomPage, TCustomPairSplitter, TCustomProgressBar, 
TCustomRubberBand, TCustomScrollBar, TCustomStaticText, TCustomTabControl, 
TCustomTrackBar, TPreviewFileControl, and TStatusBar.
</p>
</descr>
<seealso>
<link id="TControl"/>
</seealso>
</element>

<element name="TWinControl.FAlignOrder"/>
<element name="TWinControl.FBorderWidth"/>
<element name="TWinControl.FBoundsLockCount"/>

<element name="TWinControl.FBoundsRealized">
<short>
The bounds as sent to the widget. Used to suppress feedback messages from the 
widget.
</short>
</element>

<element name="TWinControl.FBorderStyle"/>
<element name="TWinControl.FBrush"/>
<element name="TWinControl.FAdjustClientRectRealized"/>
<element name="TWinControl.FAdjustClientRect"/>
<element name="TWinControl.FChildSizing"/>
<element name="TWinControl.FControls"/>
<element name="TWinControl.FOnGetDockCaption"/>
<element name="TWinControl.FDefWndProc"/>
<element name="TWinControl.FDockClients"/>
<element name="TWinControl.FClientWidth"/>
<element name="TWinControl.FClientHeight"/>
<element name="TWinControl.FDockManager"/>
<element name="TWinControl.FFlipped"/>
<element name="TWinControl.FOnAlignInsertBefore"/>
<element name="TWinControl.FOnAlignPosition"/>
<element name="TWinControl.FOnDockDrop"/>
<element name="TWinControl.FOnDockOver"/>
<element name="TWinControl.FOnGetSiteInfo"/>
<element name="TWinControl.FOnKeyDown"/>
<element name="TWinControl.FOnKeyPress"/>
<element name="TWinControl.FOnKeyUp"/>
<element name="TWinControl.FOnEnter"/>
<element name="TWinControl.FOnExit"/>
<element name="TWinControl.FOnUnDock"/>
<element name="TWinControl.FOnUTF8KeyPress"/>
<element name="TWinControl.FParentDoubleBuffered"/>
<element name="TWinControl.FParentWindow"/>
<element name="TWinControl.FRealizeBoundsLockCount"/>
<element name="TWinControl.FHandle"/>
<element name="TWinControl.FTabOrder"/>
<element name="TWinControl.FTabList"/>
<element name="TWinControl.FTabStop"/>
<element name="TWinControl.FShowing"/>
<element name="TWinControl.FDockSite"/>
<element name="TWinControl.FUseDockManager"/>

<element name="TWinControl.AlignControl">
<short>Aligns the control and its child controls.</short>
<descr>
<p>
<var>AlignControl</var> is a procedure used to align the control (and its 
child controls) relative to the control specified in <var>AControl</var>. 
AControl can contain the value <b>Nil</b> to indicate a containing control is 
not used to align the control instance.
</p>
<p>
AlignControl calls <var>DisableAlign</var> on entry, and 
<var>EnableAlign</var> prior to exiting from the method.
</p>
<remark>
No actions are performed in the method when the control is being freed (the 
value csDestroying is in ComponentState).
</remark>
<p>
AlignControl gets the client rectangle used to display the control, and calls 
<var>AdjustClientRect</var> to allocate border spacing when needed. 
<var>AlignControls</var> is called to align child controls relative to the 
control in AControl using the calculated client rectangle. Some widgetsets 
update their client rectangle when the first child is positioned; a second 
call to AlignControls is made if the client rectangle is altered in the 
initial call to the method.
</p>
<p>
AlignControl is used in the implementation of the <var>DoAllAutoSize</var> 
method in <var>TControl</var>.
</p>
</descr>
<seealso>
<link id="TControl.DoAllAutoSize"/>
</seealso>
</element>
<element name="TWinControl.AlignControl.AControl">
<short>
Control which provides the relative position for the control and its children.
</short>
</element>

<element name="TWinControl.DoubleBufferedIsStored">
<short>
Implements the storage specifier for the DoubleBuffered property.
</short>
<descr>
<p>Contains <b>True</b> when the Parent control has not enabled its 
DoubleBuffered property.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.DoubleBufferedIsStored.Result">
<short>
<b>True</b> when the Parent control has not enabled its DoubleBuffered 
property.
</short>
</element>

<element name="TWinControl.GetBrush" link="#lcl.controls.TWinControl.Brush"/>
<element name="TWinControl.GetBrush.Result"/>
<element name="TWinControl.GetControl" link="#lcl.controls.TWinControl.Controls"/>
<element name="TWinControl.GetControl.Result"/>
<element name="TWinControl.GetControl.Index"/>
<element name="TWinControl.GetControlCount" link="#lcl.controls.TWinControl.ControlCount"/>
<element name="TWinControl.GetControlCount.Result"/>
<element name="TWinControl.GetDockClientCount" link="#lcl.controls.TWinControl.DockClientCount"/>
<element name="TWinControl.GetDockClientCount.Result"/>
<element name="TWinControl.GetDockClients" link="#lcl.controls.TWinControl.DockClients"/>
<element name="TWinControl.GetDockClients.Result"/>
<element name="TWinControl.GetDockClients.Index"/>
<element name="TWinControl.GetHandle" link="#lcl.controls.TWinControl.Handle" />
<element name="TWinControl.GetHandle.Result"/>
<element name="TWinControl.GetIsResizing" link="#lcl.controls.TWinControl.IsResizing"/>
<element name="TWinControl.GetIsResizing.Result"/>

<element name="TWinControl.GetIsSpecialSubControl">
<short>Gets the value for the IsSpecialSubControl property.</short>
<descr/>
<seealso>
<link id="TWinControl.IsSpecialSubControl"/>
</seealso>
</element>
<element name="TWinControl.GetIsSpecialSubControl.Result">
<short>Value for the property.</short>
</element>

<element name="TWinControl.GetTabOrder" link="#lcl.controls.TWinControl.TabOrder"/>
<element name="TWinControl.GetTabOrder.Result"/>
<element name="TWinControl.GetVisibleDockClientCount"/>
<element name="TWinControl.GetVisibleDockClientCount.Result"/>
<element name="TWinControl.SetChildSizing" link="#lcl.controls.TWinControl.ChildSizing"/>
<element name="TWinControl.SetChildSizing.AValue"/>

<element name="TWinControl.SetDesignerDeleting">
<short>Sets the value for the DesignerDeleting property.</short>
<descr/>
<seealso>
<link id="TWinControl.DesignerDeleting"/>
</seealso>
</element>
<element name="TWinControl.SetDesignerDeleting.AValue">
<short>New value for the DesignerDeleting property.</short>
</element>

<element name="TWinControl.SetDockSite" link="#lcl.controls.TWinControl.DockSite"/>
<element name="TWinControl.SetDockSite.NewDockSite"/>
<element name="TWinControl.SetHandle" link="#lcl.controls.TWinControl.Handle"/>
<element name="TWinControl.SetHandle.NewHandle"/>
<element name="TWinControl.SetBorderWidth" link="#lcl.controls.TWinControl.BorderWidth"/>
<element name="TWinControl.SetBorderWidth.Value"/>
<element name="TWinControl.SetParentDoubleBuffered"/>
<element name="TWinControl.SetParentDoubleBuffered.Value"/>
<element name="TWinControl.SetParentWindow" link="#lcl.controls.TWinControl.ParentWindow"/>
<element name="TWinControl.SetParentWindow.AValue"/>
<element name="TWinControl.SetTabOrder" link="#lcl.controls.TWinControl.TabOrder"/>
<element name="TWinControl.SetTabOrder.NewTabOrder"/>
<element name="TWinControl.SetTabStop"/>
<element name="TWinControl.SetTabStop.NewTabStop"/>
<element name="TWinControl.SetUseDockManager"/>
<element name="TWinControl.SetUseDockManager.AValue"/>

<element name="TWinControl.UpdateTabOrder">
<short>
Places a control at the specified position in the tab order for Controls.
</short>
<descr>
<p>
UpdateTabOrder is a procedure used to place the current control at the 
position in NewTabOrder in its Parent control. Causes the TabOrder for child 
controls in Parent to be re-sequenced as needed.
</p>
<p>
No actions are performed in the method when Parent is unassigned (contains 
<b>Nil</b>).
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.UpdateTabOrder.NewTabOrder">
<short>New tab order for the current control.</short>
</element>

<element name="TWinControl.Insert">
<short>
Inserts or appends the specified control to the list of child controls.
</short>
<descr>
<p>
Insert is an overloaded procedure used to insert or append the control 
specified in AControl to the list of child controls in the class instance. An 
overloaded variant has an Index argument which specifies the position in the 
list.
</p>
<p>
No actions are performed in the method when AControl has not been assigned 
(contains <b>Nil</b>).
</p>
<p>
Insert raises an exception if AControl already has an assigned Parent, or 
when AControl is the same as the current class instance.
</p>
<p>
The ListInsert routine is called to store AControl in the Controls property 
at the position contained in Index. If AControl is a TWinControl instance, it 
is added to the internal list which maintains the tab order for child 
controls. At design-time, the TabStop property in AControl is automatically 
set to <b>True</b> when its CanTab property is enabled.
</p>
<p>
Insert sets the Parent property in AControl to the current control instance.
</p>
<p>
Inserts checks to see whether auto-sizing has been disabled in the AControl 
argument. When disabled in the child control, it is also disabled in the 
current class instance.
</p>
<p>
Insert is used in the implementation for the InsertControl method.
</p>
</descr>
<errors>
<p>
Raises an EInvalidOperation exception when the inserted control already has a 
Parent.
</p>
<p>
Raises an EInvalidOperation exception when the inserted control is the same 
as the current class instance. Uses the exception message in 
rsAControlCanNotHaveItselfAsParent.
</p>
</errors>
<seealso>
<link id="TControl.Parent"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.InsertControl"/>
<link id="TControl.DisableAutoSizing"/>
<link id="ListInsert"/>
</seealso>
</element>
<element name="TWinControl.Insert.AControl">
<short>Control to insert or append as a child control.</short>
</element>
<element name="TWinControl.Insert.Index">
<short>
Position where the new control is stored in the Controls property.
</short>
</element>

<element name="TWinControl.Remove">
<short>
Removes the specified control from the list of child Controls for the class 
instance.
</short>
<descr>
<p>
Remove is a procedure used to remove the control in AControl from the list of 
child Controls for the class instance. No actions are performed in the method 
when AControl has not been assigned (contains <b>Nil</b>).
</p>
<p>
Remove ensures that the value in AControl is removed from the Controls 
property, and the internal list used to determine alignment order of the 
child controls. When AControl is a TWinControl instance, it is removed from 
the internal tab order list for child controls.
</p>
<p>
Remove sets the Parent property in AControl to <b>Nil</b>.
</p>
<p>
Remove checks to see whether auto-sizing has been disabled in the AControl 
argument. When disabled in the child control, it is re-enabled for the 
current class instance.
</p>
<p>
Remove is used in the implementation of the RemoveControl method.
</p>
</descr>
<seealso>
<link id="TWinControl.Controls"/>
<link id="TControl.Parent"/>
<link id="TWinControl.RemoveControl"/>
<link id="TControl.EnableAutoSizing"/>
</seealso>
</element>
<element name="TWinControl.Remove.AControl">
<short>
Control removed from the list of child Controls in the class instance.
</short>
</element>

<element name="TWinControl.AlignNonAlignedControls"/>
<element name="TWinControl.AlignNonAlignedControls.ListOfControls"/>
<element name="TWinControl.AlignNonAlignedControls.BoundsModified"/>

<element name="TWinControl.CreateControlAlignList">
<short>
Fills the list with the child controls which must be realigned.
</short>
<descr>
<p>
The list is initialized with all child controls which have the given 
alignment and are visible.
</p>
</descr>
<seealso>
<link id="TWinControl.AlignControls"/>
</seealso>
</element>
<element name="TWinControl.CreateControlAlignList.TheAlign">
<short>List all controls with this alignment.</short>
</element>
<element name="TWinControl.CreateControlAlignList.AlignList">
<short>
TFPList instance populated in the method.
</short>
</element>
<element name="TWinControl.CreateControlAlignList.StartControl">
<short>
TControl instance that is added as the first control in the align list.
</short>
</element>

<element name="TWinControl.UpdateAlignIndex"/>
<element name="TWinControl.UpdateAlignIndex.aChild"/>

<element name="TWinControl.FDoubleBuffered">
<short>
Member used to store the value for the DoubleBuffered property.
</short>
</element>

<element name="TWinControl.FWinControlFlags">
<short>Contains various window control state flags.</short>
</element>

<element name="TWinControl.WSRegisterClass">
<short>Registers the class instance for use in the widgetset.</short>
<descr>
<p>
No actions are performed in the method when the class type has already been 
registered in the widgetset.
</p>
<p>
Calls the inherited method on entry to ensure that the TControl class type 
has been registered in the widgetset. Calls the widgetset routine used to 
register the TWinControl class type.
</p>
<p>
Registers properties in TWinControl which are ignored during LCL component 
streaming. These are Delphi / VCL compatibility properties like 
ParentDoubleBuffered, ImeMode, and ImeName. They are not used in the LCL.
</p>
</descr>
<seealso>
<link id="TControl.WSRegisterClass"/>
<link id="#lcl.lclclasses.TLCLComponent.WSRegisterClass">TLCLComponent.WSRegisterClass</link>
</seealso>
</element>

<element name="TWinControl.AdjustClientRect">
<short>
Override this method when the ClientRect for a control differs from the 
default value.
</short>
<descr>
<p>
In TWinControl, the virtual method has an empty implementation. It can be 
overridden in descendent classes to perform actions needed for the class 
type. Such as:
</p>
<ul>
<li>
Shrink or grow the client rectangle to account for added or removed borders 
or bezels.
</li>
<li>
Reserve space for companion controls or user interface elements.
</li>
<li>
Set state or configuration flags which affect the client rectangle for the 
class.
</li>
</ul>
<p>
AdjustClientRect can be called often, especially during auto-sizing and 
anchoring operations. Do not use expensive code here, or cache the resulting 
client rectangle for subsequent access.
</p>
</descr>
<version>
Behavior modified in LCL version 3.4 to use the adjusted client rectangle when 
controls are aligned.
</version>
<seealso>
<link id="TWinControl.GetAdjustedLogicalClientRect"/>
</seealso>
</element>
<element name="TWinControl.AdjustClientRect.ARect">
<short>The client rectangle examined and updated in the method.</short>
</element>

<element name="TWinControl.GetAdjustedLogicalClientRect">
<short>
Returns the adjusted logical ClientRect, using the cached value when 
available.
</short>
<descr>
<p>
<var>GetAdjustedLogicalClientRect</var> is a method used to get the client 
rectangle for the control, and adjust the values for any additional space 
needed for the control. It calls the AdjustClientRectangle method to apply any 
additional spacing required for borders, bevels, edges, indentation, etc. In 
TWinControl, no additional space is required. Descendent classes may have 
different requirements.
</p>
<p>
GetAdjustedLogicalClientRect is used to implement the CheckSidePosition method 
in TAnchorSide.
</p>
</descr>
<seealso>
<link id="TControl.ClientRect"/>
<link id="TWinControl.AdjustClientRect"/>
<link id="TAnchorSide.CheckSidePosition"/>
<link id="TWinControlFlag"/>
</seealso>
</element>
<element name="TWinControl.GetAdjustedLogicalClientRect.ARect">
<short>
Output variable with the client bounds adjusted for borders, bevels, edges, or 
indentation used on the control.
</short>
</element>

<element name="TWinControl.AlignControls">
<short>Repositions and resizes the control and child controls.</short>
<descr>
<p>
<var>AlignControls</var> is a method used to reposition and resize the 
specified control and the children in its Controls property. This includes 
using the DockManager (when assigned and enabled) to reserve space for docked 
controls in the client rectangle. It uses settings in the Align, Anchor, 
BorderSpacing, ChildSizing, and Constraints properties to determine the 
actions needed in the method for each of the controls.
</p>
<p>
AlignControls checks and updates the windowed control flags prior to starting 
the operation. No actions are performed in the method when 
wcfAligningControls is already included in the control flags.
</p>
<p>
The ControlsAligned method is called when the method is completed, and the 
control flags are updated to remove the value wcfAligningControls.
</p>
<p>
AlignControls is called from the private AlignControl method after the client 
rectangle has been adjusted and the logical display area for the control has 
been determined. AlignControl is the boss; AlignControls performs the heavy 
lifting.
</p>
</descr>
<version>
Behavior modified in LCL version 3.4 to use the adjusted client rectangle when 
controls are aligned.
</version>
<seealso>
<link id="TWinControl.Controls"/>
<link id="TWinControl.AdjustClientRect"/>
<link id="TWinControl.ChildSizing"/>
<link id="TWinControl.DoAdjustClientRectChange"/>
<link id="TControl.DoAllAutoSize"/>
<link id="TWinControlFlag"/>
</seealso>
</element>
<element name="TWinControl.AlignControls.AControl">
<short>Control examined and updated in the method.</short>
</element>
<element name="TWinControl.AlignControls.RemainingClientRect">
<short>The available space, becomes remaining space on exit.</short>
</element>

<element name="TWinControl.CustomAlignInsertBefore">
<short>
Indicates whether the specified controls were custom-aligned using the 
OnAlignInsertBefore handler.
</short>
<descr>
<p>
<var>CustomAlignInsertBefore</var> is a <var>Boolean</var> function which 
indicates whether the specified controls need to be custom-aligned using the 
OnAlignInsertBefore handler. CustomAlignInsertBefore is called (circuitously) 
when auto-sizing is performed in the DoAutoSize method, and the Align property 
in the control is alCustom.
</p>
<p>
<var>AControl1</var> and <var>AControl2</var> are child controls examined to 
determine the alignment order in the parent control.
</p>
<p>
The return value is <b>False</b> if OnAlignInsertBefore has not been assigned 
in the control, or when the controls do not require custom alignment. 
<b>True</b> indicates that the controls are swapped in the alignment order.
</p>
</descr>
<seealso>
<link id="TWinControl.OnAlignInsertBefore"/>
<link id="TWinControl.DoAutoSize"/>
<link id="TAlignInsertBeforeEvent"/>
</seealso>
</element>
<element name="TWinControl.CustomAlignInsertBefore.Result">
<short><b>True</b> if Control2 should be placed before Control1.</short>
</element>
<element name="TWinControl.CustomAlignInsertBefore.AControl1">
<short>
Child control examined in the event handler for its aligment order.
</short>
</element>
<element name="TWinControl.CustomAlignInsertBefore.AControl2">
<short>
Child control examined in the event handler for its aligment order.
</short>
</element>

<element name="TWinControl.CustomAlignPosition">
<short>
Returns the aligned position for a custom-aligned child control, using the 
<var>OnAlignPosition</var> event handler.
</short>
<descr>
<p>
The derived coordinates take into account the anchoring for 
<var>AControl</var>.
</p>
<p>
The <var>OnAlignPosition</var> handler can update the coordinates as required.
</p>
</descr>
<seealso>
<link id="TAlignInsertBeforeEvent"/>
</seealso>
</element>
<element name="TWinControl.CustomAlignPosition.AControl">
<short>The control to be repositioned / resized.</short>
</element>
<element name="TWinControl.CustomAlignPosition.ANewLeft">
<short/>
</element>
<element name="TWinControl.CustomAlignPosition.ANewTop">
<short/>
</element>
<element name="TWinControl.CustomAlignPosition.ANewWidth">
<short/>
</element>
<element name="TWinControl.CustomAlignPosition.ANewHeight">
<short/>
</element>
<element name="TWinControl.CustomAlignPosition.AlignRect">
<short>
The remaining client area, within which the control can be placed.
</short>
</element>
<element name="TWinControl.CustomAlignPosition.AlignInfo">
<short>Information about the current align process.</short>
</element>

<element name="TWinControl.DoAlignChildControls">
<short>
Override this method to position / align all child controls for the specified 
control.
</short>
<descr>
<p>
<var>DoAlignChildControls</var> always returns <b>False</b> in TWinControl. It 
can be overridden in descendent classes to perform any actions needed, and to 
set the return value to <b>True</b> to avoid the default handling performed in 
AlignControls.
</p>
</descr>
<seealso>
<link id="TWinControl.AlignControls"/>
</seealso>
</element>
<element name="TWinControl.DoAlignChildControls.Result">
<short><b>True</b> when all controls have been placed.</short>
</element>
<element name="TWinControl.DoAlignChildControls.TheAlign">
<short>The alignment of all given controls.</short>
</element>
<element name="TWinControl.DoAlignChildControls.AControl">
<short>
Control with child controls and client rectangle used in the method.
</short>
</element>
<element name="TWinControl.DoAlignChildControls.AControlList">
<short>The controls to be placed.</short>
</element>
<element name="TWinControl.DoAlignChildControls.ARect">
<short>The unused client rectangle available for the child controls.</short>
</element>

<element name="TWinControl.DoChildSizingChange">
<short>
Called after a change in ChildSizing information to trigger further 
processing.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.DoChildSizingChange.Sender">
<short/>
</element>

<element name="TWinControl.InvalidatePreferredChildSizes">
<short>
Flags the preferred sizes of all child controls as invalid (recursively).
</short>
<seealso>
<link id="TWinControlFlag"/>
<link id="TControlFlag"/>
</seealso>
</element>

<element name="TWinControl.CanTab">
<short>
Indicates whether the Tab key can be used for keyboard navigation in the 
control.
</short>
<descr>
<p>
CanTab is an overridden method in TWinControl. The return value is 
<b>True</b> if the control is eligible to receive input focus. It must have a 
parent form and be both visible and enabled.
</p>
<p>
Set TabStop to indicate the control is omitted in the tab order for the 
parent form.
</p>
</descr>
<seealso>
<link id="TWinControl.CanFocus"/>
<link id="TWinControl.SelectNext"/>
<link id="TWinControl.Focused"/>
<link id="TControl.CanTab"/>
</seealso>
</element>
<element name="TWinControl.CanTab.Result">
<short>
<b>True</b> if the control is eligible to receive input focus.
</short>
</element>

<element name="TWinControl.IsClientHeightStored">
<short>Implements the storage specifier for the ClientHeight property.</short>
<descr>
<p>
Re-implements the method inherited from TControl.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.ClientHeight">TControl.ClientHeight</link>
</seealso>
</element>
<element name="TWinControl.IsClientHeightStored.Result">
<short><b>True</b> if ControlCount has a non-zero value.</short>
</element>

<element name="TWinControl.IsClientWidthStored">
<short>Implements the storage specifier for the ClientWidth property.</short>
<descr>
<p>
Re-implements the method inherited from TControl.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.ClientWidth">TControl.ClientWidth</link>
</seealso>
</element>
<element name="TWinControl.IsClientWidthStored.Result">
<short><b>True</b> if ControlCount has a non-zero value.</short>
</element>

<element name="TWinControl.DoSendShowHideToInterface">
<short>Sends the new Visible state to the widgetset class instance.</short>
<descr>
<p>
Called from the CMShowingChanged method.
</p>
</descr>
<seealso>
<link id="TWinControl.CMShowingChanged"/>
</seealso>
</element>

<element name="TWinControl.ControlsAligned">
<short>
Called from AlignControls when alignment for the control is completed.
</short>
<descr>
<p>
ControlsAligned has an empty implementation in the current LCL version.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.DoSendBoundsToInterface">
<short>
Sends the new bounds for the control to the widgetset class instance.
</short>
<descr>
Called from RealizeBounds.
</descr>
<seealso>
<link id="TWinControlFlag"/>
</seealso>
</element>

<element name="TWinControl.RealizeBounds">
<short>
Checks for changes in BoundsRect, and sends the new bounds to the widget.
</short>
<descr>
<p>
Calls DoSendBoundsToInterface to update the widget.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.RealizeBoundsRecursive">
<short>
Sends changed BoundsRects to the widget, for both the control and all child 
controls.
</short>
<descr/>
<seealso>
<link id="TWinControl.RealizeBounds"/>
<link id="TWinControlFlag"/>
</seealso>
</element>

<element name="TWinControl.InvalidateBoundsRealized">
<short>Resets the realized bounds rectangle for the control.</short>
<descr>
<p>
Creates a new, empty TRect instance for the internal member passed to the 
widgetset class. Used in widgetset methods which apply changes to the Font 
for the control.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.CreateSubClass">
<short>An empty implementation in the current LCL version.</short>
<descr>
<p>
An empty implementation in the current LCL version.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.CreateSubClass.Params">
<short>Creation parameters for the subclass.</short>
</element>
<element name="TWinControl.CreateSubClass.ControlClassName">
<short>Class name for the control added as a subclass.</short>
</element>

<element name="TWinControl.DoConstraintsChange">
<short>
Notifies the widgetset class instance when Constraints are changed.
</short>
<descr>
<p>
DoConstraintsChange is an overridden method in TWinControl, and calls the 
inherited method on entry to size and position child controls to Constraints. 
Calls the ConstraintsChange method in the widgetset class instance when its 
Handle has been allocated.
</p>
<p>
DoConstraintsChange is called from the TSizeConstraints.Change method before 
it signals the OnChange event handler in the constraints class instance.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.DoConstraintsChange">TControl.DoConstraintsChange</link>
</seealso>
</element>
<element name="TWinControl.DoConstraintsChange.Sender">
<short>Object (TWinControl) instance for the change notification.</short>
</element>

<element name="TWinControl.DoSetBounds">
<short>
Updates the size and extent of the control as well as its ClientRect.
</short>
<descr>
<p>
<var>DoSetBounds</var> is an overridden method in <var>TWinControl</var>. It 
keeps a copy of the current Width and Height prior to calling the inherited 
method to apply the argument values to the Left, Top, Width and Height 
properties.
</p>
<p>
It performs actions to adjust the CachedClientWidth and CachedClientHeight if the control flags do not indicate they are being loading or have already been 
loaded for the control. Changing the ClientRect here, to the most probable size, reduces unnecessary resize messages.
</p>
<p>
Normally, the ClientWidth / ClientHeight are adjusted automatically by the 
widget. But it is up to the widget when this will be done. GTK, for example, 
just puts resize requests in a queue. The LCL would resize the child 
components immediately after the GTK procedure to adjust the ClientRect. On 
complex forms with lots of nested controls, this would result in thousands of 
resize messages.
</p>
</descr>
<seealso>
<link id="TControl.DoSetBounds"/>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.Width"/>
<link id="TControl.Height"/>
</seealso>
</element>
<element name="TWinControl.DoSetBounds.ALeft">
<short>
New value for the Left property in the control.
</short>
</element>
<element name="TWinControl.DoSetBounds.ATop">
<short>
New value for the Top property in the control.
</short>
</element>
<element name="TWinControl.DoSetBounds.AWidth">
<short>
New value for the Width property in the control.
</short>
</element>
<element name="TWinControl.DoSetBounds.AHeight">
<short>
New value for the Height property in the control.
</short>
</element>

<element name="TWinControl.DoAutoSize">
<short>
Shrinks or enlarges the control to accommodate its children.
</short>
<descr>
<p>
Because this method is frequently overridden, the LCL calls the 
<link id="TControl.AdjustSize"/> method instead; it checks whether DoAutoSize 
really should be called right now.
</p>
<p>
DoAutoSize performs the following:
</p>
<ul>
<li>Checks whether Autosize is permitted</li>
<li>Checks for unaligned child components and aligns them as best it can</li>
<li>
Moves the constrained (aligned) child components to the correct position
</li>
<li>Adjusts the size of the client rectangle</li>
<li>Adjusts the bounds of the whole control</li>
</ul>
</descr>
<seealso>
<link id="TControl.DoAutoSize"/>
</seealso>
</element>

<element name="TWinControl.DoAllAutoSize">
<short>
Performs actions to resize and align the control and all of its children.
</short>
<descr>
<p>
<var>DoAllAutoSize</var> is an overridden method in <var>TWinControl</var>.
</p>
<p>
No actions are performed in the method when wcfAllAutoSizing has already been 
included in the window control flags; in other words, the method has already 
been called. No actions are performed when AutoSizeDelayed returns 
<b>True</b>.
</p>
<p>
DoAllAutoSize checks to ensure that a Handle has been allocated for the 
control, and that it and its Parent are Visible. If AutoSizing is not 
possible, the flag is removed from the control and its children and the 
method is exited.
</p>
<p>
DoAllAutoSize calls the inherited method to change the bounds, invalidate the 
preferred size, and update flags for the control. RealizeBoundsRecursive is 
called to update the bounds for the all child controls. The child controls 
are made visible first, and then the current control instance.
</p>
<p>
DoAllAutoSize is called from the AdjustSize and EnableAutoSizing methods.
</p>
</descr>
<errors>
<p>
The inherited method raises an EInvalidOperation exception if Parent has not 
been assigned for the control.
</p>
<p>
Raises a catchable exception when cfAutoSizeNeeded is already included in the 
control flags when the method is called.
</p>
</errors>
<seealso>
<link id="TControl.DoAllAutoSize"/>
<link id="TControl.Parent"/>
<link id="TControl.AutoSizingAll"/>
</seealso>
</element>

<element name="TWinControl.AllAutoSized">
<short>
Called from DoAllAutoSize after all bounds have been computed for the control.
</short>
<descr/>
<seealso>
<link id="#lcl.forms.TCustomForm.AllAutoSized">TCustomForm.AllAutoSized</link>
</seealso>
</element>

<element name="TWinControl.CalculatePreferredSize">
<short>
Override this method to return a different preferred height and/or width for 
auto-sizing.
</short>
<descr>
<p>
Calls the inherited method to calculate the default / preferred width and 
height for a <var>TWinControl</var> instance. It is used by the LCL 
auto-sizing algorithms as the default size. Only positive values are valid. 
Negative or 0 (Zero) values are treated as undefined, and the LCL uses other 
values to perform auto-sizing.
</p>
<p>
<var>TWinControl</var> overrides this:
</p>
<ul>
<li>If there are child components, their total preferred size is 
calculated</li>
<li>If this value cannot be computed (e.g. the children depend too much on 
their
parent clientrect), then the interface is asked for the preferred size</li>
</ul>
<p>
For example the preferred size of a <var>TButton</var> is the size, where the 
label fits exactly. This relies on the current theme and widgetset.
</p>
<p>
This value is independent of constraints and siblings, only the inner parts 
are relevant for the calculates values.
</p>
<p>
<var>WithThemeSpace</var> adds space for stacking when set to <b>True</b>. 
For example: <var>TRadioButton</var> has a minimum size. But for stacking 
multiple TRadioButtons there should be space around each control. This space 
is theme-dependent, so it is passed as a parameter to the widgetset.
</p>
</descr>
<seealso>
<link id="TControl.CalculatePreferredSize"/>
</seealso>
</element>
<element name="TWinControl.CalculatePreferredSize.PreferredWidth">
<short>
Width used for new instances of the control.
</short>
</element>
<element name="TWinControl.CalculatePreferredSize.PreferredHeight">
<short>
Height used for new instances of the control.
</short></element>
<element name="TWinControl.CalculatePreferredSize.WithThemeSpace">
<short>Indicates if additional space is reserved for theme services.</short>
</element>

<element name="TWinControl.GetPreferredSizeClientFrame">
<short>
Calculates the width and height for the frame area around the control.
</short>
<descr>
<p>
Calculated as follows:
</p>
<ul>
<li>
AWidth is the difference between Width and ClientWidth.
</li>
<li>
AHeight is the difference between Height and ClientHeight.
</li>
</ul>
</descr>
<seealso/>
</element>
<element name="TWinControl.GetPreferredSizeClientFrame.AWidth">
<short>Width used for the frame around the control.</short>
</element>
<element name="TWinControl.GetPreferredSizeClientFrame.AHeight">
<short>Height used for the frame around the control.</short>
</element>

<element name="TWinControl.GetChildren">
<short>
Calls the specified procedure for each child control with Root as the Owner.
</short>
<descr>
<p>
Iterates the values in Controls to locate any controls where Root is the 
Owner of the control instance. Calls the procedure in Proc using the control 
instance as an argument. An application must implement an object procedure 
using the signature in TGetChildProc, and pass the procedure in the Proc 
argument.
</p>
</descr>
<seealso>
</seealso>
</element>
<element name="TWinControl.GetChildren.Proc">
<short>The callback procedure.</short>
</element>
<element name="TWinControl.GetChildren.Root">
<short>Owner of the controls passed to the procedure.</short>
</element>

<element name="TWinControl.ChildClassAllowed">
<short>
Checks whether the specified class type is allowed as a child control.
</short>
<descr>
<p>
<var>ChildClassAllowed</var> is an overridden method in TWinControl used to 
determine if instances of the class type in ClassType are allowed as child 
controls. Returns <b>True</b> if the specified class type is allowed as a 
child control in the Controls property.
</p>
<p>
In TWinControl, the return value is <b>True</b> when ChildClass has been 
assigned (not <b>Nil</b>) and the class type is derived from TControl.
</p>
<p>
ChildClassAllowed does not call the inherited method which always returns 
<b>False</b>.
</p>
<p>
ChildClassAllowed is called from the CheckChildClassAllowed method in 
TControl.
</p>
</descr>
<seealso>
<link id="TWinControl.Controls"/>
<link id="TControl.CheckChildClassAllowed"/>
<link id="TControl.Parent"/>
</seealso>
</element>
<element name="TWinControl.ChildClassAllowed.Result">
<short><b>True</b> when ChildClass is allowed in Controls.</short>
</element>
<element name="TWinControl.ChildClassAllowed.ChildClass">
<short>Class type examined in the method.</short>
</element>

<element name="TWinControl.PaintControls">
<short>
Paints all child controls which do not have a Handle.
</short>
<descr>
<p>
Controls which do <b>not</b> descend from <var>TWinControl</var> have no 
handle of their own; they are repainted when the parent control is redrawn.
</p>
<p>
No actions are performed in PaintControls for the following conditions:
</p>
<ul>
<li>The device context in DC is unassigned (0).</li>
<li>The device context in DC is a handle for a design-time window.</li>
<li>The Handle has not been allocated for the control.</li>
<li>
The internal TFPList has not been created to store child controls in the 
Controls property.
</li>
</ul>
<p>
PaintControls tries to locate and paint controls (starting with the control 
in First) not derived from TWinControl. When First is omitted (<b>Nil</b>) or 
not found in the internal list, all child controls in the list are examined. 
The control must be Visible and within the visible client area on the Parent 
to be painted.
</p>
<p>
Each eligible control is positioned on the device context using the Left and 
Top properties for the control. Its clipping rectangle is copied to the 
device context, and an LM_PAINT message is performed on the DC to redraw the 
parent control.
</p>
<p>
The ControlState property is updated prior to and following the paint 
operation for each child control to include or exclude the csPaintCopy control 
state value.
</p>
<p>
PaintControls is called from the PaintHandler method, and occurs when the 
WMPaint method handles an LM_PAINT message for a control.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.PaintControls.DC">
<short>The device context usable for painting child controls.</short>
</element>
<element name="TWinControl.PaintControls.First">
<short>First of the controls in Controls[], which remain to paint.</short>
</element>

<element name="TWinControl.PaintHandler">
<short>Handler for TLMPaint, manages the painting of child controls.</short>
<descr>
<p>
<var>PaintHandler</var> is a method used to apply the LM_PAINT window message 
in TheMessage to the client rectangle for the control. The device context in 
TheMessage is used as the target for the paint operation. If the device 
context is unassigned on entry, the BeginPaint routine in the LCL interface 
is called to get a device context for the Handle in the control.
</p>
<p>
PaintHandler checks the list of child controls if any of the items are 
visible, opaque TControl class instances which need to be drawn using the 
Handle for the control. When found, a clipping rectangle for the child 
control is calculated on the device context.
</p>
<p>
PaintHandler calls the PaintSite method in the DockManager (when assigned and 
enabled) to paint the DockSite to the device context. The PaintControls 
method is called to force the all child controls to be painted to the device 
context.
</p>
<p>
PaintHandler calls the EndPaint routine in the LCL interface to free the 
device context prior to exiting from the method.
</p>
<p>
PaintHandler is called when the WMPaint method receives an LM_PAINT message 
for the control.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.PaintHandler.TheMessage">
<short>LM_PAINT window message handled in the method.</short>
</element>

<element name="TWinControl.PaintWindow">
<short>
Paints a clipping region for the control on the specified device context.
</short>
<descr>
<p>
<var>PaintWindow</var> is a method used to paint a clipping region for the 
control (or a child control) to the device context in DC.
</p>
<p>
PaintWindow creates a TLMessage instance using the LM_PAINT window message 
and the specified device context. The DefaultHandler method is called to pass 
the message to the widgetset class instance (and ultimately its message 
processing loop).
</p>
<p>
No actions are performed in the method when DC is unassigned (<b>0</b>), the 
Handle for the control has not been allocated, or the control is being freed.
</p>
<p>
PaintWindow is called from the PaintHandler method.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.PaintWindow.DC">
<short>Device context with the requested clipping region.</short>
</element>

<element name="TWinControl.CreateBrush">
<short>
Creates the <link id="TWinControl.Brush">Brush</link>, if not already created.
</short>
<descr>
<p>
Creates and assigns a <var>TBrush</var> instance used in the <var>Brush</var> 
property. The brush Color is updated using the resolved value in the Color 
property. clDefault in Color causes the default brush color value from the 
widgetset to be used.
</p>
<p>
CreateBrush is called when the value for the Brush property is read, and the 
member has not yet been assigned.
</p>
</descr>
<seealso>
<link id="TWinControl.Brush"/>
<link id="TControl.Color"/>
<link id="TControl.GetDefaultColor"/>
<link id="#lcl.graphics.TBrush">TBrush</link>
</seealso>
</element>

<element name="TWinControl.ScaleControls">
<short>Scales values for all child controls.</short>
<descr>
<p>
<var>ScaleControls</var> is a method used to scale the child controls in the 
Controls property using the specified multiplier and divisor. ScaleControls 
visits each of the class instances in Controls and calls its ChangeScale 
method using Multiplier and Divider as arguments.
</p>
<p>
ScaleControls is called from the overridden ChangeScale method. This causes 
all controls in the hierarchy to apply the scaling factor to values in their 
Constraints, Font, Left, Top, Right and Bottom properties. For top-level 
Forms, the values in Left and Top are <b>not</b> scaled.
</p>
</descr>
<seealso>
<link id="TWinControl.ChangeScale"/>
<link id="TControl.ChangeScale"/>
<link id="TControl.UpdateAnchorRules"/>
</seealso>
</element>
<element name="TWinControl.ScaleControls.Multiplier">
<short>Multiplier applied to a value to achieve a scaling factor.</short>
</element>
<element name="TWinControl.ScaleControls.Divider">
<short>Divisor applied to a value to achieve a scaling factor.</short>
</element>

<element name="TWinControl.ChangeScale">
<short>
Scales (resizes) the control and all of its child controls.
</short>
<descr>
<p>
<var>ChangeScale</var> is an overridden method in TWinControl used to ensure 
that child controls are scaled using the values in the Multiplier and Divider 
arguments.
</p>
<p>
ChangeScale extends the inherited method by calling DisableAlign before 
applying the scaling factor. It calls the ScaleControls method to apply 
Multiplier and Divider to the child controls. It calls the inherited method 
to apply scaling to the Bounds, Constraints, and Font in the control.
</p>
<p>
ChangeScale visits each of the control instances in Controls, and calls their 
UpdateAnchorRules method to update the BaseBounds in the control as needed.
</p>
<p>
EnableAlign is called prior to exiting from the method.
</p>
</descr>
<seealso>
<link id="TControl.ChangeScale"/>
</seealso>
</element>
<element name="TWinControl.ChangeScale.Multiplier">
<short>Multiplier applied to a value to achieve a scaling factor.</short>
</element>
<element name="TWinControl.ChangeScale.Divider">
<short>Divisor applied to a value to achieve a scaling factor.</short>
</element>

<element name="TWinControl.CMBiDiModeChanged">
<short>
Handles a CM_BIDIMODECHANGED control message for the control.
</short>
<descr>
<p>
<var>CMBiDiModeChanged</var> is an overridden method in TWinControl used to 
handle a CM_BIDIMODECHANGED control message received for the control. It 
calls the inherited method on entry to invalidate the control when needed. It 
extends the inherited method to notify child controls of the change using a 
CM_PARENTBIDIMODECHANGED message.
</p>
<p>
If a handle has been allocated in the widgetset class instance, its 
SetBiDiMode method is called to reflect the values from 
UseRightToLeftAlignment, UseRightToLeftReading, and UseRightToLeftScrollBar.
</p>
<p>
AdjustSize is called to update the sizes for parent and child controls after 
the property value has been changed.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.CMBiDiModeChanged.Message">
<short>Control message examined and handled in the method.</short>
</element>

<element name="TWinControl.CMBorderChanged">
<short>
Handles a CM_BORDERCHANGED message received for the control.
</short>
<descr>
<p>
<var>CMBorderChanged</var> ensures that the size and client rectangle are 
adjusted when a border is added to or removed from the control. It calls 
DoAdjustClientRectChange and AdjustSize to update values in the control. It 
calls Invalidate to force the control to be redrawn with the new size and 
client rectangle.
</p>
</descr>
</element>
<element name="TWinControl.CMBorderChanged.Message">
<short>Control message examined and applied in the method.</short>
</element>

<element name="TWinControl.CMDoubleBufferedChanged">
<short>Handler for changes to the DoubleBuffered property.</short>
<descr>
<p>
<var>CMDoubleBufferedChanged</var> is the handler used to process 
<b>CM_PARENTDOUBLEBUFFEREDCHANGED</b> messages when the value in 
<var>DoubleBuffered</var> has been been changed.
</p>
<p>
CMDoubleBufferedChanged calls <var>NotifyControls</var> to apply the message 
in the widgetset class; the value in the Message argument is ignored.
</p>
<p>
CMDoubleBufferedChanged calls <var>Invalidate</var> to cause the control to 
be redrawn.
</p>
</descr>
<seealso>
<link id="TWinControl.DoubleBuffered"/>
<link id="TWinControl.NotifyControls"/>
<link id="TWinControl.Invalidate"/>
</seealso>
</element>
<element name="TWinControl.CMDoubleBufferedChanged.Message">
<short>Message examined in the method.</short>
</element>

<element name="TWinControl.CMEnabledChanged">
<short>
Handler signalled when the Enabled property has been changed.
</short>
<descr>
<p>
If the control is not Enabled and has a Parent control, the RemoveFocus 
method is called to defocus the control on its Parent form. If the window 
Handle has been allocated for the control, the EnableWindow routine in the 
LCL interface is called to set the enabled state for the handle.
</p>
<p>
CMEnabledChanged calls the inherited method prior to exit to Invalidate the 
control.
</p>
</descr>
<seealso>
<link id="TWinControl.RemoveFocus"/>
<link id="TControl.Enabled"/>
<link id="TControl.CMEnabledChanged"/>
<link id="TControl.Invalidate"/>
</seealso>
</element>
<element name="TWinControl.CMEnabledChanged.Message">
<short>
CM_ENABLEDCHANGED control message which triggered the handler.
</short>
</element>

<element name="TWinControl.CMParentDoubleBufferedChanged">
<short>
Handles the CM_PARENTDOUBLEBUFFEREDCHANGED control message for the control 
(when enabled).
</short>
<descr>
<p>
Sets the value in ParentDoubleBuffered to <b>True</b>. When Parent is 
assigned, the value in DoubleBufferred is set to the corresponding value from 
the Parent control.
</p>
<p>
No actions are performed in the method if ParentDoubleBuffered is already set 
to <b>False</b>.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.CMParentDoubleBufferedChanged.Message">
<short>Message handled in the method.</short>
</element>

<element name="TWinControl.CMShowingChanged">
<short>
Handler for changed <link id="TWinControl.Showing">Showing</link> message; 
notifies the widgetset.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CMShowingChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TWinControl.CMShowHintChanged">
<short>
Handler for changed <link id="TControl.ShowHint">ShowHint</link> message; 
notifies all child controls.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CMShowHintChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TWinControl.CMVisibleChanged">
<short>
Handles Focus changes, and forces UpdateControlState.
</short>
<descr>
Handler for changed <link id="TControl.Visible">Visible</link> message.
</descr>
<seealso/>
</element>
<element name="TWinControl.CMVisibleChanged.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TWinControl.CMEnter">
<short>Handles the CM_ENTER control message for the control.</short>
<descr>
<p>
CM_ENTER and CM_EXIT messages occur when the active control is changed on a 
form.
</p>
<p>
Calls DoEnter to signal the OnEnter event handler (when assigned).
</p>
</descr>
<seealso>
<link id="TWinControl.DoEnter"/>
<link id="TWinControl.OnEnter"/>
</seealso>
</element>
<element name="TWinControl.CMEnter.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TWinControl.CMExit">
<short>Handles the CM_EXIT control message for the control.</short>
<descr>
<p>
CM_ENTER and CM_EXIT messages occur when the active control is changed on a 
form.
</p>
<p>
Calls DoExit to signal the OnExit event handler (when assigned).
</p>
</descr>
<seealso>
<link id="TWinControl.DoExit"/>
<link id="TWinControl.OnExit"/>
</seealso>
</element>
<element name="TWinControl.CMExit.Message">
<short>
Control message handled in the method.
</short>
</element>

<element name="TWinControl.WMContextMenu">
<short>
Handler for an <link id="TControl.PopupMenu">ContextMenu</link> event; 
eventually delegates handling to the affected child control.
</short>
<descr>
</descr>
<seealso/>
</element>
<element name="TWinControl.WMContextMenu.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMEraseBkgnd">
<short>
Erases the background, when required.
</short>
<descr/>
<seealso>
<link id="TWinControlFlag"/>
</seealso>
</element>
<element name="TWinControl.WMEraseBkgnd.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMNotify">
<short>Handles (dispatches) notification messages.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMNotify.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMSetFocus">
<short>Handler for receiving Focus event.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMSetFocus.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMKillFocus">
<short>Handles the LM_KILLFOCUS message for the control.</short>
<descr>
<p>
<var>WMKillFocus</var> is a method used to handle the LM_KILLFOCUS control 
message received when a control loses focus. WMKillFocus ensures that the 
<var>EditingDone</var> method is called for the control when the parent form 
has been assigned and is Active.
</p>
<p>
No actions are performed in the method at design-time, or when the control is 
being freed.
</p>
</descr>
<seealso>
<link id="TControl.EditingDone"/>
<link id="#lcl.forms.GetParentForm">GetParentForm</link>
</seealso>
</element>
<element name="TWinControl.WMKillFocus.Message">
<short>Window message examined in the method.</short>
</element>

<element name="TWinControl.WMShowWindow">
<short>Handler for changed visibility notification.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMShowWindow.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMEnter">
<short>Handles the LM_ENTER message for the control.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMEnter.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMExit">
<short>Handles the LM_EXIT message for the control.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMExit.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMKeyDown">
<short>
Event handler for a key press not handled by the widget; Tries <link 
id="TWinControl.DoRemainingKeyDown"/>.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMKeyDown.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMSysKeyDown">
<short>
Event handler for system key presses not handled by the widget; tries <link 
id="TWinControl.DoRemainingKeyDown"/>.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMSysKeyDown.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMKeyUp">
<short>
Event handler for key released, not handled by the widget. Tries <link 
id="TWinControl.DoRemainingKeyUp"/>.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMKeyUp.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMSysKeyUp">
<short>
Event handler for system key releases not handled by the widget; tries <link 
id="TWinControl.DoRemainingKeyUp"/>
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMSysKeyUp.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMChar">
<short>
Handler for messages sent by the widget, after it has handled the key press 
itself.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMChar.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMSysChar">
<short>
Handler for messages sent by the widget, after it has handled the key press 
itself.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMSysChar.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMPaint">
<short>
Manages paint requests, and handles double buffering.
</short>
<descr/>
<notes>
<note>
This topic needs more detail.
BUFFERED_WMPAINT is defined for the Windows platform only.
Ensures that a valid device context is selected before calling the Windows API 
routines like: CreateCompatibleBitmap and BitBlt. Ensures the device context 
is freed after use.
</note>
</notes>
<seealso/>
</element>
<element name="TWinControl.WMPaint.Msg">
<short>
LM_PAINT window message examined and handled in the method.
</short>
</element>

<element name="TWinControl.WMDestroy">
<short>
Handler for widget destroyed message; clears the Handle.
</short>
<descr>
<p>
Sets Handle to the unassigned value (0) when the windowed control no longer 
exists.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.WMDestroy.Message">
<short>
LM_DESTROY window message which triggered the handler.
</short>
</element>

<element name="TWinControl.WMMove">
<short>
Handler for widget moved message; updates the Bounds.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.WMMove.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMSize">
<short>
Event handler for size messages.
</short>
<descr>
<p>
This method is called whenever <var>Width</var>, <var>Height</var>, 
<var>ClientWidth</var> or <var>ClientHeight</var> have changed. If the source 
of the message is the interface, the new size is stored in the internal 
BoundsRealized member to avoid sending a size message back to the interface.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.WMSize.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.WMWindowPosChanged">
<short>
Event handler for size/move messages.
</short>
<descr>
<p>
This method is called whenever left, top, width, height, clientwidth or 
clientheight have changed.
</p>
<p>
If the source of the message is the interface, the new size is stored in the 
internal BoundsRealized member. Avoids sending a size message back to the 
interface.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.WMWindowPosChanged.Message">
<short>
Window message handled in the method.
</short>
</element>

<element name="TWinControl.CNKeyDown">
<short>
Handler for a key pushed notification; the message is handled by 
DoKeyDownBeforeInterface by default.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CNKeyDown.Message">
<short>Message handled in the method.</short>
</element>

<element name="TWinControl.CNSysKeyDown">
<short>
Handler for a system key pushed notification; the message is handled by 
DoKeyDownBeforeInterface by default.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CNSysKeyDown.Message">
<short>Message handled in the method.</short>
</element>

<element name="TWinControl.CNKeyUp">
<short>
Handler for a key released notification; the message is handled by 
DoKeyUpBeforeInterface by default.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CNKeyUp.Message">
<short>Message handled in the method.</short>
</element>

<element name="TWinControl.CNSysKeyUp">
<short>
Handler for a system key released notification; the message is handled by 
DoKeyUpBeforeInterface by default.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CNSysKeyUp.Message">
<short>Message handled in the method.</short>
</element>

<element name="TWinControl.CNChar">
<short>
Handler for a key pressed notification; CNChar is sent by the widget before 
it has handled the key press itself.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CNChar.Message">
<short>Message handled in the method.</short>
</element>

<element name="TWinControl.DoDragMsg">
<short>Dispatches a drag message, sent by the DragManager.</short>
<descr>
<p>
On dmFindTarget, a TWinControl returns the child control under the mouse, or 
Self if none is found.
</p>
<p>
All other messages are handled by the inherited <link 
id="TControl.DoDragMsg"/> method.
</p>
</descr>
<seealso>
<link id="TControl.DoDragMsg"/>
</seealso>
</element>
<element name="TWinControl.DoDragMsg.Result">
<short/>
</element>
<element name="TWinControl.DoDragMsg.ADragMessage">
<short/>
</element>
<element name="TWinControl.DoDragMsg.APosition">
<short/>
</element>
<element name="TWinControl.DoDragMsg.ADragObject">
<short/>
</element>
<element name="TWinControl.DoDragMsg.ATarget">
<short/>
</element>
<element name="TWinControl.DoDragMsg.ADocking">
<short/>
</element>

<element name="TWinControl.DoDockClientMsg">
<short>
Handles a dmDragDock message, when a control has been docked to this site.
</short>
<descr>
<p>
Called when a control is dropped for docking. Asks the dropped control to 
Dock itself into this control (adjust HostDockSite etc.). Calls an installed 
DockManager to adjust the coordinates of the docked control. The Result is 
always <b>True</b> (unless overridden).
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.DoDockClientMsg.Result">
<short/>
</element>
<element name="TWinControl.DoDockClientMsg.DragDockObject">
<short/>
</element>
<element name="TWinControl.DoDockClientMsg.aPosition">
<short/>
</element>

<element name="TWinControl.DoUndockClientMsg">
<short>
Notifies the DockManager of the undock of a client control.
</short>
<descr/>
<seealso>
<link id="TDockManager.RemoveControl"/>
</seealso>
</element>
<element name="TWinControl.DoUndockClientMsg.Result">
<short>Always <b>True</b>.</short>
</element>
<element name="TWinControl.DoUndockClientMsg.NewTarget">
<short/>
</element>
<element name="TWinControl.DoUndockClientMsg.Client">
<short/>
</element>

<element name="TWinControl.DoAddDockClient">
<short>Adjust the Parent of a newly docked Client.</short>
<descr>
The default action is to set the Parent to the new docksite (this control), 
so that the client is displayed within the new site.
</descr>
</element>
<element name="TWinControl.DoAddDockClient.Client">
<short/>
</element>
<element name="TWinControl.DoAddDockClient.ARect">
<short/>
</element>

<element name="TWinControl.DockOver">
<short>Called to check whether this control allows docking and where.
</short>
<descr>
<p>
Called for messages from the DragManager including: dmEnter, dmLeave, and 
dmMove. Gets the DockRect to show.
</p>
<p>
Positions the DockRect, and invokes OnDockOver (via DoDockOver).
</p>
<p>
Everything can be overridden using the OnDockOver handler, when assigned.
</p>
</descr>
<seealso>
<link id="TControl.PositionDockRect"/>
<link id="TWinControl.OnDockOver"/>
</seealso>
</element>
<element name="TWinControl.DockOver.Source">
<short/>
</element>
<element name="TWinControl.DockOver.X">
<short/>
</element>
<element name="TWinControl.DockOver.Y">
<short/>
</element>
<element name="TWinControl.DockOver.State">
<short/>
</element>
<element name="TWinControl.DockOver.Accept">
<short>Initially <b>True</b>, set to <b>False</b> to reject an drop.</short>
</element>

<element name="TWinControl.DoDockOver">
<short>
Invoke the <link id="TWinControl.OnDockOver">OnDockOver</link> handler.
</short>
</element>
<element name="TWinControl.DoDockOver.Source">
<short/>
</element>
<element name="TWinControl.DoDockOver.X">
<short/>
</element>
<element name="TWinControl.DoDockOver.Y">
<short/>
</element>
<element name="TWinControl.DoDockOver.State">
<short/>
</element>
<element name="TWinControl.DoDockOver.Accept">
<short/>
</element>

<element name="TWinControl.DoRemoveDockClient">
<short>
Override this method to take special actions on removal of an docked client.
</short>
<descr>The default implementation does nothing.</descr>
</element>
<element name="TWinControl.DoRemoveDockClient.Client">
<short/>
</element>

<element name="TWinControl.DoUnDock">
<short>
Notifies an <var>OnUnDock</var> handler and the <var>DockManager</var> of an 
undocked client control.
</short>
<descr>
<p>
The <var>OnUnDock</var> handler can deny the undocking request for the 
control. This can cause problems; instead, the control better should not be 
draggable.
</p>
</descr>
<seealso>
<link id="TWinControl.DoUndockClientMsg"/>
<link id="TWinControl.OnUnDock"/>
</seealso>
</element>
<element name="TWinControl.DoUnDock.Result">
<short>Set to <b>False</b> to deny undocking.</short>
</element>
<element name="TWinControl.DoUnDock.NewTarget">
<short>The new docksite, <b>Nil</b> for floating.</short>
</element>
<element name="TWinControl.DoUnDock.Client">
<short>The control being undocked.</short>
</element>
<element name="TWinControl.DoUnDock.KeepDockSiteSize">
<short/>
</element>

<element name="TWinControl.GetSiteInfo">
<short>Return information about this dock site (InfluenceRect).</short>
<descr>
<p>
The <var>InfluenceRect</var> determines the screen coordinates, within which 
a drop is accepted. The <var>InfluenceRect</var> is the slightly inflated 
<var>WindowRect</var> for the dock site, and can be adjusted in the 
<var>OnGetSiteInfo</var> event handler.
</p>
</descr>
</element>
<element name="TWinControl.GetSiteInfo.Client">
<short>The dragged control.</short>
</element>
<element name="TWinControl.GetSiteInfo.InfluenceRect">
<short>The screen rectangle within which a drop is allowed.</short>
</element>
<element name="TWinControl.GetSiteInfo.MousePos">
<short>The current mouse position.</short>
</element>
<element name="TWinControl.GetSiteInfo.CanDock">
<short>Can be set to <b>False</b> to reject an drop.</short>
</element>

<element name="TWinControl.GetParentHandle">
<short>Gets the handle for the Parent control.</short>
<descr>
<p>
<var>GetParentHandle</var> is a <var>HWND</var> function used to get the 
handle for the Parent in the current control. The return value contains the 
handle for the TWinControl instance in Parent (when assigned). When 
unassigned, the handle in ParentWindow is used as the return value.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TWinControl.ParentWindow"/>
</seealso>
</element>
<element name="TWinControl.GetParentHandle.Result">
<short>
Control or window handle that is the parent for the current control.
</short>
</element>

<element name="TWinControl.GetTopParentHandle">
<short>
Gets the window handle for the parent control at the top of the control 
hierarchy.
</short>
<descr>
<p>
GetTopParentHandle is a HWND function used to get the window handle for the 
first control in the parent control hierarchy. The value in Parent is 
recursively searched until Parent is not assigned.
</p>
<p>
The return value is the ParentWindow property in the top-most control. If 
ParentWindow is 0 (the unassigned value), the value in its Handle property is 
used.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.GetTopParentHandle.Result">
<short>Window handle for the top-most parent control in the hierarchy.</short>
</element>

<element name="TWinControl.ReloadDockedControl">
<short>Returns the docked control of the specified name.</short>
<descr>
<p>This method is used during the restore of the layout of a docksite.</p>
<p>The control is searched in the controls owned by the owner of the 
docksite.</p>
<p>Override to search other places, or to create a control of the requested 
name.</p>
</descr>
</element>
<element name="TWinControl.ReloadDockedControl.AControlName">
<short>The name of the control to be docked.</short>
</element>
<element name="TWinControl.ReloadDockedControl.AControl">
<short>The matching control.</short>
</element>

<element name="TWinControl.CreateDockManager">
<short>Returns the DockManager for this control.</short>
<descr>
<p>
If DockManager is <b>Nil</b>, and <var>UseDockManager</var> is <b>True</b>, a 
new default DockManager is created.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.CreateDockManager.Result">
<short>
The dockmanager for this site, can be <b>Nil</b> for an unmanaged site.
</short>
</element>

<element name="TWinControl.SetDockManager">
<short>Sets the value for the DockManager property.</short>
<descr/>
<seealso>
<link id="TWinControl.DockManager"/>
</seealso>
</element>
<element name="TWinControl.SetDockManager.AMgr">
<short>New value for the DockManager property.</short>
</element>

<element name="TWinControl.DoFloatMsg">
<short>Handler called when the control starts floating.</short>
<descr>
<p>
A TWinControl can be floated as a stand-alone window, unless they request a 
special FloatingDockSiteClass.
</p>
</descr>
<seealso>
<link id="TControl.DoFloatMsg"/>
</seealso>
</element>
<element name="TWinControl.DoFloatMsg.ADockSource">
<short/>
</element>

<element name="TWinControl.DoGetDockCaption">
<short>Returns the dock caption in AControl.</short>
<descr>
<p>
Asks the control for its default dock caption, then allows the 
OnGetDockCaption handler to adjust the string value.
</p>
</descr>
<seealso>
<link id="TWinControl.GetDockCaption"/>
<link id="TWinControl.OnGetDockCaption"/>
</seealso>
</element>
<element name="TWinControl.DoGetDockCaption.AControl">
<short>The control whose dock caption string is requested.</short>
</element>
<element name="TWinControl.DoGetDockCaption.ACaption">
<short>The dock caption to use.</short>
</element>

<element name="TWinControl.DoEnter">
<short>
Signals the OnEnter event handler (when assigned) when the control receives 
focus.
</short>
<descr>
<p>
<var>DoEnter</var> is called from the CMEnter method when a CM_ENTER message 
is received for the control. The event handler allows actions to be performed 
when the control receives focus, either by using keyboard navigation or by 
mouse click in the client area for the control.
</p>
</descr>
<seealso>
<link id="TWinControl.OnEnter"/>
<link id="TWinControl.CMEnter"/>
<link id="TWinControl.DoExit"/>
<link id="TWinControl.OnExit"/>
</seealso>
</element>

<element name="TWinControl.DoExit">
<short>
Signals the OnExit event handler (when assigned) when the control loses focus.
</short>
<descr>
<p>
<var>DoExit</var> is called from the CMExit method when a CM_EXIT message is 
received for the control. The event handler allows actions to be performed 
when the control loses focus, either by using keyboard navigation or by mouse 
click in the client area for another control.
</p>
</descr>
<seealso>
<link id="TWinControl.OnExit"/>
<link id="TWinControl.CMExit"/>
<link id="TWinControl.DoEnter"/>
<link id="TWinControl.OnEnter"/>
</seealso>
</element>

<element name="TWinControl.DoKeyDownBeforeInterface">
<short>Handles a KeyDown event before the widget processes the key.
</short>
<descr>
<p>
Key event handlers are invoked in sequence, until a handler is located which 
responds to the key.
</p>
<p>
First, all application wide handlers are invoked 
(<var>TApplication.NotifyKeyDownBeforeHandler</var>).
</p>
<p>
Second, the form handler is invoked when KeyPreview is requested.
</p>
<p>
Third, the DragManager is used to determine the dragging status for the 
control. It interprets the <b>ESC</b> key as a cancel dragging request, and 
the <b>CTRL</b> key as a request to ignore drag targets.
</p>
<p>
Finally, the <link id="TWinControl.OnKeyDown"/> user handler is invoked.
</p>
<p>
If none of the handlers accept / respond to the key, the widgetset class is 
used to process the key.
</p>
</descr>
<seealso>
<link id="TWinControl.OnKeyDown"/>
<link id="#lcl.Forms.TApplication.NotifyKeyDownBeforeHandler">
TApplication.NotifyKeyDownBeforeHandler</link>
</seealso>
</element>
<element name="TWinControl.DoKeyDownBeforeInterface.Result">
<short>Set to <b>True</b> when the key was handled.</short>
</element>
<element name="TWinControl.DoKeyDownBeforeInterface.Message">
<short>Message examined in the method.</short>
</element>
<element name="TWinControl.DoKeyDownBeforeInterface.IsRecurseCall">
<short/>
</element>

<element name="TWinControl.DoRemainingKeyDown">
<short>
Handles key down messages which are not handled by the widget.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.DoRemainingKeyDown.Result">
<short><b>True</b> if the key was handled.</short>
</element>
<element name="TWinControl.DoRemainingKeyDown.Message">
<short>
Key down message examined in the method.
</short>
</element>

<element name="TWinControl.DoRemainingKeyUp">
<short>
Handles key up messages not already handled by the widget.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.DoRemainingKeyUp.Result">
<short><b>True</b> if the key was handled.</short>
</element>
<element name="TWinControl.DoRemainingKeyUp.Message">
<short>
Key up message examined in the method.
</short>
</element>

<element name="TWinControl.DoKeyPress">
<short>
Performs actions needed to handle a key press message for the control.
</short>
<descr>
<p>
<var>DoKeyPress</var> is a <var>Boolean</var> function used to handle a key 
press event received for the control. The return value is <b>True</b> if the 
character code in the specified Message is handled for the control.
</p>
<p>
DoKeyPress allows a TCustomForm instance in Parent with KeyPreview enabled to 
handle the notification message using its DoKeyPress method. If the character 
code is handled, the return value is set and no further actions are performed 
in the method.
</p>
<p>
The return value is <b>False</b> when standard events have been disabled by 
including csNoStdEvents in the ControlStyle property.
</p>
<p>
When not disabled, the KeyPress method is called using the character code in 
Message as an argument. If the character was handled in the OnKeyPress event 
handler, the return value is <b>True</b>.
</p>
<p>
DoKeyPress is called from the CNChar method when a CN_CHAR control 
notification message is received for the control.
</p>
</descr>
<seealso>
<link id="TWinControl.OnKeyPress"/>
<link id="TWinControl.OnUTF8KeyPress"/>
<link id="TWinControl.DoUTF8KeyPress"/>
<link id="TWinControl.CNChar"/>
<link id="TControl.ControlStyle"/>
</seealso>
</element>
<element name="TWinControl.DoKeyPress.Result">
<short><b>True</b> if the key press was handled for the control.</short>
</element>
<element name="TWinControl.DoKeyPress.Message">
<short>Control Notification message handled in the method.</short>
</element>

<element name="TWinControl.DoUTF8KeyPress">
<short>
Performs actions needed to handle a UTF-8-encoded key press message for the 
control.
</short>
<descr>
<p>
<var>DoUTF8KeyPress</var> is a <var>Boolean</var> function used to handle a 
key press event for a UTF-8-encoded value received for the control. The 
return value is <b>True</b> if the character code in the specified Message is 
handled for the control.
</p>
<p>
DoUTF8KeyPress allows a TCustomForm instance in Parent with KeyPreview 
enabled to handle the notification message using its DoUTF8KeyPress method. 
If the character code is handled, the return value is set and no further 
actions are performed in the method.
</p>
<p>
The return value is <b>False</b> when standard events have been disabled by 
including csNoStdEvents in the ControlStyle property.
</p>
<p>
When not disabled, the UTF8KeyPress method is called using the character code 
in Message as an argument. If the character was handled in the OnUTF8KeyPress 
event handler, the return value is <b>True</b>.
</p>
<p>
At design-time, DoUTF8KeyPress redirects the key event to the active design 
surface in the Lazarus IDE.
</p>
<p>
DoUTF8KeyPress is called from the IntfUTF8KeyPress method when a CN_CHAR 
control notification message is received for the control. DoUTF8KeyPress is 
called after KeyDown has been executed.
</p>
</descr>
<seealso>
<link id="TWinControl.OnUTF8KeyPress"/>
<link id="TWinControl.IntfUTF8KeyPress"/>
<link id="TWinControl.OnKeyPress"/>
<link id="TWinControl.DoKeyPress"/>
<link id="TWinControl.CNChar"/>
<link id="TControl.ControlStyle"/>
</seealso>
</element>
<element name="TWinControl.DoUTF8KeyPress.Result">
<short><b>True</b> if the key was handled.</short>
</element>
<element name="TWinControl.DoUTF8KeyPress.UTF8Key">
<short>UTF-8-encoded character examined in the method.</short>
</element>

<element name="TWinControl.DoKeyUpBeforeInterface">
<short>
Handles a KeyUp event before the widget processes the key.
</short>
<descr>
<p>
For details, see the <link id="TWinControl.DoKeyDownBeforeInterface"/> method.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.DoKeyUpBeforeInterface.Result">
<short><b>True</b> if the key was handled.</short>
</element>
<element name="TWinControl.DoKeyUpBeforeInterface.Message">
<short>Message examined in the method.</short>
</element>

<element name="TWinControl.ChildKey">
<short>
Allows a parent form to process a keyboard message in one of its child 
controls.
</short>
<descr>
<remark>
WantChildKey in TCustomForm always returns <b>False</b>.
</remark>
</descr>
<seealso>
<link id="TWinControl.DoRemainingKeyDown"/>
<link id="#lcl.forms.TCustomForm.WantChildKey">TCustomForm.WantChildKey</link>
</seealso>
</element>
<element name="TWinControl.ChildKey.Result">
<short><b>True</b> if the key message was handled.</short>
</element>
<element name="TWinControl.ChildKey.Message">
<short>Child key message handled in the method.</short>
</element>

<element name="TWinControl.SendDialogChar">
<short>
Forwards the key message to the parent form to be handled as an accelerator 
(shortcut) key.
</short>
<descr>
<p>
If the dialog character is handled in the Parent form, the CharCode member in Message is set to VK_UNKNOWN (0).
</p>
<p>
No actions are performed in the method when accelerator keys are not enabled 
for the LCL interface, or when ParentForm is unassigned for the control.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.SendDialogChar.Result">
<short><b>True</b> if the key was handled.</short>
</element>
<element name="TWinControl.SendDialogChar.Message">
<short>
Message with the key event handled and updated in the method.
</short>
</element>

<element name="TWinControl.DialogChar">
<short>
Handles the specified key in Message as an accelerator or shortcut key.
</short>
<descr>
<p>
DialogChar is an overridden Boolean function in TWinControl used to handle a 
character code in Message as an accelerator (or shortcut) key for a control. 
It re-implements the inherited method which always returns <b>False</b>. In 
TWinControl, the Message is sent to each of the children in Controls until 
one of them indicates that it responds to the accelerator key.
</p>
<p>
DialogChar is overridden in descendent classes to perform actions needed when 
the shortcut key is handled in the method. These classes allow the 
accelerator key to be defined using the Caption or Shortcut properties. Some 
examples include:
</p>
<ul>
<li>TCustomGrid / TGrid</li>
<li>TCustomButton / TButton</li>
<li>TCustomLabel / TLabel</li>
<li>TCustomStaticText / TStaticText</li>
<li>TCustomSpeedButton / TSpeedButton</li>
</ul>
</descr>
<seealso>
<link id="#lcl.controls.TControl.DialogChar">TControl.DialogChar</link>
</seealso>
</element>
<element name="TWinControl.DialogChar.Result">
<short><b>True</b> if the key was handled.</short>
</element>
<element name="TWinControl.DialogChar.Message">
<short>Message with the character examined in the method.</short>
</element>

<element name="TWinControl.ControlKeyDown">
<short>
Handles key down events for special navigation keys used in a control.
</short>
<descr>
<p>
<var>ControlKeyDown</var> is a method used to detect and handle key down 
events for navigation keys used in the control. ControlKeyDown calls the 
corresponding method in TApplication to determine the actions needed for the 
key and modifier. The application handles Tab and cursor keys which may 
affect control or form focus.
</p>
<p>
ControlKeyDown is called from the DoRemainingKeyDown method to handle keys 
not otherwise handled by a control or its parent forms.
</p>
</descr>
<seealso>
<link id="TWinControl.DoRemainingKeyDown"/>
<link id="#lcl.forms.TApplication.ControlKeyDown">TApplication.ControlKeyDown</link>
<link id="#lcl.forms.TApplication.DoTabKey">TApplication.DoTabKey</link>
<link id="#lcl.forms.TApplication.DoArrowKey">TApplication.DoArrowKey</link>
</seealso>
</element>
<element name="TWinControl.ControlKeyDown.Key">
<short>Numeric key code examined in the method.</short>
</element>
<element name="TWinControl.ControlKeyDown.Shift">
<short>Shift, Ctrl, or Alt modifier for the key.</short>
</element>

<element name="TWinControl.ControlKeyUp">
<short>Handles key up events for special navigation keys.</short>
<descr>
<p>
<var>ControlKeyUp</var> is a method used to detect and handle key up events 
for navigation keys used in the control. ControlKeyUp calls the corresponding 
method in TApplication to determine the actions needed for the key and 
modifier. The application handles Return (Enter) and Escape keys which may 
affect control or form focus.
</p>
<p>
ControlKeyUp is called from the DoRemainingKeyUp method to handle keys not 
otherwise handled by a control or its parent forms.
</p>
</descr>
<seealso>
<link id="TWinControl.DoRemainingKeyUp"/>
<link id="#lcl.forms.TApplication.ControlKeyUp">TApplication.ControlKeyUp</link>
<link id="#lcl.forms.TApplication.DoReturnKey">TApplication.DoReturnKey</link>
<link id="#lcl.forms.TApplication.DoEscapeKey">TApplication.DoEscapeKey</link>
</seealso>
</element>
<element name="TWinControl.ControlKeyUp.Key">
<short>Numeric key code examined in the method.</short>
</element>
<element name="TWinControl.ControlKeyUp.Shift">
<short>Shift, Ctrl, or Alt modifier for the key.</short>
</element>

<element name="TWinControl.KeyDown">
<short>
Signals OnKeyDown event handlers (when assigned).
</short>
<descr>
<p>
<var>KeyDown</var> is a method used to signal the assigned 
<var>OnKeyDown</var> event handler(s) for the control. It provides arguments 
with the virtual key code and the state modifiers for the TKeyEvent type.
</p>
<p>
KeyDown signals the OnKeyDown event handler (when assigned). The handler 
routine can modify the Key argument if it is handled (or discarded) in the 
event handler. Set Key to VK_UNKNOWN (0) in the handler routine if the key 
event is either applied or discarded by the handler.
</p>
<p>
When Key has a non-zero value - because OnKeyDown was not assigned or did not 
handle the key - DoCallKeyEventHandler is called to check other chtOnKeyDown 
handlers added to the control using AddHandler or AddHandlerOnKeyDown.
</p>
<p>
KeyDown is called from the KeyDownBeforeInterface method. It occurs after the Application, any forms with KeyPreview enabled, and the active DragManager have examined and possibly handled the key event.
</p>
<p>
See KeyUp for the actions performed when the key is released.
</p>
</descr>
<seealso>
<link id="TWinControl.OnKeyDown"/>
<link id="TWinControl.KeyUp"/>
<link id="TWinControl.KeyDownBeforeInterface"/>
<link id="TControl.DoCallKeyEventHandler"/>
<link id="TControl.AddHandler"/>
<link id="TControl.AddHandlerOnKeyDown"/>
<link id="TKeyEvent"/>
<link id="TControlHandlerType"/>
<link id="#lcl.forms.TCustomForm.KeyPreview">TCustomForm.KeyPreview</link>
<link id="#lcl.forms.TCustomForm.IsShortcut">TCustomForm.IsShortcut</link>
<link id="#lcl.forms.TApplication.IsShortcut">TApplication.IsShortcut</link>
<link id="#lcl.forms.Application">Application</link>
</seealso>
</element>
<element name="TWinControl.KeyDown.Key">
<short>Numeric key code examined and handled in the method.</short>
</element>
<element name="TWinControl.KeyDown.Shift">
<short>Shift, Ctrl, or Alt modifier for the key.</short>
</element>

<element name="TWinControl.KeyDownBeforeInterface">
<short>
Allows the application, parent forms, or control to handle key preview before 
the LCL interface.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.KeyDownBeforeInterface.Key">
<short>Numeric key code examined in the method.</short>
</element>
<element name="TWinControl.KeyDownBeforeInterface.Shift">
<short>Shift, Ctrl, or Alt modifier for the key.</short>
</element>

<element name="TWinControl.KeyDownAfterInterface">
<short>An empty implementation in the current LCL version.</short>
<descr>
<p>
An empty implementation in the current LCL version.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.KeyDownAfterInterface.Key">
<short>
Numeric key code handled in the method.
</short>
</element>
<element name="TWinControl.KeyDownAfterInterface.Shift">
<short>
Shift, Ctrl, or Alt modifier for the key.
</short>
</element>

<element name="TWinControl.KeyPress">
<short>
Signals the OnKeyPress event handler (when assigned).
</short>
<descr>
<p>
<var>KeyPress</var> is called from the DoKeyPress method when the parent form 
does not have KeyPreview enabled or does not handle the character code in 
<var>Key</var>. KeyPress is <b>not</b> called if csNoStdEvents has been 
included in the ControlStyle property.
</p>
<p>
See UTF8KeyPress for the actions performed for a UTF-8-encoded character in a 
key press.
</p>
</descr>
<seealso>
<link id="TWinControl.UTF8KeyPress"/>
</seealso>
</element>
<element name="TWinControl.KeyPress.Key">
<short>
Character value for the key press event.
</short>
</element>

<element name="TWinControl.KeyUp">
<short>
Signals the OnKeyUp event handler (when assigned).
</short>
<descr>
<p>
<var>KeyUp</var> is a method used to signal the OnKeyUp event handler (when 
assigned). It provides the arguments with the virtual key code and the state 
modifiers for the TKeyEvent type.
</p>
<p>
KeyUp is called from the KeyUpBeforeInterface method. It occurs after forms 
with KeyPreview enabled or the active DragManager have examined and possibly 
handled the key event.
</p>
<p>
See KeyDown for the actions performed when the key down event has occurred.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.KeyUp.Key">
<short>Numeric key code for the key up event.</short>
</element>
<element name="TWinControl.KeyUp.Shift">
<short>Shift, Ctrl, or Alt modifier for the key.</short>
</element>

<element name="TWinControl.KeyUpBeforeInterface">
<short>
Signals the OnKeyUp handler (when assigned)) before calling the LCL interface.
</short>
<descr/>
<seealso>
<link id="TWinControl.KeyUp"/>
<link id="TWinControl.DoKeyUpBeforeInterface"/>
<link id="TWinControl.OnKeyUp"/>
<link id="TControl.ControlStyle"/>
<link id="DragManager"/>
<link id="#lcl.forms.TCustomForm.KeyPreview">TCustomForm.KeyPreview</link>
</seealso>
</element>
<element name="TWinControl.KeyUpBeforeInterface.Key">
<short>
Numeric key code for the key up event.
</short>
</element>
<element name="TWinControl.KeyUpBeforeInterface.Shift">
<short>
Shift, Ctrl, or Alt modifier for the key.
</short>
</element>

<element name="TWinControl.KeyUpAfterInterface">
<short>
An empty implementation in the current LCL version.
</short>
<descr>
<p>
An empty implementation in the current LCL version.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.KeyUpAfterInterface.Key">
<short>
Numeric key code for the key up event.
</short>
</element>
<element name="TWinControl.KeyUpAfterInterface.Shift">
<short>
Shift, Ctrl, or Alt modifier for the key.
</short>
</element>

<element name="TWinControl.UTF8KeyPress">
<short>
Signals the OnUTF8KeyPress event handler (when assigned).
</short>
<descr>
<p>
<var>UTF8KeyPress</var> is called from the DoUTF8KeyPress method when the 
parent form does not have KeyPreview enabled or does not handle the character 
code in <var>Key</var>. UTF8KeyPress is <b>not</b> called if csNoStdEvents has 
been included in the ControlStyle property.
</p>
<p>
The handler routine in OnUTF8KeyPress can modify the value in the Key 
argument. It sets Key to an empty string ('') if the encoded value is handled 
in the routine.
</p>
<p>
See KeyPress for the actions performed for a character value that does not use 
UTF-8 encoding.
</p>
</descr>
<seealso>
<link id="TWinControl.OnUTF8KeyPress"/>
<link id="TWinControl.OnKeyPress"/>
<link id="TWinControl.KeyPress"/>
<link id="TUTF8KeyPressEvent"/>
</seealso>
</element>
<element name="TWinControl.UTF8KeyPress.UTF8Key">
<short>
UTF-8-encoded character value for the key press event.
</short>
</element>

<element name="TWinControl.FindNextControl">
<short>
Returns the preceding or next control in the tab order.
</short>
<descr>
<p>
When <var>CurrentControl</var> is <b>Nil</b>, the first control (forward) or 
last control (backward) in the TabOrder is returned; direction depends on the 
value in <var>GoForward</var>.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.FindNextControl.Result">
<short>The (next) control.</short>
</element>
<element name="TWinControl.FindNextControl.CurrentControl">
<short>
The control which has the focus. If <b>Nil</b>, the first control (forward) 
or last control (backward) in TabOrder is returned, depending on GoForward.
</short>
</element>
<element name="TWinControl.FindNextControl.GoForward">
<short> <b>False</b> to find the preceding control.</short>
</element>
<element name="TWinControl.FindNextControl.CheckTabStop">
<short>When <b>True</b> only a control with TabStop enabled is found.</short>
</element>
<element name="TWinControl.FindNextControl.CheckParent">
<short>
When <b>True</b> only a control with Parent set to Self is found.
</short>
</element>

<element name="TWinControl.SelectFirst">
<short>
Returns the first control in the tab order for the parent form.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.RealGetText" link="#lcl.controls.TControl.RealGetText"/>
<element name="TWinControl.RealGetText.Result"/>

<element name="TWinControl.GetBorderStyle">
<short>Gets the value for the BorderStyle property.</short>
<descr/>
<seealso>
<link id="TWinControl.BorderStyle"/>
</seealso>
</element>
<element name="TWinControl.GetBorderStyle.Result">
<short>Value for the BorderStyle property.</short>
</element>

<element name="TWinControl.GetClientOrigin">
<short>
Gets the top, left screen coordinates for the client area in the control.
</short>
<descr>
</descr>
<seealso>
<link id="#lcl.controls.TControl.GetClientOrigin">TControl.GetClientOrigin</link>
</seealso>
</element>
<element name="TWinControl.GetClientOrigin.Result">
<short>
TPoint instance with the screen coordinates for the origin of the control.
</short>
</element>

<element name="TWinControl.GetClientRect">
<short>Gets the value for the ClientRect property.</short>
<descr>
<p>
<var>GetClientRect</var> is an overridden method in TWinControl used to get 
the value for the ClientRect property. ClientRect contains the visual client 
area for the control.
</p>
<p>
GetClientRect extends the inherited method to synchronize values in the 
control with its widgetset class instance using the Handle for the control. 
It uses values in ComponentState and the control flags for the TWinControl 
instance to determine the actions needed in the method. If an action cannot 
be determined, or the handle is not available, values in ClientWidth and 
ClientHeight are used as the Width and Height in the TRect instance.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.GetClientRect">TControl.GetClientRect</link>
</seealso>
</element>
<element name="TWinControl.GetClientRect.Result">
<short>Value for the ClientRect property.</short>
</element>

<element name="TWinControl.GetControlOrigin">
<short>Gets the value for the ControlOrigin property.</short>
<descr>
<p>
<var>GetControlOrigin</var> is overridden in TWinControl to get a window 
rectangle from the LCL interface. If the Handle for the control has not been 
allocated, the inherited method is called.
</p>
<p>
Returns the screen coordinates for the Top and Left coordinate 0,0 of the 
control area. (The top / left pixel of the control on the screen). Note that 
this value is the position as stored in the interface and is not always in 
sync with the LCL. When a control is moved, the LCL sets the bounds to the 
wanted position and sends a move message to the interface. It is up to the 
interface to handle moves instantly or to queue them.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.GetControlOrigin">TControl.GetControlOrigin</link>
</seealso>
</element>
<element name="TWinControl.GetControlOrigin.Result">
<short>
TPoint instance with the screen coordinates for the Top and Left properties.
</short>
</element>

<element name="TWinControl.GetDeviceContext">
<short>Gets the device context for the control.</short>
<descr>
<p>
<var>GetDeviceContext</var> is an overridden <var>HDC</var> function in 
TWinControl used to get the device context used for the control.
</p>
<p>
The device context provides a Handle (yes another one) with information about 
the drawing region on a display or printer. In the LCL, this essentially 
identifies a clipping rectangle for a given window handle. In TControl, the 
device context for the WindowHandle in the Parent control is used (because it 
does not have its own handle). In TWinControl, the Handle for the control is 
used.
</p>
<p>
GetDevice context calls the GetDC routine in the LCL interface to get a 
device context for the value in its Handle property. On successful completion 
of the routine, the return value is also assigned to the WindowHandle 
argument (which is the member for the WindowHandle property for display 
purposes).
</p>
<p>
An EOutOfResources exception is raised when GetDC returns an unassigned 
device context (0).
</p>
<p>
GetDeviceContext re-implements the inherited method.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.GetDeviceContext.Result">
<short>Device context created for the control, or 0 when unavailable.</short>
</element>
<element name="TWinControl.GetDeviceContext.WindowHandle">
<short>
Handle for the control represented in the device context. Updated in the 
method.
</short>
</element>

<element name="TWinControl.IsControlMouseMsg">
<short>
Sends the specified mouse message to a child control.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.IsControlMouseMsg.Result">
<short>
<b>True</b> if a child control was found at the mouse coordinates.
</short>
</element>
<element name="TWinControl.IsControlMouseMsg.TheMessage">
<short/>
</element>

<element name="TWinControl.CreateHandle">
<short>Creates the Handle for the widget, if not already created.</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.CreateParams">
<short>
Initializes the window creation parameter record with the settings for the 
control.
</short>
<descr>
<p>
<var>CreateParams</var> is a procedure used to initialize and/or update 
creation parameters in the <var>Params</var> argument. CreateParams is called 
from the <var>CreateWnd</var> method when the window handle is allocated for 
the control.
</p>
<p>
CreateParams ensures that values in the <var>TCreateParams</var> record 
instance contain the values needed for the class instance. The following 
members in the record are update:
</p>
<dl>
<dt>Caption</dt>
<dd>Set to the value in the Caption property.</dd>
<dt>Style</dt>
<dd>
Includes flag values: WS_CHILD, WS_CLIPSIBLINGS, WS_CLIPCHILDREN, and 
WS_TABSTOP when needed.
</dd>
<dt>ExStyle</dt>
<dd>Includes style values needed for the value in ControlStyle and 
BorderStyle.</dd>
<dt>WndParent</dt>
<dd>Set to the handle in ParentWindow, or Parent.Handle when assigned.</dd>
<dt>X, Y, Width, Height</dt>
<dd>Set to the property values in the class instance.</dd>
</dl>
</descr>
<seealso>
<link id="TWinControl.CreateWnd"/>
<link id="#lcl.lcltype.TCreateParams">TCreateParams</link>
</seealso>
</element>
<element name="TWinControl.CreateParams.Params">
<short>Create parameters updated in the method.</short>
</element>

<element name="TWinControl.CreateWnd">
<short>
Creates the interface object (widget) and assigns the value in Handle.
</short>
<descr>
<p>
Raises a catchable debugger exception for various conditions, including:
</p>
<ul>
<li>
The control, or its <var>Parent</var>, has the value <var>csDestroying</var> 
in the <var>ComponentState</var> property.
</li>
<li>
The method has been called recursively, as indicated by values in the window 
control flags.
</li>
<li>
The method has been called at run-time before LCL component streaming has 
been completed.
</li>
<li>
The <var>Handle</var> was not successfully created in the widgetset class.
</li>
</ul>
<p>
Ensures that the realized bounds for the control is reset prior to creating 
the Handle for the control and any child <var>Controls</var>. An 
<var>EInvalidOperation</var> exception is raised if the handle for the Parent 
control is not valid when the method is called.
</p>
<p>
Calls the <var>InvalidatePreferredSize</var> method for the control, and any 
child controls, and calls <var>AdjustSize</var>. If an error occurred while 
creating the Handle, auto-sizing is not enabled for the control.
</p>
<p>
CreateWnd is called from the <var>CreateHandle</var> method.
</p>
</descr>
<seealso>
<link id="TWinControl.CreateHandle"/>
</seealso>
</element>

<element name="TWinControl.DestroyHandle">
<short>Destroys the handle for the control and all child controls.</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.DestroyWnd">
<short>Destroys the interface object (widget).</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.DoFlipChildren">
<short>Flip children horizontally (mirrors the Left position).</short>
<descr>
<p>
Child controls arranged in left-to-right order appear in right-to-left order 
after flipping. All anchors are adjusted accordingly.
</p>
</descr>
<seealso>
<link id="TWinControl.FlipChildren"/>
</seealso>
</element>

<element name="TWinControl.FinalizeWnd">
<short>
Prepares to remove the window (called before the Handle is destroyed).
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.FixupTabList">
<short>
Assigns sequential TabOrder values to child controls.
</short>
<descr>
<p>
Called from the Loaded method when LCL component streaming is completed. It 
occurs before auto-sizing is enabled for the component.
</p>
</descr>
<seealso>
<link id="TWinControl.Loaded"/>
</seealso>
</element>

<element name="TWinControl.FontChanged">
<short>
Implements the event handler signalled when the Font has been changed for the 
control.
</short>
<descr>
<p>
<var>FontChanged</var> is an overridden method in <var>TWinControl</var> 
which implements the handler assigned for OnChange events in the control 
Font. The assignment occurs in the inherited constructor. FontChanged is 
called when a new value of assigned to the Font property in the control.
</p>
<p>
FontChanged ensures that the widgetset class instance uses the TFont instance 
in the Sender argument when its handle has been allocated. It also updates 
the control flags to remove the value wcfFontChanged when the widgetset class 
has been updated. If the widgetset handle has not been allocated, the value 
wcfFontChanged is included in the control flags.
</p>
<p>
FontChanged calls the inherited method. NotifyControls is called to notify 
child controls of the change to their parent font.
</p>
</descr>
<seealso>
<link id="TWinControl.NotifyControls"/>
<link id="TControl.FontChanged"/>
</seealso>
</element>
<element name="TWinControl.FontChanged.Sender">
<short>Object instance (TFont) for the event notification.</short>
</element>

<element name="TWinControl.InitializeWnd">
<short>
Copies cached control properties to the newly created widget.
</short>
<descr>
<p>
Called after the Handle is created, and before child handles are created.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.Loaded">
<short>
Performs actions when a component has been loaded during LCL streaming.
</short>
<descr>
<p>
<var>Loaded</var> is an overridden method in <var>TWinControl</var> used to 
perform actions needed when a component has been loaded from a resource 
during LCL streaming. It extends the inherited method to align and resize it 
child Controls, as well synchronize property values with those in the 
widgetset class instance when its handle has been allocated.
</p>
<p>
Loaded calls the inherited method to update the BaseBounds for control, and 
to apply property values dependent on the Parent control.
</p>
<p>
Loaded calls FixupTabList to populate an internal list with child Controls 
ordered by their TabOrder property.
</p>
</descr>
<seealso>
<link id="TWinControl.FixupTabList"/>
<link id="TControl.Loaded"/>
</seealso>
</element>

<element name="TWinControl.FormEndUpdated">
<short>
Realizes all cached changes after a bulk update to a form. Calls the 
inherited <var>FormEndUpdated</var> method, then informs each child control.
</short>
<descr/>
<seealso>
<link id="TControl.FormEndUpdated"/>
</seealso>
</element>

<element name="TWinControl.MainWndProc">
<short>
The message handler loop for the control.
</short>
<descr>
<p>
Used for controls which need features not yet supported by the LCL. 
MainWndProc has an empty implementation in TWinControl.
</p>
</descr>
<seealso>
<link id="#lcl.forms.TApplication">TApplication</link>
</seealso>
</element>
<element name="TWinControl.MainWndProc.Msg">
<short>Message handled in the method.</short>
</element>

<element name="TWinControl.ParentFormHandleInitialized">
<short>
Called after all child handles for the ParentForm are created; notifies all 
children of the end of the handle creation phase.
</short>
<descr/>
<seealso>
<link id="TControl.ParentFormHandleInitialized"/>
</seealso>
</element>

<element name="TWinControl.ChildHandlesCreated">
<short>
Called after all child handles have been created; resets 
wcfCreatingChildHandles.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.GetMouseCapture">
<short>Gets the value for the MouseCapture property.</short>
<descr>
<p>
<var>GetMouseCapture</var> is a <var>Boolean</var> function used to get the 
value for the MouseCapture property. It is overridden in TWinControl to ensure 
that the Handle for the control has been allocated. The return value is 
<b>True</b> when HandleAllocated returns <b>True</b>, and GetCaptureControl 
returns the current class instance.
</p>
</descr>
<seealso>
<link id="TControl.MouseCapture"/>
<link id="TControl.GetMouseCapture"/>
<link id="GetCaptureControl"/>
</seealso>
</element>
<element name="TWinControl.GetMouseCapture.Result">
<short>Value for the MouseCapture property.</short>
</element>

<element name="TWinControl.RealSetText">
<short>Sets the text / caption for the control.</short>
<descr>
<p>
<var>RealSetText</var> is an overridden method in TWinControl. It ensures 
that the new value is applied to the widgetset class when its Handle has been 
allocated, and the control size is adjusted when needed/enabled. The 
inherited method is called to apply AValue to the Text and/or Caption 
properties for the control.
</p>
</descr>
<seealso>
<link id="TWinControl.WSSetText"/>
<link id="TControl.Caption"/>
<link id="TControl.Text"/>
<link id="TControl.RealSetText"/>
<link id="TControl.RealGetText"/>
<link id="TControl.AdjustSize"/>
</seealso>
</element>
<element name="TWinControl.RealSetText.AValue">
<short>New value for the text / caption for the control.</short>
</element>

<element name="TWinControl.RemoveFocus">
<short>Notifies the parent Form when the control cannot be focused.</short>
<descr>
<p>
<var>RemoveFocus</var> is a method used to notify the parent form when the 
control cannot be focused. RemoveFocus is called from methods like Destroy 
and RemoveControl, where the control will no longer exist on the parent form. 
It is also called from methods like CMEnabledChanged and CMVisibleChanged, 
where the parent form should no longer allow the control to be focused.
</p>
<p>
RemoveFocus calls GetParentForm to get the parent form instance, and calls 
its DefocusControl method to ensure that the control is removed as the 
ActiveControl (when assigned).
</p>
</descr>
<seealso>
<link id="TWinControl.CMEnabledChanged"/>
<link id="TWinControl.CMVisibleChanged"/>
<link id="TWinControl.RemoveControl"/>
<link id="TWinControl.Destroy"/>
<link id="#lcl.forms.TCustomForm.DefocusControl">TCustomForm.DefocusControl</link>
<link id="#lcl.forms.TCustomForm.ActiveControl">TCustomForm.ActiveControl</link>
<link id="#lcl.forms.GetParentForm">GetParentForm</link>
</seealso>
</element>
<element name="TWinControl.RemoveFocus.Removing">
<short>
<b>True</b> if the control is being freed, <b>False</b> when it is not 
enabled or not visible.
</short>
</element>

<element name="TWinControl.SendMoveSizeMessages">
<short>
Sends Move or Size messages using the window message processing loop.
</short>
<descr>
<p>
Sends Move and Size messages through the LCL message paths. This simulates the 
VCL behavior and has no real effect.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.SendMoveSizeMessages">TControl.SendMoveSizeMessages</link>
</seealso>
</element>
<element name="TWinControl.SendMoveSizeMessages.SizeChanged">
<short/>
</element>
<element name="TWinControl.SendMoveSizeMessages.PosChanged">
<short/>
</element>

<element name="TWinControl.SetBorderStyle">
<short>Sets the value for the BorderStyle property.</short>
<descr>
<p>
Notifies the widgetset class instance of the new property value when its 
handle has been allocated.
</p>
</descr>
<seealso>
<link id="TWinControl.BorderStyle"/>
</seealso>
</element>
<element name="TWinControl.SetBorderStyle.NewStyle">
<short>New value for the BorderStyle property.</short>
</element>

<element name="TWinControl.SetColor">
<short>Sets the value for the Color property.</short>
<descr>
<p>
SetColor is an overridden method in TWinControl used to set the value for the 
Color property. It calls the inherited method on entry, and ensures that the 
new property value is applied to the internal TBrush instance used in the 
control. This includes translating the value clDefault to the actual brush 
color used for the platform.
</p>
<p>
If the Handle has been allocated for the control, the widgetset class is 
updated. Otherwise, control flags are updated to include the value 
wcfColorChanged.
</p>
<p>
The NotifyControls method is called to send the CM_PARENTCOLORCHANGED control 
message to the child controls.
</p>
</descr>
<seealso>
<link id="TControl.Color"/>
<link id="TControl.SetColor"/>
</seealso>
</element>
<element name="TWinControl.SetColor.Value">
<short>
New value for the Color property.
</short>
</element>

<element name="TWinControl.SetChildZPosition">
<short>
Updates the position of the child control in the Z plane (i.e. front-to-back).
</short>
<descr>
<p>
<var>SetChildZPosition</var> repositions the child control in <var>AChild</var> 
in the display order for the child Controls in the class instance. No actions 
are performed in the method when:
</p>
<ul>
<li>
The Controls list has not been allocated.
</li>
<li>
AChild has not been assigned (contains <b>Nil</b>).
</li>
<li>
AChild is not stored in the child Controls for the class instance.
</li>
</ul>
<p>
<var>APosition</var> contains the new relative display order on the Z-axis for 
the specified child control. A value in APosition must be in the range allowed 
in Controls (0..Controls.Count-1). Smaller values in APosition move the child 
control towards the front or top of the display order. Larger values move the 
child control towards the bottom or back of the display order.
</p>
<p>
SetChildZPosition calls the Move method in Controls to change the ordinal 
position for the specified control in the list.
</p>
<p>
If AChild is a TWinControl descendant, the SetChildZPosition method in the 
widgetset class is used to notify the child controls which have a valid 
handle. If AChild is a TControl instance, its InvalidateControl method is 
called to redraw the control using its visibility and opacity settings.
</p>
<p>
SetChildZPosition is used to implement the SetControlIndex method.
</p>
</descr>
<seealso>
<link id="TWinControl.Controls"/>
<link id="TWinControl.ControlCount"/>
<link id="TWinControl.Handle"/>
<link id="TWinControl.SetControlIndex"/>
<link id="TControl.InvalidateControl"/>
</seealso>
</element>
<element name="TWinControl.SetChildZPosition.AChild">
<short>Control to locate and move in the method.</short>
</element>
<element name="TWinControl.SetChildZPosition.APosition">
<short>New ordinal position for the control in the Controls property.</short>
</element>

<element name="TWinControl.ShowControl">
<short>Displays the control on its Parent.</short>
<descr>
<p>
<var>ShowControl</var> is a method used to display the control on its Parent. 
When Parent has been assigned, its ShowControl is called. This is repeated 
until a control without an assigned Parent is encountered.
</p>
<p>
ShowControl is called from the Show method in a control instance. It occurs 
before the Visible property is set to<b>True</b>, and forces each of the 
parent controls to become visible before setting the value in the control.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TControl.Show"/>
</seealso>
</element>
<element name="TWinControl.ShowControl.AControl">
<short>A control to display. Ignored in this method.</short>
</element>

<element name="TWinControl.UpdateControlState">
<short>
Updates the visible state for the control, and notifies the widgetset class 
when available.
</short>
<descr>
<p>
Calls AdjustSize when the Handle has been allocated for the control and the 
control is logically visible in the client area for the parent. This causes 
DoAllAutoSize and UpdateShowing to be called. If the control is not visible, 
UpdateShowing is called to hide the control.
</p>
<p>
Called from the SetParentWindow method.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.UpdateShowing">
<short>
Updates the Showing property with the visibility for the control, its 
Parents, and its child controls.
</short>
<descr>
<p>
<var>UpdateShowing</var> is a method used to determine the visibility for the 
Handle in the control. It calls HandleObjectShouldBeVisible to check the 
handle state and visibility for both the control and each of its Parent 
controls. If the control should be showing and Handle has not already been 
allocated, CreateHandle is called.
</p>
<p>
When child controls exist in the Controls property, they are visited to call 
the UpdatingShowing method for each of the TWinControl instances.
</p>
<p>
If an auto-sizing request is not active, a CM_SHOWINGCHANGED message is 
performed to apply the new visibility for the control(s). The Showing 
property is updated prior to exiting from the method.
</p>
</descr>
<seealso>
<link id="TWinControl.Showing"/>
<link id="TWinControl.CreateHandle"/>
<link id="TWinControl.AutoSizeDelayed"/>
<link id="TWinControl.AutoSizePhases"/>
<link id="TControl.HandleObjectShouldBeVisible"/>
</seealso>
</element>

<element name="TWinControl.WndProc">
<short>
Adds special handling for focus and input messages, and notifies the 
DockManager.
</short>
<descr>
<p>
Handles the following messages:
</p>
<dl>
<dt>LM_SETFOCUS</dt>
<dd>Gets the parent form and show this control as focused</dd>
<dt>LM_KILLFOCUS</dt>
<dd>Removes focus from this control</dd>
<dt>LM_NCHITTEST</dt>
<dd>Checks the transparency for the control, etc.</dd>
<dt>Mouse messages</dt>
<dd>Sent to the DockManager (when used).</dd>
<dt>CM_THEMECHANGED</dt>
<dd>Broadcasts the message received for a theme change event.</dd>
</dl>
</descr>
<version>
Modified in LCL version 3.6 to handle CM_THEMECHANGED messages.
</version>
<seealso>
<link id="TControl.WndProc"/>
</seealso>
</element>
<element name="TWinControl.WndProc.Message">
<short>
Message examined and handled in the method.
</short>
</element>

<element name="TWinControl.WSSetText">
<short>
Sets the value for the Text property in the widgetset class.
</short>
<descr>
<p>
Calls the SetText method in the widgetset class instance.
</p>
<p>
WSSetText is called from the Loaded and InitializeWnd methods after the 
control has finished loading using the LCL streaming mechanism or created its 
window handle. It is also called from RealSetText to apply a new value for 
the Caption property to the Text for the control.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.WSSetText.AText">
<short>The text to send.</short>
</element>

<element name="TWinControl.WindowHandle">
<short>
For internal use; allows direct access to the Handle for the control, 
bypassing any getter/setter methods.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.BorderStyle">
<short>
Indicates the border style displayed around the control.
</short>
<descr>
<p>
<var>BorderStyle</var> is a <var>TBorderStyle</var> property which indicates 
the borders drawn for the control. bsSingle indicates that borders are drawn 
for the control. The default value for the property is bsNone, and indicates 
that borders are not drawn for the control.
</p>
<p>
Changing the value for the property causes the widgetset class to be updated 
when the Handle has been allocated for the control.
</p>
<p>
BorderStyle is used in the CreateParams method. It causes the 
WS_EX_CLIENTEDGE extended window style flag to be included in the control 
when the property is set to bsSingle.
</p>
<p>
BorderStyle is used along with BorderWidth in descendent classes which allow 
their borders to be drawn with a raised or lowered appearance.
</p>
</descr>
<seealso>
<link id="TWinControl.BorderWidth"/>
<link id="TBorderStyle"/>
<link id="TFormBorderStyle"/>
</seealso>
</element>

<element name="TWinControl.OnGetSiteInfo">
<short>
Provides information about the DockSite for the control.
</short>
<descr>
<p>
The handler can adjust the <var>InfluenceRect</var>, within which mouse moves 
are recognized by this control. The handler also can deny any drops, 
depending on the dragging operation for the control.
</p>
<p>
<var>OnGetSiteInfo</var> occurs before the <var>OnDockOver</var> event 
handler.
</p>
</descr>
<seealso>
<link id="TWinControl.OnDockOver"/>
</seealso>
</element>

<element name="TWinControl.OnGetDockCaption">
<short>
This handler can provide a special DockCaption, different than the Caption 
default.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.BorderWidth">
<short>
Width of the Border around the control; default is zero.
</short>
<descr>
<p>
<var>BorderWidth</var> is a <var>TBorderWidth</var> property which contains 
the size for a border drawn on the control. The default value for the 
property is 0 (zero). Changing the value for the property causes a 
CM_BORDERCHANGED control message to be sent to the processing loop for the 
control.
</p>
<p>
BorderWidth is significant when BorderStyle is set to bsSingle. Descendent 
classes, which allow their borders to be drawn using a raised or lowered 
appearance, may use the property value when the control is drawn. It 
indicates the amount of space to reserve for the borders in the bounds 
rectangle for the control.
</p>
</descr>
<seealso>
<link id="TWinControl.BorderStyle"/>
</seealso>
</element>

<element name="TWinControl.BoundsLockCount">
<short>
A counter used to track updates to the BoundsRect for the control.
</short>
<descr>
<p>
<var>BoundsLockCount</var> is a read-only <var>Integer</var> property with the 
counter used to track active updates to the BoundsRect for the control. Its 
value is maintained when the BeginUpdateBounds and EndUpdateBounds methods are 
called. Its value is incremented when BeginUpdateBounds is called, and 
decremented when EndUpdateBounds is called. When it has a non-zero value, 
updates to the BoundsRect property are blocked. When it reaches 0 (zero), the 
SetBounds method is called to store the values in Left, Top, Width, and Height 
to the bounds rectangle.
</p>
</descr>
<seealso>
<link id="TWinControl.BeginUpdateBounds"/>
<link id="TWinControl.EndUpdateBounds"/>
<link id="TWinControl.SetBounds"/>
<link id="TControl.BoundsRect"/>
<link id="TControl.Left"/>
<link id="TControl.Top"/>
<link id="TControl.Width"/>
<link id="TControl.Height"/>
</seealso>
</element>

<element name="TWinControl.Brush">
<short>
The Brush used to paint the background for the control.
</short>
<descr>
<p>
<var>Brush</var> is a read-only TBrush property which provides the tool used 
to paint the interior of the control. The value in Brush is allocated and 
configured in the CreateBrush method, called when the value for the property 
is read but has not been assigned.
</p>
<p>
The Color property in Brush is updated when a new value is assigned to the 
Color property in the control.
</p>
<p>
Brush is used in the EraseBackground method and provides the Handle used to 
draw the background rectangle for the control.
</p>
</descr>
<seealso>
<link id="TWinControl.CreateBrush"/>
<link id="TWinControl.EraseBackground"/>
<link id="TControl.Color"/>
<link id="#lcl.graphics.TBrush">TBrush</link>
</seealso>
</element>

<element name="TWinControl.CachedClientHeight">
<short>
The intended ClientHeight, as sent to the widgetset class.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.CachedClientWidth">
<short>
The intended ClientWidth, as sent to the widgetset class.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.ChildSizing">
<short>
Provides a grid (table) layout for the children of this control.
</short>
<descr>
<p>
<var>ChildSizing</var> provides access to the <var>TControlChildSizing</var>
properties and methods of the control.
Those manage how the child-controls are resized and placed into a grid layout.
</p>
<p>
ChildSizing is an alternative to using Anchors and Align properties to 
position and resize child controls.
</p>
<p>
Use the <link id="TControlChildrenLayout">Layout</link> 
property to enable the grid and specify the order and direction 
in which child controls are aligned. This affects how 
TControlChildSizing.ControlsPerLine determines the size of grid setting 
either the amount of columns or rows.
The default is cclNone and disables the grid layout.
</p>
<p>
Choose a <link id="TChildControlResizeStyle">resize algorithm</link> for 
shrinking or growing children's width and height. This does nothing 
when cclNone is chosen.
</p>
<p>
Spacing between and around the cells of the grid can be set as part of the
TControlChildSizing. It can also be set by using the BorderSpacing of 
individual child-controls. The TControlChildSizing properties for spacing
are also used when the layout is set to cclNone. They affect child-controls
that are anchored or aligned in a similar manner as setting the child's 
BorderSpacing.
</p>
<p>
See <link id="TControlChildSizing">TControlChildSizing</link> for more 
detailed information about the properties and methods in the class instance.
</p>
<p>
Additional information about child sizing and layout can be found on the 
Lazarus Wiki at:
</p>
<p>
<url href="https://wiki.lazarus.freepascal.org/Autosize_/_Layout">
Autosize / Layout
(https://wiki.lazarus.freepascal.org/Autosize_/_Layout)
</url>
</p>
<p>
<url href="https://wiki.lazarus.freepascal.org/LCL_AutoSizing">
LCL AutoSizing
(https://wiki.lazarus.freepascal.org/LCL_AutoSizing)
</url>
</p>
</descr>
<version>
Behavior modified in LCL version 3.4 to use the adjusted client rectangle when 
controls are aligned.
</version>
<version>
Implementation refactored in LCL version 4.0. This may result in behaviour 
that differs from previous LCL versions. Children with Constraints.MaxWidth / 
MaxHeight now limit the size of their column/row. In version 4.2 that was 
fixed to only apply for children with Constraints.MaxWidth/MaxHeight and 
BorderSpacing.CellAlignHorizontal/CellAlignVertical = ccaFill. Values other 
than ccaFill can be used to get the layout behaviour of version 3.
</version>
<seealso>
<link id="TWinControl.ControlCount"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.AlignControls"/>
<link id="TWinControl.AdjustClientRect"/>
<link id="TWinControl.DoChildSizingChange"/>
<link id="TWinControl.InvalidatePreferredChildSizes"/>
<link id="TControl.Align"/>
<link id="TControl.Anchors"/>
<link id="TControlChildSizing"/>
</seealso>
</element>

<element name="TWinControl.ControlCount">
<short>
The number of child controls in the Controls property.
</short>
<descr>
<p>
<var>ControlCount</var> is a read-only Integer property which contains the 
number of child controls stored in the indexed Controls property.
</p>
<p>
The value is updated when control instances are created using the current 
class instance as the Parent for the control. The value is used in the 
AlignControls method when the Controls are positioned, aligned, and resized. 
It is also used to determine whether additional actions are needed in methods 
like DoChildSizingChange, InvalidatePreferredChildSizes, DoAutoSize, and 
DoAllAutoSize.
</p>
</descr>
<seealso>
<link id="TWinControl.Controls"/>
<link id="TWinControl.AlignControls"/>
</seealso>
</element>

<element name="TWinControl.Controls">
<short>
Provides indexed access to the child controls for the class instance.
</short>
<descr>
<p>
<var>Controls</var> is a read-only indexed <var>TControl</var> property which 
provides access to child controls by their ordinal position in the list.
</p>
<p>
The Index argument contains the ordinal position for the requested child 
control, and must be in the range 0..ControlCount-1. The index also indicates 
the display or tab order for the child controls. The physical order for the 
controls in the list my be changed when the FixupTabList method is called 
during LCL component streaming.
</p>
</descr>
<seealso>
<link id="TWinControl.ControlCount"/>
</seealso>
</element>
<element name="TWinControl.Controls.Index">
<short>
Ordinal position for the child control requested in the property value.
</short>
</element>

<element name="TWinControl.DefWndProc">
<short>
The default WndProc on Windows widgetset and platforms.
</short>
</element>

<element name="TWinControl.DockClientCount">
<short>The number of clients docked into this control.</short>
<descr>
<p>
The docked controls can be accessed in<link 
id="TWinControl.DockClients">DockClients[]</link>.
</p>
<p>
<var>DockClientCount</var> is equivalent to DockClients.Count, but handles 
the special case when DockClients is <b>Nil</b>.
</p>
</descr>
<seealso>
<link id="TWinControl.DockClients"/>
</seealso>
</element>

<element name="TWinControl.DockClients">
<short>The indexed list of controls docked into this control.</short>
<descr/>
<seealso>
<link id="TWinControl.DockClientCount"/>
</seealso>
</element>
<element name="TWinControl.DockClients.Index">
<short>Index of the requested docked client.</short>
</element>

<element name="TWinControl.DockManager">
<short>The docking layout manager for this control.</short>
<descr>
<p>
A <var>DockSite</var> can be managed (using a <var>DockManager</var>), or 
unmanaged (positioning docked controls in the event handlers). The 
<var>DockManager</var> determines the placement for docked controls by 
setting <var>DropOnControl</var> and <var>DropAlign</var> before the drop, 
and by resizing and positioning the control when it's dropped.
</p>
<p>
A <var>DockManager</var> is used only when <var>UseDockManager</var> is set 
to <b>True</b>. Setting <var>UseDockManager</var> to <b>True</b> creates the 
<var>DockManager</var> using the <var>DefaultDockManagerClass</var> for this 
DockSite, if not previously assigned.
</p>
<p>
An unmanaged DockSite, without a DockManager, can handle the placement of 
dropped controls in the <var>OnDockOver</var> and <var>OnDockDrop</var> event 
handlers.
</p>
</descr>
<seealso>
<link id="TWinControl.UseDockManager"/>
<link id="TWinControl.DockSite"/>
<link id="TWinControl.OnDockDrop"/>
<link id="TWinControl.OnDockOver"/>
<link id="TDockManager"/>
</seealso>
</element>

<element name="TWinControl.DockSite">
<short>
Allows controls to be drag-and-dock-ed into this control.
</short>
<descr>
<p>
A DockSite reacts on controls dragged over this control, signals acceptance 
and where a dragged control would be dropped.
</p>
<remark>
A DockSite should initially be empty, not containing any child controls.
</remark>
</descr>
<seealso>
<link id="TWinControl.DockManager"/>
<link id="TWinControl.UseDockManager"/>
</seealso>
</element>

<element name="TWinControl.DoubleBuffered">
<short>
When enabled, it reduces flicker when the control is painted.
</short>
<descr>
<p>
<var>Paint</var> requests are typically buffered in the message queue. When a 
paint message arrives, all elements of the control are drawn onto the screen, 
according to their type, style, state and content.
</p>
<p>
This can cause flicker, when stacked controls wipe out preceding paintings, 
e.g. when unchanged text is erased from the screen before it is painted 
again, when it takes some time to retrieve the text of list entries, or 
wrapping long text at the current control boundaries. Owner-drawing also can 
cause noticeable flicker.
</p>
<p>
To reduce such flicker, <var>DoubleBuffered</var> controls use a bitmap 
buffer into which all painting is redirected. When the bitmap has been 
updated, a paint request is queued for the control. When that paint request 
is received again, the prepared bitmap is output in one fast BitBlt transfer, 
eliminating any flicker.
</p>
<p>
All this happens automatically when <var>DoubleBuffered</var> is set to 
<b>True</b>; no additional changes are required in application or custom 
control code.
</p>
</descr>
</element>

<element name="TWinControl.Handle">
<short>
A reference handle to the widgetset class instance associated with this 
control.
</short>
<descr>
<p>
<var>Handle</var> is a <var>HWND</var> property which represents the handle 
to the widgetset class instance for the control. It provides a bi-directional 
communication mechanism between an LCL component and the native control on a 
given platform or widgetset. Handle has a non-zero value when it has been 
allocated for the widget.
</p>
<p>
Read access to the property value calls the HandleNeeded method to create the 
handle if it does not already exist in the control (and its Parent controls). 
When the property value is changed, the InvalidatePreferredSize method is 
called to update control flags and clear the cached size for the control.
</p>
<p>
Use HandleAllocated to check Handle for a non-zero value. Use HandleNeeded 
when the LCL component needs to ensure that the control and Parent controls 
have an assigned Handle. Or call CreateHandle.
</p>
<p>
Use WindowHandle to access the unique identifier for a device context used in 
drawing operations for the widgetset class.
</p>
</descr>
<seealso>
<link id="TWinControl.HandleAllocated"/>
<link id="TWinControl.HandleNeeded"/>
<link id="TWinControl.CreateHandle"/>
<link id="TWinControl.CreateWnd"/>
<link id="TWinControl.WindowHandle"/>
<link id="TWinControl.ParentHandlesAllocated"/>
</seealso>
</element>

<element name="TWinControl.IsFlipped">
<short>Used in Carbon and Cocoa widgetsets</short>
<descr>
<p>
IsFlipped is a read-only Boolean property. It is used in the Carbon and Cocoa 
widgetsets for the macOS platforms.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.IsResizing">
<short>
Indicates if the control is changing its size after the BeginUpdateBounds 
method has been called.
</short>
<descr>
<p>
<var>IsResizing</var> is a read-only <var>Boolean</var> property which 
indicates if SetBounds has been called to resize the control, but the action 
has not been completed. An internal bounds lock counter is used to track the 
progress of a resize operation. It is incremented when 
<var>BeginUpdateBounds</var> is called and decremented in the 
<var>EndUpdateBounds</var> method. The property value is <b>True</b> when the 
internal bounds lock counter has a non-zero value.
</p>
<p>
IsResizing is used when a designer surface in the Lazarus IDE tries to select 
one of its components. It prevents the selection if the SetBounds operation 
is still in progress (IsResizing is <b>True</b>).
</p>
</descr>
<seealso>
<link id="TWinControl.BeginUpdateBounds"/>
<link id="TWinControl.EndUpdateBounds"/>
<link id="TWinControl.SetBounds"/>
<link id="TControl.SetBounds"/>
</seealso>
</element>

<element name="TWinControl.TabOrder">
<short>
Indicates the navigation order for the control when the user presses the Tab 
or Shift+Tab key.
</short>
<descr>
<p>
<var>TabOrder</var> is a <var>TTabOrder</var> with a numeric value which 
indicates the navigation order for the control when the user presses the Tab 
or Shift+Tab key. The default value for the property is -1 and indicates that 
an explicit value has not been assigned.
</p>
<p>
Each TWinControl has an internal list used to maintain the tab order for its 
child Controls. When TabOrder is -1 for a given child control, it added to 
the end of the tab order list. A non-zero value forces the control to be 
stored at that ordinal position in the tab order list. Setting a new value 
for the property causes the private UpdateTabOrder method to be called to 
maintain the sequence for the child controls.
</p>
<p>
Use TabStop to indicate if the control can be focused using tab order 
navigation request.
</p>
</descr>
<seealso>
<link id="TWinControl.TabStop"/>
</seealso>
</element>

<element name="TWinControl.TabStop">
<short>
Allows the user to navigate to / from the control by pressing the Tab or 
Shift+Tab keys.
</short>
<descr>
<p>
<var>TabStop</var> is a <var>TabStop</var> property which indicates if the 
control can be focused when using the <b>Tab</b> or <b>Shift+Tab</b> keys to 
navigate between controls on a form. The default value for the property is 
<b>False</b>. At design-time, the Lazarus IDE sets the value to <b>True</b> 
in newly created control instances.
</p>
<p>
When set to <b>True</b>, the windows style flags are updated to include the 
value WS_TABSTOP in the CreateParams method.
</p>
<p>
Changing the value for the property causes the internal tab order list to be 
updated, and a CM_TABSTOPCHANGED control message is performed for the control.
</p>
<p>
TabStop is used in methods like FindNextControl, and may be updated in 
methods like Insert.
</p>
</descr>
<seealso>
<link id="TWinControl.TabOrder"/>
<link id="TWinControl.FindNextControl"/>
<link id="TWinControl.CanTab"/>
<link id="TWinControl.CanFocus"/>
<link id="TControl.IsControlVisible"/>
<link id="TControl.Visible"/>
<link id="TControl.Enabled"/>
</seealso>
</element>

<element name="TWinControl.OnAlignInsertBefore">
<short>
Event handler signalled to determine the order and placement for 
custom-aligned child controls.
</short>
<descr/>
<seealso>
<link id="TWinControl.AlignControls"/>
<link id="TWinControl.CustomAlignInsertBefore"/>
<link id="TWinControl.DoAllAutoSize"/>
<link id="TAlignInsertBeforeEvent"/>
</seealso>
</element>

<element name="TWinControl.OnAlignPosition">
<short>
Event handler signalled to determines the position and size for custom-aligned 
child controls.
</short>
<descr/>
<seealso>
<link id="TWinControl.CustomAlignPosition"/>
<link id="TWinControl.AlignControls"/>
<link id="TControl.Align"/>
<link id="TControl.Anchors"/>
<link id="TAlign"/>
<link id="TAlignPositionEvent"/>
</seealso>
</element>

<element name="TWinControl.OnDockDrop">
<short>
Event handler signalled for the drop of a control to be docked.
</short>
</element>

<element name="TWinControl.OnDockOver">
<short>
Event handler signalled when a control is moved over a docksite; determines 
whether the drop event is accepted or rejected.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.OnEnter">
<short>
Event handler signalled when the control receives focus.
</short>
<descr>
<p>
<var>OnEnter</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled when the control receives focus. It is signaled from the 
DoEnter method, and occurs when the CM_ENTER control message is received and 
handled for the control.
</p>
<p>
The <var>Sender</var> argument contains the object for the event notification, 
and must be cast to TControl, TWinControl, or other descendent class to access 
properties or methods specific to the implementation.
</p>
<p>
Use OnExit to perform actions needed when the control loses focus.
</p>
</descr>
<seealso>
<link id="TWinControl.DoEnter"/>
<link id="TWinControl.CMEnter"/>
<link id="TWinControl.OnExit"/>
</seealso>
</element>

<element name="TWinControl.OnExit">
<short>
Event handler signalled when the control loses focus.
</short>
<descr>
<p>
<var>OnExit</var> is a <var>TNotifyEvent</var> property with the event handler 
signalled when the control loses focus. It is signalled (when assigned) from 
the DoExit method, and occurs when a CM_EXIT control message is received and 
handled for the control.
</p>
<p>
The <var>Sender</var> argument contains the object instance for the event 
notification. It must be cast to TControl, TWinControl, or a other descendent 
to access properties or methods specific to the implementation.
</p>
<p>
OnExit occurs after the OnEditingDone event handler which is signalled when 
the content for the control has been modified. Descendent classes generally 
perform any actions needed to maintain their internal state before OnExit is 
signalled. The notable exception is TCustomMaskEdit which can be configured to 
perform validation <b>after</b> the event.
</p>
</descr>
<seealso>
<link id="TWinControl.DoExit"/>
<link id="TWinControl.CMExit"/>
<link id="TControl.EditingDone"/>
<link id="TControl.OnEditingDone"/>
</seealso>
</element>

<element name="TWinControl.OnKeyDown">
<short>
Event handler signalled for key down keyboard events.
</short>
<descr>
<p>
<var> OnKeyDown</var> is a <var>TKeyEvent</var> property with the event 
handler signalled to handle a key down event for the control. The event 
handler receives keys including control and other non-visual keys. It is 
signalled (when assigned) from the KeyDown method.
</p>
<p>
The <var> Sender</var> argument contains the control for the key event. It 
must be cast to TControl or TwinControl type to access properties or methods 
specific to the descendent classes.
</p>
<p>
The <var>Key</var> argument contains the virtual keyboard constant for the 
key event (like VK_F1 or VK_NUMPAD5). It is a variable argument and can be 
modified in the event handler. Set Key to VK_UNKNOWN if the handler routine 
has performed the actions needed to handle the key event. Otherwise, Key is 
passed to other OnKeyDown handlers at the form or application level.
</p>
<p>
<var>Shift</var> is a set type which contains the modifiers for the key down 
event like: Ctrl, Shift, Alt, or Meta.
</p>
<remark>
When a key is held down, the OnKeyDown event is re-triggered. The first 
re-triggered event occurs after approximately 500ms, and subsequent events 
cycle between 30ms and 50ms until the key is released.
</remark>
<p>
Use OnKeyUp to perform actions needed when the key is released.
</p>
<p>
Use OnKeyPress or OnUTF8KeyPress to implement a handler routine for printable 
character values.
</p>
<remark>
Some key combinations are used as global shortcut keys for a given widgetset 
(QT, GTK, Cocoa), window manager (KDE, Gnome, Windows), or display protocol 
(X11, Wayland, WinAPI). These global shortcuts are platform-specific and 
generally perform system navigation or window management. They may be handled 
by the desktop / window manager and not forwarded to an application, form, or
control. Some common examples include: Ctrl+F4, Alt+F4, Ctrl+Command+Q, and 
others. For more details, please refer to the developer documentation for the
platform (widgetset) or desktop window manager.
</remark>
<ul>
<li>
https://docs.kde.org/stable5/en/khelpcenter/fundamentals/kbd.html
</li>
<li>
https://help.gnome.org/users/gnome-help/stable/shell-keyboard-shortcuts.html.en</li>
<li>
https://developer.gnome.org/hig/reference/keyboard.html
</li>
<li>
https://support.microsoft.com/en-us/windows/keyboard-shortcuts-in-windows-dcc61a57-8ff0-cffe-9796-cb9706c75eec
</li>
<li>
https://support.apple.com/en-us/102650
</li>
<li>
https://en.wikipedia.org/wiki/Table_of_keyboard_shortcuts#Comparison_of_keyboard_shortcuts
</li>
</ul>
</descr>
<seealso>
<link id="TWinControl.KeyDown"/>
<link id="TWinControl.OnKeyUp"/>
<link id="TWinControl.OnKeyPress"/>
<link id="TKeyEvent"/>
</seealso>
</element>

<element name="TWinControl.OnKeyPress">
<short>
Event handler signalled for character data entered by the user.
</short>
<descr>
<p>
This handler only receives characters, not control or other special key 
codes. Control keys should be handled by an <var>OnKeyDown</var> handler 
instead. The handler can also be used to convert the character into a 
different one.
</p>
<remark>
We recommend using <var>OnUTF8KeyPress</var> to prevent data loss. Characters 
are converted from UTF-8 to the system encoding in <var>OnKeyPressEvent</var>, 
with possible loss of characters outside the <b>ANSI</b> codepage.
</remark>
</descr>
<seealso>
<link id="TWinControl.OnKeyDown"/>
<link id="TWinControl.OnUTF8KeyPress"/>
</seealso>
</element>

<element name="TWinControl.OnKeyUp">
<short>
Event handler signalled when a key up event has occurred for the control.
</short>
<descr>
<p>
<var>OnKeyUp</var> is a <var>TKeyEvent</var> property with the event handler 
signalled when a key up event has occurred in the control. OnKeyUp is 
signalled (when assigned) from the KeyUp method. It occurs when the CN_KEYUP 
or CN_SYSKEYUP notifications are handled for the control.
</p>
<p>
The <var> Sender</var> argument contains the control for the key event. It 
must be cast to TControl or TwinControl type to access properties or methods 
specific to the descendent classes.
</p>
<p>
The <var>Key</var> argument contains the virtual keyboard constant for the 
key event (like VK_F1 or VK_NUMPAD5).
</p>
<p>
<var>Shift</var> is a set type which contains the modifiers for the key down 
event like: Ctrl, Shift, Alt, or Meta.
</p>
<p>
Unlike OnKeyDown, this event occurs only once for auto-repeated keys. For more 
information, see <link id="TWinControl.OnKeyDown"/>.
</p>
<p>
Use OnKeyDown to perform actions needed when a key down event for a 
non-printable key is received for the control.
</p>
<p>
Use OnKeyPress to handle a key press for printable characters entered into the 
control.
</p>
</descr>
<seealso>
<link id="TWinControl.KeyUp"/>
<link id="TWinControl.CNSysKeyUp"/>
<link id="TWinControl.CNKeyUp"/>
<link id="TWinControl.OnKeyDown"/>
<link id="TWinControl.OnKeyPress"/>
<link id="TKeyEvent"/>
</seealso>
</element>

<element name="TWinControl.OnUnDock">
<short>
Event handler signalled before a control is undocked from its DockSite.
</short>
<descr>
<p>
<var>OnUnDock</var> is a <var>TUnDockEvent</var> property with the event 
handler signalled before a control is undocked from its DockSite. The event 
handler arguments identify the control with the DockSite, the client control 
which will become undocked, the control that has the new dock site, and a 
Boolean which indicates if the operation is allowed.
</p>
<p>
The event handler can be used to disallow undocking by setting the Boolean 
argument to <b>False</b> in the handler routine.
</p>
<p>
OnUnDock is signalled from the DoUnDock method.
</p>
</descr>
<seealso>
<link id="TWinControl.DoUnDock"/>
</seealso>
</element>

<element name="TWinControl.OnUTF8KeyPress">
<short>
Handler for a character entered by the user.
</short>
<descr>
<p>
This handler receives characters codes only, not control or other special key 
codes. Control keys should be handled by an <var>OnKeyDown</var> handler 
instead. The event handler can also convert the character code into a 
different value.
</p>
<p>
While <link id="TWinControl.OnKeyPress">OnKeyPress</link> receives only 
<b>ANSI</b> characters (with possible loss of characters outside the 
<b>ANSI</b> codepage), the <var>OnUTF8KeyPress</var> handler receives the 
<b>UTF-8</b>-encoded character code.
</p>
</descr>
<seealso>
<link id="TWinControl.OnKeyPress"/>
<link id="TWinControl.OnKeyDown"/>
</seealso>
</element>

<element name="TWinControl.ParentDoubleBuffered">
<short>Value for the DoubleBuffered property in a Parent control.</short>
<descr>
<p>
<var>ParentDoubleBuffered</var> is a <var>Boolean</var> property which 
indicates the value for the DoubleBuffered property in the Parent control. 
The default value for the property is <b>True</b>. Changing the value for the 
property causes a CM_PARENTDOUBLEBUFFEREDCHANGED message to be performed (for 
the control) when Parent has been assigned.
</p>
<p>
To disable double buffering for a single control, make sure both 
DoubleBuffered and ParentDoubleBuffered are set to <b>False</b>.
</p>
<p>
Double buffering is a technique used to reduce screen flicker when controls 
are redrawn. It uses an additional off-screen buffer to perform drawing 
operations, and transfers the content to the on-screen buffer when completed.
</p>
<p>
DoubleBuffered and ParentDoubleBuffered are implemented for the Win32 
platform/widgetset. It is implemented for TWinControl (and descendants) and 
TApplication. In TApplication, the setting is applied to all forms and 
controls when assigned before the forms and controls are created.
</p>
</descr>
<seealso>
<link id="TWinControl.DoubleBuffered"/>
<link id="TControl.Parent"/>
</seealso>
</element>

<element name="TWinControl.ParentWindow">
<short>The window Handle for the Parent widget.</short>
<descr>
<p>
<var> ParentWindow</var> is a <var> HWND</var> property with the window Handle 
for the Parent widget. A new value assigned to the property is ignored when 
Parent has already been assigned.
</p>
<p>
The property value is assigned when the CreateParented constructor or the 
CreateParentedControl class function is used to create a new TWinControl 
instance. Setting the property to <b>0</b> (zero) causes the handle to be 
destroyed. <b>0</b> is the unassigned handle value.
</p>
<p>
ParentWindow is used in the CreateWnd method to form an association 
between the Handle in the widgetset class instance and the window handle 
for a control.
</p>
</descr>
<seealso>
<link id="TWinControl.GetParentHandle"/>
<link id="TWinControl.GetTopParentHandle"/>
<link id="TWinControl.CreateParented"/>
<link id="TWinControl.CreateParentedControl"/>
<link id="TWinControl.CreateWnd"/>
<link id="TControl.Parent"/>
</seealso>
</element>

<element name="TWinControl.Showing">
<short>
Cached visibility for the widget. Not necessarily in sync with the widget.
</short>
<descr>
<p>
<var>Showing</var> is a read-only <var>Boolean</var> property with the 
visibility for the Handle in a control or its Parent. The value for the 
property is assigned in the UpdateShowing method when the control hierarchy 
is checked for valid and Visible window handles for the control or its 
Parents. Showing may be updated when the DoAllAutoSize or UpdateControlState 
methods are called.
</p>
</descr>
<seealso>
<link id="TWinControl.UpdateShowing"/>
<link id="TWinControl.Handle"/>
<link id="TWinControl.DoAllAutoSize"/>
<link id="TWinControl.UpdateControlState"/>
<link id="TWinControl.CMShowingChanged"/>
<link id="TControl.Visible"/>
</seealso>
</element>

<element name="TWinControl.UseDockManager">
<short>
Determines whether a DockManager is used for this DockSite.
</short>
<descr>
<p>
When <var>UseDockManager</var> is set to <b>True</b>, and DockSite is also 
set to <b>True</b>, a <var>DockManager</var> is created automatically. When 
set to <b>False</b>, an existing <var>DockManager</var> is ignored. </p>
<p>
If you want to use a special DockManager, install it before setting 
<var>UseDockManager</var> to <b>True</b>.
</p>
</descr>
<seealso>
<link id="TWinControl.DockSite"/>
<link id="TWinControl.DockManager"/>
<link id="TWinControl.CreateDockManager"/>
</seealso>
</element>

<element name="TWinControl.DesignerDeleting">
<short>
Indicates whether the wcfDesignerDeleting flag is included in the flags for 
the control.
</short>
<descr>
<p>
<var>DesignerDeleting</var> is a <var>Boolean</var> property which indicates 
if the wcfDesignerDeleting is includes in the control flags for the 
TWinControl instance. When set to <b>True</b>, wcfDesignerDeleting is 
included in the control flag values. When set to <b>False</b>, it is removed. 
Used in TPairSplitter only.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.IsSpecialSubControl">
<short>
Indicates if the control has the wcfSpecialSubControl control flag.
</short>
<descr>
<p>
<var>IsSpecialSubControl</var> is a read-only <var>Boolean</var> property. 
Its value is <b>True</b> when wcfSpecialSubControl has been included in the 
WinControlFlags for the control. Used in <var>TCustomPairSplitter</var> only.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.VisibleDockClientCount">
<short>The number of visible docked controls.</short>
<seealso>
<link id="TWinControl.DockClientCount"/>
<link id="TWinControl.DockClients"/>
</seealso>
</element>

<element name="TWinControl.AutoSizePhases">
<short>Translates control state flags into AutoSizePhases.</short>
<descr>
<p>
The return value is a <var>TControlAutoSizePhases</var> set type. It is 
populated with values from the <var>TControlAutoSizePhase</var> enumeration 
based on window control flags and other internal members in the class 
instance. When Parent has been assigned, the values are derived by calling 
AutoSizePhases in Parent.
</p>
<p>
AutoSizePhases is called from methods like DoAutoSize and UpdateShowing. It 
is also called from window message handlers like WMMove, WMSize, and 
WMWindowPosChanged.
</p>
</descr>
<seealso>
<link id="TWinControl.DoAutoSize"/>
<link id="TWinControl.UpdateShowing"/>
<link id="TWinControl.WMMove"/>
<link id="TWinControl.WMSize"/>
<link id="TWinControl.WMWindowPosChanged"/>
<link id="TControl.Parent"/>
<link id="TControlAutoSizePhases"/>
<link id="TControlAutoSizePhase"/>
</seealso>
</element>
<element name="TWinControl.AutoSizePhases.Result">
<short>Set withe auto-size phase values enabled for the control.</short>
</element>

<element name="TWinControl.AutoSizeDelayed">
<short>
Returns <b>True</b> if auto-sizing has been delayed until some other process 
is completed.
</short>
<descr>
<p>
<var>AutoSizeDelayed</var> is an overridden Boolean function in TWinControl. 
It returns <b>True</b> when auto-sizing cannot or should not be performed at 
the current time, or when the value in Showing cannot be changed.
</p>
<p>
In TWinControl, it checks the ControlState flags for the value 
csDestroyingHandle when determining the return value for the method. 
AutoSizeDelayed calls the inherited method, and sets the return value to 
<b>True</b> if either condition is <b>True</b>.
</p>
<p>
The value from AutoSizeDelayed is used in methods like DoAllAutoSize and 
UpdateShowing.
</p>
</descr>
<seealso>
<link id="TWinControl.Showing"/>
<link id="TWinControl.UpdateShowing"/>
<link id="TWinControl.DoAllAutoSize"/>
<link id="TControl.ControlState"/>
<link id="TControl.AutoSizeDelayed"/>
</seealso>
</element>
<element name="TWinControl.AutoSizeDelayed.Result">
<short>
<b>True</b> if auto-sizing cannot be performed at the current time.
</short>
</element>

<element name="TWinControl.AutoSizeDelayedReport" link="#lcl.controls.TControl.AutoSizeDelayedReport"/>
<element name="TWinControl.AutoSizeDelayedReport.Result" link="#lcl.controls.TControl.AutoSizeDelayedReport.Result"/>

<element name="TWinControl.AutoSizeDelayedHandle">
<short>
Returns <b>True</b> if AutoSize should be skipped / delayed because of its 
handle.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.BeginUpdateBounds">
<short>
Starts an update to the Bounds property; disables SetBounds by incrementing 
BoundsLockCount.
</short>
<descr/>
<seealso>
<link id="TWinControl.EndUpdateBounds"/>
</seealso>
</element>

<element name="TWinControl.EndUpdateBounds">
<short>
Ends an update to the Bounds property; decrements BoundsLockCount and 
eventually calls SetBounds.
</short>
<descr/>
<seealso>
<link id="TWinControl.BeginUpdateBounds"/>
</seealso>
</element>

<element name="TWinControl.LockRealizeBounds">
<short>
Disables sending bounds to the widget, by incrementing the internal 
FRealizeBoundsLockCount.
</short>
<descr/>
<seealso>
<link id="TWinControl.UnlockRealizeBounds"/>
</seealso>
</element>

<element name="TWinControl.UnlockRealizeBounds">
<short>
Enables sending bounds to the widget again, eventually updates the widget.
</short>
<descr/>
<seealso>
<link id="TWinControl.LockRealizeBounds"/>
</seealso>
</element>

<element name="TWinControl.ControlAtPos">
<short>Get the child control at the given client position.</short>
<descr>
<p>WinControls are found before Controls (if overlapping).</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.ControlAtPos.Result">
<short>The found control, <b>Nil</b> if none found.</short>
</element>
<element name="TWinControl.ControlAtPos.Pos">
<short>The client coordinates.</short>
</element>
<element name="TWinControl.ControlAtPos.AllowDisabled">
<short>Allow finding disabled controls.</short>
</element>
<element name="TWinControl.ControlAtPos.AllowWinControls">
<short>Allow finding TWinControls, in addition to TControls.</short>
</element>
<element name="TWinControl.ControlAtPos.OnlyClientAreas">
<short>Only search in client areas.</short>
</element>
<element name="TWinControl.ControlAtPos.Flags">
<short>Encoded Allow... conditions.</short>
</element>

<element name="TWinControl.ContainsControl">
<short>
Returns <b>True</b> if the control is a parent for the specified control.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.ContainsControl.Result">
<short><b>True</b> when we are a parent of Control.</short>
</element>
<element name="TWinControl.ContainsControl.Control">
<short>The control examined as a child control.</short>
</element>

<element name="TWinControl.DoAdjustClientRectChange">
<short>
Asks the widget if ClientRect has changed since the last AlignControl 
execution; calls AdjustSize on change.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.DoAdjustClientRectChange.InvalidateRect">
<short/>
</element>

<element name="TWinControl.InvalidateClientRectCache">
<short>
The ClientRect is cached; call this procedure to invalidate the cache, so 
that the next ClientRect value is fetched from the widgetset class.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.InvalidateClientRectCache.WithChildControls">
<short>Also invalidate all child controls, if <b>True</b>.</short>
</element>

<element name="TWinControl.ClientRectNeedsInterfaceUpdate">
<short>
The ClientRect is cached - check if the cache is valid.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.ClientRectNeedsInterfaceUpdate.Result">
<short><b>True</b> if update needed.</short>
</element>

<element name="TWinControl.SetBounds">
<short>Sets the control bounds and adjusts child and docked controls.</short>
<descr>
<p>
<var>SetBounds</var> is an overridden method in TWinControl. used to set the 
bounds for the control to the values in the ALeft, ATop, AWidth, and AHeight 
arguments.
</p>
<p>
No actions are performed in the method when the internal BoundsLockCount 
member has a non-zero value. In other words, when BeginUpdateBounds has been 
called and EndUpdateBounds has not been called.
</p>
<p>
At design-time, SetBounds checks to ensure that negative is not present in 
the Width or Height properties when the user has changed the bounds for the 
control.
</p>
<p>
SetBounds calls DisableAutoSizing to reduce the overhead for 
recomputing/moving/resizing when the bounds are changed. The inherited method 
is called to apply the new values in ALeft, ATop, AWidth, and AHeight. 
EnableAutoSizing is called to re-enable auto-sizing when the operation has 
been completed.
</p>
<p>
SetBounds is called when any one of these Left, Top, Width or Height 
properties, or the BoundsRect property has been changed.
</p>
<p>
Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid 
and will be changed by the LCL before applied.
</p>
</descr>
<seealso>
<link id="TWinControl.BeginUpdateBounds"/>
<link id="TWinControl.EndUpdateBounds"/>
<link id="TControl.SetBounds"/>
<link id="TControl.ChangeBounds"/>
<link id="TControl.DisableAutoSizing"/>
<link id="TControl.EnableAutoSizing"/>
</seealso>
</element>
<element name="TWinControl.SetBounds.aLeft">
<short>The X coordinate for the left side of the control.</short>
</element>
<element name="TWinControl.SetBounds.aTop">
<short>The Y coordinate for the left side of the control.</short>
</element>
<element name="TWinControl.SetBounds.aWidth">
<short>The width for the control.</short>
</element>
<element name="TWinControl.SetBounds.aHeight">
<short>The height for the control.</short>
</element>

<element name="TWinControl.GetChildrenRect">
<short>
Returns the Client rectangle relative to the controls left, top.
</short>
<descr>
<p>
If Scrolled is <b>True</b>, the rectangle is moved by the current scrolling 
values
(for an example see TScrollingWincontrol).
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.GetChildrenRect">TControl.GetChildrenRect</link>
</seealso>
</element>
<element name="TWinControl.GetChildrenRect.Result">
<short/>
</element>
<element name="TWinControl.GetChildrenRect.Scrolled">
<short/>
</element>

<element name="TWinControl.DisableAlign">
<short>Disables auto-sizing when aligning the control and its parent.</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.EnableAlign">
<short>
Re-enables auto-sizing after aligning the control and its parent.
</short>
<descr/>
<seealso/>
</element>

<element name="TWinControl.ReAlign">
<short>
Adjusts the size and placement for the control and all of its children.
</short>
<descr>
<p>
Calls the inherited AdjustSize method.
</p>
</descr>
<seealso>
<link id="TControl.AdjustSize"/>
</seealso>
</element>

<element name="TWinControl.ScrollBy_WS">
<short>Scrolls the control using the handle for the widgetset class.</short>
<descr/>
<errors>
Raises an Exception if the handle has not been allocated for the widgetset 
class instance. Raised with the message 'TWinControl.ScrollBy_WS: Handle not 
allocated'.
</errors>
<seealso>
<link id="TWinControl.HandleAllocated"/>
</seealso>
</element>
<element name="TWinControl.ScrollBy_WS.DeltaX">
<short>
Number of pixels scrolled in the horizontal direction.
</short>
</element>
<element name="TWinControl.ScrollBy_WS.DeltaY">
<short>
Number of pixels scrolled in the vertical direction.
</short>
</element>

<element name="TWinControl.ScrollBy">
<short>
Scrolls child controls by the specified number of pixels.
</short>
<descr>
<p>
<var>ScrollBy</var> temporarily disables auto-sizing while the child Controls 
are being moved, and re-enables auto-sizing prior to exiting form the method. 
The Left and Top bounds for each of the child Controls are updated by the 
amounts specified in DeltaX and DeltaY. The Height and Width values are not 
modified.
</p>
</descr>
<seealso>
<link id="TWinControl.Controls"/>
<link id="TWinControl.ControlCount"/>
<link id="TControl.SetBounds"/>
</seealso>
</element>
<element name="TWinControl.ScrollBy.DeltaX">
<short>
Number of pixels scrolled in the horizontal direction.
</short>
</element>
<element name="TWinControl.ScrollBy.DeltaY">
<short>
Number of pixels scrolled in the vertical direction.
</short>
</element>

<element name="TWinControl.WriteLayoutDebugReport" link="#lcl.controls.TControl.WriteLayoutDebugReport"/>
<element name="TWinControl.WriteLayoutDebugReport.Prefix"/>

<element name="TWinControl.AutoAdjustLayout">
<short>
Automatically adjusts the size and layout for the control (and all of its 
children).
</short>
<descr>
<p>
<var>AutoAdjustLayout</var> is an overridden procedure used to automatically 
adjust the size and layout for the control. All children in the 
<var>Controls</var> property also call their AutoAdjustLayout method, and the 
inherited method is called to adjust and resize the current control instance.
</p>
<p>
AutoAdjustLayout calls DisableAutoSizing on entry, and EnableAutoSizing prior 
to exit from the method.
</p>
</descr>
<seealso>
<link id="TControl.AutoAdjustLayout"/>
<link id="TControl.DisableAutoSizing"/>
<link id="TControl.EnableAutoSizing"/>
<link id="TControl.DoAutoAdjustLayout"/>
<link id="TWinControl.Controls"/>
</seealso>
</element>
<element name="TWinControl.AutoAdjustLayout.AMode">
<short>Layout mode applied in the method.</short>
</element>
<element name="TWinControl.AutoAdjustLayout.AFromPPI">
<short>
Existing pixels per inch (PPI) setting for the control.
</short>
</element>
<element name="TWinControl.AutoAdjustLayout.AToPPI">
<short>
Target pixels per inch (PPI) setting for the control.
</short>
</element>
<element name="TWinControl.AutoAdjustLayout.AOldFormWidth">
<short>
Form width before PPI scaling is applied.
</short>
</element>
<element name="TWinControl.AutoAdjustLayout.ANewFormWidth">
<short>
Form width after PPI scaling is applied.
</short>
</element>

<element name="TWinControl.FixDesignFontsPPIWithChildren">
<short>
Fixes the design-time PPI settings for the control font, and applies the 
changes to child controls.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.FixDesignFontsPPIWithChildren.ADesignTimePPI">
<short/>
</element>

<element name="TWinControl.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
Create is the overridden constructor for the class instance. Create calls the 
inherited method using TheOwner as the owner for the class instance. Create 
allocates resources needed in the class instance, and sets the default values 
for the following properties:
</p>
<dl>
<dt>ParentDoubleBuffered</dt>
<dd>Set to <b>True</b></dd>
<dt>ChildSizing</dt>
<dd>Sets DoChildSizingChange as the OnChange event handler</dd>
<dt>Brush</dt>
<dd>
Set to <b>Nil</b>; few controls require a brush, and it is created on 
DoRemainingKeyDown
</dd>
<dt>TabOrder</dt>
<dd>Set to -1</dd>
<dt>TabStop</dt>
<dd>Set to <b>False</b></dd>
</dl>
<p>
Create calls the InvalidateClientRectCache method to invalidate a cached 
client rectangle, and to force the value to be read from the LCL interface.
</p>
</descr>
<seealso>
<link id="TWinControl.InvalidateClientRectCache"/>
</seealso>
</element>
<element name="TWinControl.Create.TheOwner">
<short>Owner of the class instance.</short>
</element>

<element name="TWinControl.CreateParented">
<short>
Constructor for a control that is the child of the given widget.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.CreateParented.AParentWindow">
<short/>
</element>

<element name="TWinControl.CreateParentedControl" link="#lcl.controls.TWinControl.CreateParented"/>
<element name="TWinControl.CreateParentedControl.Result" link="#lcl.controls.TWinControl.CreateParented.Result"/>
<element name="TWinControl.CreateParentedControl.AParentWindow" link="#lcl.controls.TWinControl.CreateParented.AParentWindow"/>

<element name="TWinControl.Destroy">
<short>Destructor for the class instance.</short>
<descr>
<p>
<var>Destroy</var> is the overridden destructor for the class instance.
</p>
<p>
Destroy call RemoveFocus to ensure that the control cannot receive focus from 
a Parent control. If a handle has been allocated for the windowed control, 
the DestroyHandle method is called.
</p>
<p>
Destroy iterates over Controls to remove the value in the Parent property for 
each child control, and to remove an assigned HostDockSite. It does not 
actually free the child Controls; they are freed by the owner of the control 
instance (usually a TForm instance).
</p>
<p>
Destroy ensures that any controls in the DockClients property remove the 
current class instance from their host dock site.
</p>
<p>
Destroy frees resources allocated in the constructor, or in other class 
methods, including the DockManager and DockCients. Destroy calls the 
inherited destructor prior to exiting from the method.
</p>
</descr>
<seealso>
<link id="TControl.Parent"/>
<link id="TWinControl.Controls"/>
<link id="TWinControl.RemoveControl"/>
<link id="TWinControl.DockManager"/>
<link id="TWinControl.DockClients"/>
<link id="TControl.HostDockSite"/>
</seealso>
</element>

<element name="TWinControl.DockDrop">
<short>
Handler for a DragManager dmDragDrop message, sent when a dragged control has 
been dropped onto this docksite.
</short>
<descr>
<p>
Asks the dropped control to dock itself into this docksite, updates its 
Parent, HostDockSite, and the DockClients for the old and new DockSite.
</p>
<p>
When a DockManager is installed, it is used to position the docked control 
(InsertControl).
</p>
<p>
Finally, an OnDockDrop event is signalled.
</p>
</descr>
<seealso>
<link id="TWinControl.DoDockClientMsg"/>
<link id="TWinControl.OnDockDrop"/>
<link id="TDragDockObject"/>
</seealso>
</element>
<element name="TWinControl.DockDrop.DragDockObject">
<short/>
</element>
<element name="TWinControl.DockDrop.X">
<short/>
</element>
<element name="TWinControl.DockDrop.Y">
<short/>
</element>

<element name="TWinControl.CanFocus">
<short>
Is this control allowed to receive the focus when parent form is visible?
</short>
<descr>
<p>
Checks if the control can get focus when parent form is visible, i.e. if all 
its parents except the form are visible and enabled.
</p>
<p>A possible usage:</p>
<code>
if FormFoo.EditBar.CanFocus then
  FormFoo.ActiveControl := FormFoo.EditBar;
</code>
<remark>
CanFocus returns <b>True</b> even if the parent form is not actually visible, 
and a subsequent SetFocus call could throw an exception. Use 
<var>CanSetFocus</var> in this case.
</remark>
</descr>
<seealso>
<link id="TWinControl.CanSetFocus"/>
<link id="TWinControl.SetFocus"/>
<link id="TWinControl.CanFocus"/>
</seealso>
</element>
<element name="TWinControl.CanFocus.Result">
<short/>
</element>

<element name="TWinControl.CanSetFocus">
<short>Is this control allowed to receive the focus?</short>
<descr>
<p>
Checks if the control can receive focus, i.e. if all its parents are visible 
and enabled.
</p>
<p>A possible usage:</p>
<code>
if MyControl.CanSetFocus then
   MyControl.SetFocus;
</code>
<p>
<var>CanSetFocus</var> should be preferred over <var>CanFocus</var> if used 
in CanSetFocus/SetFocus combination because it checks also if the parent form 
can receive focus and thus prevents the "cannot focus an invisible window" 
LCL exception.
</p>
</descr>
<seealso>
<link id="TWinControl.CanFocus"/>
<link id="TWinControl.SetFocus"/>
</seealso>
</element>
<element name="TWinControl.CanSetFocus.Result">
<short/>
</element>

<element name="TWinControl.GetControlIndex">
<short>
Finds the position for the specified control in the Controls property.
</short>
<descr>
<p>
Calls the <var>IndexOf</var> method in Controls to find the child control in 
AControl. The return value contains the ordinal position in Controls where 
AControl is stored, or -1 when not found or Controls has not been assigned.
</p>
</descr>
<seealso>
<link id="TWinControl.Controls"/>
<link id="#rtl.classes.TFPList.IndexOf">TFPList.IndexOf</link>
</seealso>
</element>
<element name="TWinControl.GetControlIndex.Result">
<short>The ordinal position in Controls, -1 if not found.</short>
</element>
<element name="TWinControl.GetControlIndex.AControl">
<short>The child control to locate in the method.</short>
</element>

<element name="TWinControl.SetControlIndex" link="#lcl.controls.TWinControl.SetChildZPosition"/>
<element name="TWinControl.SetControlIndex.AControl"/>
<element name="TWinControl.SetControlIndex.NewIndex"/>

<element name="TWinControl.Focused">
<short>Checks whether the control has focus.</short>
<descr>
<p>
<var>Focused</var> is a <var>Boolean</var> function which indicates whether 
the control can be and is the currently focused control. The return value is 
<b>True</b> when the control can become focused during tab order navigation, 
has a valid Handle, and is the currently focused control in the widgetset 
class instance.
</p>
</descr>
<seealso>
<link id="TWinControl.CanTab"/>
<link id="FindOwnerControl"/>
</seealso>
</element>
<element name="TWinControl.Focused.Result">
<short><b>True</b> when the control has focus.</short>
</element>

<element name="TWinControl.PerformTab">
<short>Changes the focus to the next (or preceding) control.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.PerformTab.Result">
<short><b>True</b> when the focus has been transferred.</short>
</element>
<element name="TWinControl.PerformTab.ForwardTab">
<short>
The direction of Tab movement; <b>True</b> for the next control in the 
TabOrder, <b>False</b> for the preceding control.
</short>
</element>

<element name="TWinControl.FindChildControl">
<short>Finds a child control with the specified name.</short>
<descr>
<p>Only finds direct children, no recursion. The name is case insensitive.</p>
<p>Note that unique names are not guaranteed for components created in code
(if they have different owners). Therefore, only the first matching control
will be returned.</p>
</descr>
</element>
<element name="TWinControl.FindChildControl.Result">
<short>Control with the given name or <b>nil</b>.</short>
</element>
<element name="TWinControl.FindChildControl.ControlName">
<short>The name of the control to find (case insensitive).</short>
</element>

<element name="TWinControl.SelectNext">
<short>Transfers the focus to the next child control.</short>
<descr>
<p>
The search wraps around on the boundaries of the TabOrder array. When no next 
control can be found, the focus remains unchanged.
</p>
</descr>
<seealso>
<link id="TWinControl.FindNextControl"/>
</seealso>
</element>
<element name="TWinControl.SelectNext.CurControl">
<short>The control which is assumed to have the focus.</short>
</element>
<element name="TWinControl.SelectNext.GoForward">
<short>
 <b>False</b> when the control preceding CurControl shall be found.
</short>
</element>
<element name="TWinControl.SelectNext.CheckTabStop">
<short>
When <b>True</b>, only select a control that can receive the focus.
</short>
</element>

<element name="TWinControl.SetTempCursor" link="#lcl.controls.TControl.SetTempCursor"/>
<element name="TWinControl.SetTempCursor.Value"/>

<element name="TWinControl.BroadCast">
<short>
Posts the specified message to all of the child controls.
</short>
<descr>
<p>
Allows the specified method to be handled by one of the child Controls. The 
ToAllMessage argument is untyped; any TLMessage descendant can be passed as 
the value for the argument.
</p>
<p>
The method name is a misnomer. Broadcast implies delivery of the message 
simultaneously to all of the recipients. Actually, it is more like a 
telegraph. The message is posted sequentially to child controls until one of 
them handles the message using its WindowProc method.
</p>
<p>
Use NotifyControls to post a message with a specific message identifier 
constant to child Controls in the class instance.
</p>
</descr>
<seealso>
<link id="TWinControl.NotifyControls"/>
</seealso>
</element>
<element name="TWinControl.BroadCast.ToAllMessage">
<short>The message sent in the method.</short>
</element>

<element name="TWinControl.NotifyControls">
<short>Sends a message to all child controls.</short>
<descr>
<p>
Calls the BroadCast method to deliver a TLMessage instance with the 
identifier in Msg.
</p>
</descr>
<seealso>
<link id="TWinControl.BroadCast"/>
</seealso>
</element>
<element name="TWinControl.NotifyControls.Msg">
<short>The message ID.</short>
</element>

<element name="TWinControl.DefaultHandler">
<short>
Handles all messages that the control doesn't fully handle itself.
</short>
<descr>
<p>
This implementation sends the message to the widget's message handler.
</p>
<p>
Override this method to implement your own message handling. If the message 
Result is non-zero, the message already has been handled; otherwise, set the 
Result to a non-zero value (depending on the message ID) when the message has 
been handled.
</p>
</descr>
<seealso>
<link id="#rtl.system.TObject.DefaultHandler">TObject.DefaultHandler</link>
</seealso>
</element>
<element name="TWinControl.DefaultHandler.AMessage">
<short>The message to process.</short>
</element>

<element name="TWinControl.GetTextLen" link="#lcl.controls.TControl.GetTextLen"/>
<element name="TWinControl.GetTextLen.Result"/>

<element name="TWinControl.Invalidate">
<short>Schedules a repaint request.</short>
<descr>
<p>
<var>Invalidate</var> is an overridden method in TWinControl. It 
re-implements the inherited method to call the Invalidate method in the 
widgetset class instance when its Handle has been allocated. It does not call 
the inherited method.
</p>
<p>
The control is redrawn when there are no pending window messages in the 
message queue.
</p>
</descr>
<seealso>
<link id="TControl.Invalidate"/>
</seealso>
</element>

<element name="TWinControl.AddControl">
<short>
Tells the widgetset to add a Handle object representing the current control to 
the Parent handle.
</short>
<descr>
</descr>
<seealso/>
</element>

<element name="TWinControl.InsertControl">
<short>Inserts the specified control into the Controls property.</short>
</element>
<element name="TWinControl.InsertControl.AControl">
<short>The control to insert.</short>
</element>
<element name="TWinControl.InsertControl.Index">
<short>Insert at index (optional).</short>
</element>

<element name="TWinControl.RemoveControl">
<short>Removes the specified control from the Controls property.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.RemoveControl.AControl">
<short>The control to remove.</short>
</element>

<element name="TWinControl.GetEnumeratorControls">
<short>Gets an enumerator for the Controls property.</short>
<descr>
</descr>
<seealso/>
</element>
<element name="TWinControl.GetEnumeratorControls.Result">
<short>The TWinControlEnumerator instance.</short>
</element>

<element name="TWinControl.GetEnumeratorControlsReverse">
<short>Gets a reverse-order enumerator for the Controls property.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.GetEnumeratorControlsReverse.Result">
<short>The TWinControlEnumerator instance.</short>
</element>

<element name="TWinControl.Repaint" link="#lcl.controls.TControl.Repaint"/>
<element name="TWinControl.Update" link="#lcl.controls.TControl.Update"/>

<element name="TWinControl.SetFocus">
<short>
Ensures that the control or window handle has focus.
</short>
<descr>
<p>
<var>SetFocus</var> is a procedure used to give focus to the current control. 
SetFocus calls <var>GetParentForm</var> for the control instance, and uses 
its <var>FocusControl</var> method to change the focused control.
</p>
<p>
If the parent Form is unassigned (contains <b>Nil</b>), the LCL interface is 
used to change focus to the handle for the control. No actions are performed 
in the method when Form is unassigned and the control does not have an 
allocated handle.
</p>
</descr>
<seealso/>
</element>

<element name="TWinControl.FlipChildren">
<short>
Flip children horizontally. That means mirroring the Left position and 
anchoring.
</short>
<descr>
<p>
Child controls arranged in left-to-right order appear in right-to-left order 
after flipping. All anchors are adjusted accordingly.
</p>
</descr>
<seealso>
<link id="TWinControl.DoFlipChildren"/>
</seealso>
</element>
<element name="TWinControl.FlipChildren.AllLevels">
<short>Flip recursive?</short>
</element>

<element name="TWinControl.ScaleBy" link="#lcl.controls.TWinControl.ChangeScale"/>
<element name="TWinControl.ScaleBy.Multiplier" link="#lcl.controls.TWinControl.ChangeScale.Multiplier"/>
<element name="TWinControl.ScaleBy.Divider" link="#lcl.controls.TWinControl.ChangeScale.Divider"/>

<element name="TWinControl.GetDockCaption">
<short>Returns the docking caption for the specified control.</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.GetDockCaption.Result">
<short>String the docking caption for the control.</short>
</element>
<element name="TWinControl.GetDockCaption.AControl">
<short>Control instance examined in the method.</short>
</element>

<element name="TWinControl.UpdateDockCaption">
<short>
Updates the Caption to reflect the names for the docked clients.
</short>
<descr>
<p>
Called when this is a HostDockSite and either the list of docked clients have 
changed, or one of their captions has changed.
</p>
<p>
If the control is being undocked, but still is in the DockClients list, it is 
excluded from the docking caption and the Exclude argument is set to 
<b>True</b>.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.UpdateDockCaption.Exclude">
<short>Control to exclude from the DockCaption.</short>
</element>

<element name="TWinControl.GetTabOrderList">
<short>
Fill the list with all TabStop controls, recursing into child controls.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.GetTabOrderList.List">
<short>The list to which the controls shall be added.</short>
</element>

<element name="TWinControl.HandleAllocated">
<short>
Checks whether a handle for the widget has been allocated for the control.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.HandleAllocated.Result">
<short>
<b>True</b> when a widget exists and its Handle is not <b>Nil</b>.
</short>
</element>

<element name="TWinControl.ParentHandlesAllocated">
<short>
Returns <b>True</b> if all Parents have handles allocated, and are not being 
destroyed.
</short>
<descr>
<p>
ParentHandlesAllocated is an overridden method in TWinControl which checks 
whether Handles are valid for all controls in the component hierarchy for the 
current control.
</p>
<p>
ParentHandlesAllocated visits each of the controls, starting with the current 
class instance, and checks whether the control has an allocated handle and is 
not being destroyed. It navigates to the next Parent control in the 
hierarchy, and exits when the Parent control is unassigned.
</p>
<p>
The return value is <b>True</b> when all of the controls in the hierarchy 
have an allocated Handle and are not being destroyed. The return value is 
<b>False</b> if any control is found in the hierarchy that does not have a 
valid handle allocated, or ComponentState indicates its handle is being freed.
</p>
</descr>
<seealso>
<link id="TWinControl.HandleAllocated"/>
<link id="TWinControl.Handle"/>
<link id="TControl.Parent"/>
<link id="TControl.ParentHandlesAllocated"/>
</seealso>
</element>
<element name="TWinControl.ParentHandlesAllocated.Result">
<short>
<b>True</b> when all of the controls in the Parent hierarchy have a valid 
handle.
</short>
</element>

<element name="TWinControl.HandleNeeded">
<short>
Call this method when your code requires a valid Handle for this control.
</short>
<descr>
<p>
An attempt is made to create a widget, when not already done.
</p>
<remark>
In certain situations it may be impossible to create a widget right now!
</remark>
</descr>
<seealso/>
</element>

<element name="TWinControl.BrushCreated">
<short>
Indicates whether a Brush has been created for the control.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.BrushCreated.Result">
<short><b>True</b> when a Brush has been created.</short>
</element>

<element name="TWinControl.EraseBackground">
<short>
Fills the display rectangle for the control with the color and pattern in 
Brush.
</short>
<descr>
<p>
<var>EraseBackground</var> is called during Paint requests from the 
WMEraseBkgnd method, which provides a valid device context in the DC 
argument. No actions are performed in the method when DC contains 0 
(unassigned).
</p>
<p>
The FillRect routine is called to perform the operation using the Width, 
Height, and the handle in the Brush property.
</p>
</descr>
<seealso>
<link id="TWinControl.Brush"/>
<link id="TControl.Height"/>
<link id="TControl.Width"/>
</seealso>
</element>
<element name="TWinControl.EraseBackground.DC">
<short>The device context to use; may be clipped to a certain shape.</short>
</element>

<element name="TWinControl.IntfUTF8KeyPress">
<short>
Called by the interface after the navigation and specials keys are handled;
i.e. after KeyDown but before KeyPress.
</short>
<descr>
<p>
Essentially expands a repeat count into multiple keystrokes. Cannot be used 
for SysKeys.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.IntfUTF8KeyPress.Result">
<short><b>True</b> when multiple keystrokes have been processed.</short>
</element>
<element name="TWinControl.IntfUTF8KeyPress.UTF8Key">
<short>The UTF-8 encoding of the character.</short>
</element>
<element name="TWinControl.IntfUTF8KeyPress.RepeatCount">
<short>Must be greater than zero, the exact value is ignored.</short>
</element>
<element name="TWinControl.IntfUTF8KeyPress.SystemKey">
<short>Must be <b>False</b>, else nothing happens.</short>
</element>

<element name="TWinControl.IntfGetDropFilesTarget">
<short>
Searches for a Parent form that can be used as a file drop target.
</short>
<descr/>
<seealso/>
</element>
<element name="TWinControl.IntfGetDropFilesTarget.Result">
<short>
The TCustomForm instance that allows file drop actions, or <b>Nil</b> when 
file drag/drop is not supported.
</short>
</element>

<element name="TWinControl.PaintTo">
<short>Paints the control using the handle for the widgetset class.</short>
<descr>
<p>
<var>PaintTo</var> is a procedure used to draw the control using the handle 
for the widgetset class. An overloaded variant is provided which uses the 
handle in a <var>TCanvas</var> instance as the target for the drawing 
operation.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.PaintTo.DC">
<short>Device context (or Handle) used for the operation.</short>
</element>
<element name="TWinControl.PaintTo.X">
<short>Horizontal coordinate where the control is drawn.</short>
</element>
<element name="TWinControl.PaintTo.Y">
<short>Vertical coordinate where the control is drawn.</short>
</element>
<element name="TWinControl.PaintTo.ACanvas">
<short>TCanvas instance with the handle used in the operation.</short>
</element>

<element name="TWinControl.SetShape">
<short>Specifies the non-rectangular shape of the widget.</short>
<descr>
<p>
<var>SetShape</var> is an overloaded procedure used to set the shape for the 
control to the non-rectangular value in AShape. The overloaded methods allow 
AShape to be either a TBitmap or a TRegion value.
</p>
<p>
When TBitmap is used, the widgetset class calls its SetShape method to apply 
the TBitmap handle to the handle for the widget. No actions are performed in 
the method when a handle has not been allocated for the widgetset class.
</p>
<p>
When TRegion is used, SetWindowRgn in the LCL interface is called to apply 
the region in AShape to the handle for the control.
</p>
</descr>
<seealso/>
</element>
<element name="TWinControl.SetShape.AShape">
<short>
Shape for the control; TBitmap or TRegion in overloaded methods.
</short>
</element>

<element name="TGraphicControl">
<short>
<var>TGraphicControl</var> is the base class for all lightweight controls.
</short>
<descr>
<p>
<var>TGraphicControl</var> supports simple lightweight controls that do not 
need the ability to accept keyboard input, and do not contain other controls. 
Since lightweight controls do not wrap GUI widgets, they use fewer resources 
than controls based on <var>TWinControl</var>. If you want to accept keyboard 
input, or need to support child controls, use a <var>TCustomControl</var> 
instead.
</p>
<p>
<var>TGraphicControl</var> provides a <var>Canvas</var> property for access 
to the control's drawing surface and a virtual <var>Paint</var> method and an 
<var>OnPaint</var> handler, called in response to paint requests received by 
the parent control.
</p>
<p>
Override the Paint method, or supply your own <var>OnPaint</var> handler, to 
do the actual drawing of the control.
</p>
</descr>
<seealso>
<link id="TCustomControl"/>
<link id="TGraphicControl.Paint"/>
<link id="TGraphicControl.OnPaint"/>
<link id="#lcl.graphics.TCanvas">TCanvas</link>
</seealso>
</element>

<element name="TGraphicControl.FCanvas"/>
<element name="TGraphicControl.FOnPaint"/>

<element name="TGraphicControl.WMPaint">
<short>Handles a LM_PAINT message for the control.</short>
</element>
<element name="TGraphicControl.WMPaint.Message">
<short>Message handled in the method.</short>
</element>

<element name="TGraphicControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

<element name="TGraphicControl.FontChanged">
<short>
Performs actions needed when the Font for the control has been changed.
</short>
<descr>
<p>
<var>FontChanged</var> is an overridden method in TGraphicControl used to 
perform actions needed when the Font for the control has been changed. It is 
the routine used as the OnChange event handler for the Font property, and is 
assigned in the inherited constructor for the class instance.
</p>
<p>
Sender contains the object instance for the event notification, and is 
provided to maintain compatibility with the TNotifyEvent signature for the 
event handler. It is not used in TGraphicControl, but is passed as an 
argument to the inherited method.
</p>
<p>
FontChanged ensures that the new value for the Font property is also applied 
to the Canvas for the control. This includes the PixelsPerInch setting for 
the Font. FontChanged calls the inherited method prior to exit.
</p>
</descr>
<seealso>
<link id="TControl.FontChanged"/>
<link id="TControl.Font"/>
<link id="TControl.Create"/>
<link id="#lcl.graphics.TFont.PixelsPerInch">TFont.PixelsPerInch</link>
</seealso>
</element>
<element name="TGraphicControl.FontChanged.Sender">
<short>Object instance for the event notification.</short>
</element>

<element name="TGraphicControl.Paint">
<short>
Implements the default handler used to draw the control.
</short>
<descr>
<p>
<var>Paint</var> is a method which causes the control to be drawn using the 
drawing mechanism for the control. In TGraphicControl, like TCustomControl, 
the OnPaint event handler is used (when assigned). Assign a routine to the 
OnPaint handler to perform the drawing operations needed for the control.
</p>
</descr>
<seealso>
<link id="TGraphicControl.OnPaint"/>
</seealso>
</element>

<element name="TGraphicControl.DoOnChangeBounds">
<short>
Performs action needed when the bounds for the control have been changed.
</short>
<descr>
<p>
<var>DoOnChangeBounds</var> is an overridden method in TGraphicControl. It 
calls the inherited method on entry to update control flags and signal 
OnChangeBounds event handlers for the control. The Handle in Canvas is freed 
prior to exiting from the method. The handle is re-allocated the next time it 
is accessed.
</p>
<p>
DoOnChangeBounds is called when the component is loaded using the LCL 
streaming mechanism, and from the ChangeBounds method when the control is 
resized.
</p>
</descr>
<seealso>
<link id="TGraphicControl.Canvas"/>
<link id="TControlCanvas.FreeHandle"/>
<link id="TControl.DoOnChangeBounds"/>
<link id="TControl.OnChangeBounds"/>
<link id="TControl.ChangeBounds"/>
<link id="TControl.LoadedAll"/>
<link id="TControlFlag"/>
</seealso>
</element>

<element name="TGraphicControl.DoOnParentHandleDestruction">
<short>
Performs actions when the handle for the parent control is freed.
</short>
<descr>
<p>
<var>DoOnParentHandleDestruction</var> is overridden in 
<var>TGraphicControl</var> to re-implement the method in the ancestor class. 
It ensures that Handle for the Canvas is freed when the parent handler is 
destroyed.
</p>
</descr>
<seealso>
<link id="TGraphicControl.Canvas"/>
<link id="TControlCanvas.FreeHandle"/>
<link id="TControl.DoOnParentHandleDestruction"/>
</seealso>
</element>

<element name="TGraphicControl.OnPaint">
<short>
Event handler signalled to paint the control.
</short>
<descr>
<p>
<var>OnPaint</var> is a <var>TNotifyEvent</var> with the event handler 
signalled to paint the control. Applications must implement and assign a 
routine to the event handler to perform the drawing operation. 
TGraphicControl does not provide a default drawing mechanism.
</p>
<p>
Use the Canvas for the control to perform drawing operations. The Font and 
Brush in Canvas are automatically configured to use values assigned to the 
corresponding properties in the control. BorderStyle, however, is not 
automatically applied. Use the Pen in Canvas as needed to draw the 
BorderStyle for the control.
</p>
<p>
OnPaint is signalled (when assigned) from the Paint method.
</p>
</descr>
<seealso>
<link id="TGraphicControl.Canvas"/>
<link id="TGraphicControl.Paint"/>
<link id="TControl.Font"/>
<link id="TControl.Color"/>
<link id="TWinControl.BorderStyle"/>
</seealso>
</element>

<element name="TGraphicControl.CMCursorChanged">
<short>Handles the CM_CURSORCHANGED message for the control.</short>
<descr>
<p>
<var>CMCursorChanged</var> is an overridden method in TGraphicControl. It 
ensures that the control is Visible before the temporary cursor shape is 
changed.
</p>
<p>
<var>Visible</var> must be set to <b>True</b>, and the <var>Parent</var> 
control (with the window handle) must be assigned before the control can be 
displayed. No actions are performed in the method if Visible is <b>False</b>, 
or Parent is <b>Nil</b>.
</p>
<p>
In addition, the mouse must be over the control to apply the cursor shape 
using <var>SetTempCursor</var> and the value in the <var>Cursor</var> 
property.
</p>
</descr>
<seealso>
<link id="TControl.CMCursorChanged"/>
<link id="TControl.Visible"/>
<link id="TControl.Parent"/>
<link id="TControl.Cursor"/>
<link id="TControl.SetTempCursor"/>
</seealso>
</element>

<element name="TGraphicControl.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the overridden constructor for the class instance. It 
calls the inherited method on entry using AOwner as the owner of the class 
instance. Create allocates a TControlCanvas instance used for the Canvas 
property.
</p>
</descr>
<seealso>
<link id="TGraphicControl.Canvas"/>
<link id="TControlCanvas"/>
<link id="TControl.Create"/>
</seealso>
</element>
<element name="TGraphicControl.Create.AOwner">
<short>Owner of the class instance.</short>
</element>

<element name="TGraphicControl.Destroy">
<short>Destructor for the class instance.</short>
<descr>
<p>
<var>Destroy</var> is the overridden destructor for the class instance. It 
ensures that resources allocated for the Canvas property are freed. It calls 
the inherited destructor prior to exiting from the method.
</p>
</descr>
<seealso>
<link id="TGraphicControl.Canvas"/>
</seealso>
</element>

<element name="TGraphicControl.Canvas">
<short>A clipped window into the parent Canvas.</short>
<descr>
<p>
Don't paint on the entire Canvas! Instead use the dimensions of the 
<var>TGraphicControl</var> stored in the <var>ClientRect</var>.
</p>
<p>
If you ask for the <var>Canvas.Width</var> or <var>Canvas.Height</var>, you 
are actually getting the Canvas dimensions from the Parent control.
</p>
</descr>
<seealso>
<link id="TControl.ClientRect"/>
<link id="TControl.ClientWidth"/>
<link id="TControl.ClientHeight"/>
<link id="TControl.BoundsRect"/>
<link id="#lcl.graphics.TCanvas">TCanvas</link>
</seealso>
</element>

<element name="TCustomControl">
<short>
The base class for windowed controls which paint themselves.
</short>
<descr>
<p>
In contrast to <var>TGraphicControl</var>, a <var>TCustomControl</var> can 
accept keyboard input (and receive Focus), and can have child controls. It is 
used as the base class for many of the controls in the LCL.
</p>
<p>
TCustomControl provides overridden methods which handle messages, update 
control state flags, and update the Canvas where the control is drawn. 
</p>
<p>
Override the Paint method, or supply your own OnPaint handler, to perform the 
actual drawing operations for the control.
</p>
</descr>
<seealso>
<link id="TGraphicControl"/>
<link id="TWinControl"/>
</seealso>
</element>

<element name="TCustomControl.FCanvas"/>
<element name="TCustomControl.FOnPaint"/>

<element name="TCustomControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

<element name="TCustomControl.WMPaint">
<short>Handles LM_PAINT messages for the control.</short>
<descr>
<p>
Re-implements the method from the ancestor class to update ControlState prior 
to handling the specified Message. Includes the value csCustomPaint in 
ControlState before calling the inherited method. Removes csCustomPaint from 
ControlState after the message has been handled.
</p>
<p>
No actions are performed in the method when the control is being freed, or 
when a Handle has not been allocated for the control.
</p>
</descr>
<seealso>
<link id="TWinControl.WMPaint"/>
</seealso>
</element>
<element name="TCustomControl.WMPaint.Message">
<short>Message handled in the method.</short>
</element>

<element name="TCustomControl.DestroyWnd">
<short>Destroys the handle for the Canvas and the interface object.</short>
<descr>
<p>
DestroyWnd is an overridden method in TCustomControl. It ensures that the 
Handle in Canvas is freed before calling the inherited method.
</p>
</descr>
<seealso>
<link id="TCustomControl.Canvas"/>
<link id="TWinControl.DestroyWnd"/>
<link id="TControlCanvas.FreeHandle"/>
</seealso>
</element>

<element name="TCustomControl.PaintWindow">
<short>The Paint handler plug-in, intercepting paint requests.</short>
<descr>
<p>
<var>PaintWindow</var> is an overridden method in TCustomControl. It ensures 
that Canvas has an allocated Handle which matches the device context 
specified in the DC argument. If the Canvas handle does not match DC, the 
value in the argument is assigned to Canvas.
</p>
<p>
PaintWindow calls the Paint method to signal the OnPaint event handler (when 
assigned).
</p>
<p>
If Handle value in Canvas was changed in the method, it is reset to 0 
(unassigned) prior to exit.
</p>
<p>
PaintWindow does not call the inherited method.
</p>
</descr>
<seealso>
<link id="TCustomControl.Canvas"/>
<link id="TCustomControl.Paint"/>
<link id="TCustomControl.OnPaint"/>
<link id="TWinControl.PaintWindow"/>
</seealso>
</element>
<element name="TCustomControl.PaintWindow.DC">
<short>The Device Context used to draw on the Canvas.</short>
</element>

<element name="TCustomControl.FontChanged">
<short>
Performs actions needed when the Font for the control has been changed.
</short>
<descr>
<p>
<var>FontChanged</var> is an overridden method in <var>TCustomControl</var> 
used to perform actions needed when the Font for the control has been 
changed. It is the routine used as the OnChange event handler for the Font 
property, and is assigned in the inherited constructor for the class instance.
</p>
<p>
Sender contains the object instance for the event notification, and is 
provided to maintain compatibility with the TNotifyEvent signature for the 
event handler. It is not used in TGraphicControl, but is passed as an 
argument to the inherited method.
</p>
<p>
FontChanged ensures that the new value for the Font property is also applied 
to the Canvas for the control. This includes the PixelsPerInch setting for 
the Font. FontChanged calls the inherited method prior to exit.
</p>
</descr>
<seealso>
<link id="TControl.FontChanged"/>
<link id="TControl.Font"/>
<link id="TControl.Create"/>
<link id="#lcl.graphics.TFont.PixelsPerInch">TFont.PixelsPerInch</link>
</seealso>
</element>
<element name="TCustomControl.FontChanged.Sender">
<short>Object instance (TControl) for the event notification.</short>
</element>

<element name="TCustomControl.SetColor">
<short>Sets the value for the Color property</short>
<descr>
<p>
<var>SetColor</var> is an overridden method in <var>TCustomControl</var> used 
to set the value in the Color property. It calls the inherited method on 
entry, and applies the new color value to the Brush in the control Canvas.
</p>
</descr>
<seealso>
<link id="#lcl.controls.TControl.Color">TControl.Color</link>
<link id="#lcl.controls.TWinControl.SetColor">TWinControl.SetColor</link>
</seealso>
</element>
<element name="TCustomControl.SetColor.Value">
<short>New value for the Color property.</short>
</element>

<element name="TCustomControl.Paint">
<short>
Implements the default handler used to draw the control.
</short>
<descr>
<p>
<var>Paint</var> is a method which causes the control to be drawn using the 
drawing mechanism for the control. In TCustomControl, like TGraphicControl, 
the OnPaint event handler is used (when assigned). Assign a routine to the 
OnPaint handler to perform the drawing operations needed for the control.
</p>
<p>
Paint called from the PaintWindow method, and occurs when a LM_PAINT message 
is handled for the control.
</p>
</descr>
<seealso>
<link id="TCustomControl.OnPaint"/>
<link id="TCustomControl.PaintWindow"/>
<link id="TCustomControl.WMPaint"/>
</seealso>
</element>

<element name="TCustomControl.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
<var>Create</var> is the overridden constructor for the class instance, and 
calls the inherited constructor on entry. Create allocates resources for the 
TControlCanvas instance used in the Canvas property.
</p>
</descr>
<seealso>
<link id="TCustomControl.Canvas"/>
<link id="TControlCanvas"/>
</seealso>
</element>
<element name="TCustomControl.Create.AOwner">
<short>Owner for the class instance.</short>
</element>

<element name="TCustomControl.Destroy">
<short>Destructor for the class instance.</short>
<descr>
<p>
<var>Destroy</var> is the overridden destructor for the class instance.
</p>
<p>
It calls RemoveFocus to prevent the Parent control from giving focus to the 
free control. It destroys the Handle for the control, and ensures that the 
control is removed as a Parent or DockSite for its child controls. It does 
not free the child controls; they are freed by their owner.
</p>
<p>
Controls in the DockClient property are updated to remove the class instance 
from the HostDockSite property in the docking clients.
</p>
<p>
Destroy frees resource allocated in the constructor, and calls the inherited 
method prior to exit.
</p>
</descr>
<seealso>
<link id="TCustomControl.Canvas"/>
</seealso>
</element>

<element name="TCustomControl.Canvas">
<short>
The drawing surface for the control.
</short>
<descr>
<p>
<var>Canvas</var> is a <var>TCanvas</var> property which contains the drawing 
surface for the control. Resources for the property are allocated in the 
constructor for the class instance. A TControlCanvas descendant is created 
and assigned to the member for the property. The Handle for the Canvas is 
updated when PaintWindow is called for a specific device context.
</p>
<p>
Changing values in the Font or Color properties causes settings in Canvas to 
be updated. A new value assigned to Font is also assigned to the Canvas in 
the control, and includes the PixelsPerInch setting for the Font. A new value 
assigned to Color is applied to the Brush in Canvas. A value assigned to 
BorderStyle must be handled in the routine assigned to the OnPaint event 
handler.
</p>
</descr>
<seealso>
<link id="TCustomControl.Canvas"/>
<link id="TCustomControl.OnPaint"/>
<link id="TWinControl.BorderStyle"/>
<link id="TControl.Font"/>
<link id="TControlCanvas"/>
<link id="#lcl.graphics.TCanvas">TCanvas</link>
</seealso>
</element>

<element name="TCustomControl.BorderStyle" link="#lcl.controls.TWinControl.BorderStyle"/>

<element name="TCustomControl.OnPaint">
<short>
Event handler signalled to paint the control.
</short>
<descr>
<p>
<var>OnPaint</var> is a <var>TNotifyEvent</var> property with the event 
handler signalled to draw the control on its Canvas. An object procedure 
which draws all aspects of the control must be implemented and assigned to 
the property.
</p>
<p>
The Sender argument provides access to properties and methods for the control 
instance. It must be cast to a TCustomControl to access members for the class 
type.
</p>
<p>
Use Canvas to render the control in the event handler. The values from Font 
and Color are already applied to the corresponding properties in Canvas. The 
BorderStyle property must be applied in code for the handler.
</p>
<p>
OnPaint is signalled from the Paint method.
</p>
<remark>
For the macOS Carbon widgetset, drawing on the Canvas outside of the OnPaint 
event handler is not supported. Drawing directly to a screen device context is 
also not supported.
</remark>
</descr>
<seealso>
<link id="TCustomControl.Paint"/>
<link id="TCustomControl.Canvas"/>
<link id="TControl.Font"/>
<link id="TControl.Color"/>
<link id="TWinControl.BorderStyle"/>
</seealso>
</element>

<element name="TImageList">
<short>
Implements a multi-resolution container for images used in an application.
</short>
<descr>
<p>
<var>TImageList</var> is a <var>TDragImageList</var> descendant, and sets the 
visibility for properties in ancestor classes (like TCustomImageList). As a 
<link id="TDragImageList">TDragImageList</link> descendant, it provides 
support for using images in the list during drag-and-drop or drag-and-dock 
operations. Most of the features and functionality for the list are inherited 
from the <link id="#lcl.imglist.TCustomImageList">TCustomImageList</link> 
class.
</p>
</descr>
<seealso>
<link id="TDragImageList"/>
<link id="#lcl.imglist.TCustomImageList">TCustomImageList</link>
</seealso>
</element>

<element name="TImageList.AllocBy" link="#lcl.imglist.TCustomImageList.AllocBy"/>
<element name="TImageList.BlendColor" link="#lcl.imglist.TCustomImageList.BlendColor"/>
<element name="TImageList.BkColor" link="#lcl.imglist.TCustomImageList.BkColor"/>
<element name="TImageList.DrawingStyle" link="#lcl.imglist.TCustomImageList.DrawingStyle"/>
<element name="TImageList.Height" link="#lcl.imglist.TCustomImageList.Height"/>
<element name="TImageList.ImageType" link="#lcl.imglist.TCustomImageList.ImageType"/>
<element name="TImageList.Masked" link="#lcl.imglist.TCustomImageList.Masked"/>
<element name="TImageList.Scaled" link="#lcl.imglist.TCustomImageList.Scaled"/>
<element name="TImageList.ShareImages" link="#lcl.imglist.TCustomImageList.ShareImages"/>
<element name="TImageList.Width" link="#lcl.imglist.TCustomImageList.Width"/>
<element name="TImageList.OnChange" link="#lcl.imglist.TCustomImageList.OnChange"/>
<element name="TImageList.OnGetWidthForPPI" link="#lcl.imglist.TCustomImageList.OnGetWidthForPPI"/>

<element name="TControlPropertyStorage">
<short>
Implements the abstract ancestor class used to get the property list for a 
control.
</short>
<descr/>
<seealso/>
</element>

<element name="TControlPropertyStorage.GetPropertyList">
<short>
Parses the values from SessionProperties in the Root component into the given 
list.
</short>
<descr/>
<seealso>
<link id="TControl.SessionProperties"/>
</seealso>
</element>
<element name="TControlPropertyStorage.GetPropertyList.List">
<short>
TStrings instance where the component/property names and values are stored.
</short>
</element>

<element name="TDockZone">
<short>
Represents a node in a <link id="#lcl.controls.TDockTree">TDockTree</link>
</short>
<descr>
<p>
It encapsulates a dock zone, containing either other zones or a single 
control.
</p>
<p>
This implementation is specific to <link id="TDockTree"/>. Another 
DockManager can (and should) use its own class instead.
</p>
</descr>
<seealso>
<link id="TDockTree"/>
</seealso>
</element>

<element name="TDockZone.FChildControl"/>
<element name="TDockZone.FChildCount"/>
<element name="TDockZone.FFirstChildZone"/>
<element name="TDockZone.FTree"/>
<element name="TDockZone.FParentZone"/>
<element name="TDockZone.FOrientation"/>
<element name="TDockZone.FNextSibling"/>
<element name="TDockZone.FPrevSibling"/>
<element name="TDockZone.FBounds"/>

<element name="TDockZone.GetHeight">
<short>Gets the value for the Height property.</short>
<descr/>
<seealso>
<link id="TDockZone.Height"/>
</seealso>
</element>
<element name="TDockZone.GetHeight.Result">
<short>Value for the Height property.</short>
</element>

<element name="TDockZone.GetLeft">
<short>Gets the value for the Left property.</short>
<descr/>
<seealso>
<link id="TDockZone.Left"/>
</seealso>
</element>
<element name="TDockZone.GetLeft.Result">
<short>Gets the value for the Left property.</short>
</element>

<element name="TDockZone.GetLimitBegin">
<short>Gets the value for the LimitBegin property.</short>
<descr/>
<seealso>
<link id="TDockZone.LimitBegin"/>
</seealso>
</element>
<element name="TDockZone.GetLimitBegin.Result">
<short>Value for the LimitBegin property.</short>
</element>

<element name="TDockZone.GetLimitSize">
<short>Gets the value for the LimitSize property.</short>
<descr/>
<seealso>
<link id="TDockZone.LimitSize"/>
</seealso>
</element>
<element name="TDockZone.GetLimitSize.Result">
<short>Value for the LimitSize property.</short>
</element>

<element name="TDockZone.GetTop">
<short>Gets the value for the Top property.</short>
<descr/>
<seealso>
<link id="TDockZone.Top"/>
</seealso>
</element>
<element name="TDockZone.GetTop.Result">
<short>Value for the Top property.</short>
</element>

<element name="TDockZone.GetVisible">
<short>Gets the value for the Visible property.</short>
<descr/>
<seealso>
<link id="TDockZone.Visible"/>
</seealso>
</element>
<element name="TDockZone.GetVisible.Result">
<short>Value for the Visible property.</short>
</element>

<element name="TDockZone.GetVisibleChildCount">
<short>Gets the value for the VisibleChildCount property.</short>
<descr/>
<seealso>
<link id="TDockZone.VisibleChildCount"/>
</seealso>
</element>
<element name="TDockZone.GetVisibleChildCount.Result">
<short>Value for the VisibleChildCount property.</short>
</element>

<element name="TDockZone.GetWidth">
<short>Gets the value for the Width property.</short>
<descr/>
<seealso>
<link id="TDockZone.Width"/>
</seealso>
</element>
<element name="TDockZone.GetWidth.Result">
<short>Value for the Width property.</short>
</element>

<element name="TDockZone.SetLimitBegin">
<short>Sets the value for the LimitBegin property.</short>
<descr/>
<seealso>
<link id="TDockZone.LimitBegin"/>
</seealso>
</element>
<element name="TDockZone.SetLimitBegin.AValue">
<short>New value for the LimitBegin property.</short>
</element>

<element name="TDockZone.SetLimitSize">
<short>New value for the LimitSize property.</short>
<descr/>
<seealso>
<link id="TDockZone.LimitSize"/>
</seealso>
</element>
<element name="TDockZone.SetLimitSize.AValue">
<short>New value for the LimitSize property.</short>
</element>

<element name="TDockZone.SetHeight">
<short>Sets the value for the Height property.</short>
<descr/>
<seealso>
<link id="TDockZone.Height"/>
</seealso>
</element>
<element name="TDockZone.SetHeight.AValue">
<short>New value for the Height property.</short>
</element>

<element name="TDockZone.SetLeft">
<short>Sets the value for the Left property.</short>
<descr/>
<seealso>
<link id="TDockZone.Left"/>
</seealso>
</element>
<element name="TDockZone.SetLeft.AValue">
<short>New value for the Left property.</short>
</element>

<element name="TDockZone.SetTop">
<short>Sets the value for the Top property.</short>
<descr/>
<seealso>
<link id="TDockZone.Top"/>
</seealso>
</element>
<element name="TDockZone.SetTop.AValue">
<short>New value for the Top property.</short>
</element>

<element name="TDockZone.SetWidth">
<short>Sets the value for the Width property.</short>
<descr/>
<seealso>
<link id="TDockZone.Width"/>
</seealso>
</element>
<element name="TDockZone.SetWidth.AValue">
<short>New value for the Width property.</short>
</element>

<element name="TDockZone.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
Stores values passed in the TheTree and TheChild arguments to the Tree and 
ChildControl property. Sets the initial bounds for the dock zone to an empty 
rectangle. This causes the Top, Left, Width, and Height properties to contain 
0 (zero).
</p>
</descr>
<seealso/>
</element>
<element name="TDockZone.Create.TheTree">
<short>The dock tree to which this zone belongs.</short>
</element>
<element name="TDockZone.Create.TheChildControl">
<short>The control in this zone (or <b>Nil</b> when unassigned).</short>
</element>

<element name="TDockZone.FindZone">
<short>Returns the dock zone containing the given control.</short>
<descr/>
<seealso/>
</element>
<element name="TDockZone.FindZone.Result">
<short>The zone containing AControl as ChildControl.</short>
</element>
<element name="TDockZone.FindZone.AControl">
<short>Control to locate in the dock tree.</short>
</element>

<element name="TDockZone.FirstVisibleChild">
<short>The first visible child zone.</short>
<descr/>
<seealso>
<link id="TDockZone.Visible"/>
</seealso>
</element>
<element name="TDockZone.FirstVisibleChild.Result">
<short/>
</element>

<element name="TDockZone.GetNextVisibleZone">
<short>The next visible zone.</short>
<descr/>
<seealso>
<link id="TDockZone.Visible"/>
</seealso>
</element>
<element name="TDockZone.GetNextVisibleZone.Result">
<short>The zone, or <b>Nil</b> if none found.</short>
</element>

<element name="TDockZone.NextVisible">
<short>The next visible zone.</short>
<descr/>
<seealso>
<link id="TDockZone.Visible"/>
</seealso>
</element>
<element name="TDockZone.NextVisible.Result">
<short/>
</element>

<element name="TDockZone.PrevVisible">
<short>The preceding visible zone.</short>
<descr/>
<seealso>
<link id="TDockZone.Visible"/>
</seealso>
</element>
<element name="TDockZone.PrevVisible.Result">
<short/>
</element>

<element name="TDockZone.AddSibling">
<short>Inserts NewZone as preceding or following sibling.</short>
<descr/>
</element>
<element name="TDockZone.AddSibling.NewZone">
<short>The zone to add.</short>
</element>
<element name="TDockZone.AddSibling.InsertAt">
<short>How to add the zone.</short>
</element>

<element name="TDockZone.AddAsFirstChild">
<short>Adds the given zone as the first child.</short>
<descr/>
<seealso/>
</element>
<element name="TDockZone.AddAsFirstChild.NewChildZone">
<short>The zone to add.</short>
</element>

<element name="TDockZone.AddAsLastChild">
<short>Adds the given zone as the last child.</short>
<descr/>
<seealso/>
</element>
<element name="TDockZone.AddAsLastChild.NewChildZone">
<short>The zone to add.</short>
</element>

<element name="TDockZone.ReplaceChild">
<short>
Replace the <var>OldChild</var> zone by <var>NewChild</var>.
</short>
<descr/>
<seealso/>
</element>
<element name="TDockZone.ReplaceChild.OldChild">
<short>The zone to unlink.</short>
</element>
<element name="TDockZone.ReplaceChild.NewChild">
<short>The zone to link in place of OldChild.</short>
</element>

<element name="TDockZone.GetLastChild">
<short>The last child zone.</short>
<descr/>
<seealso/>
</element>
<element name="TDockZone.GetLastChild.Result">
<short/>
</element>

<element name="TDockZone.GetIndex">
<short>Calculates the index of the zone within its parent zone.</short>
<descr/>
<seealso/>
</element>
<element name="TDockZone.GetIndex.Result">
<short/>
</element>

<element name="TDockZone.Remove">
<short>Unlinks the given child zone.</short>
<descr/>
<seealso/>
</element>
<element name="TDockZone.Remove.ChildZone">
<short/>
</element>

<element name="TDockZone.ChildControl">
<short>The control docked in this zone.</short>
<descr>
A zone can contain nothing, a control, or child zones.
</descr>
<seealso/>
</element>

<element name="TDockZone.ChildCount">
<short>The number of child zones.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.FirstChild">
<short>The first child zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.Height">
<short>The height of the zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.Left">
<short>The left coordinate of the zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.LimitBegin">
<short>The free coordinate of the DockZone (Left or Top).</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.LimitSize">
<short>The free size of the DockZone (Width or Height).</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.Orientation">
<short>
Whether docking is oriented vertically, horizontally, in pages, or not at all.
</short>
<descr>
<ul>
<li>doNoOrient: zone contains a TControl and no child zones.</li>
<li>doHorizontal: zone's children are stacked top-to-bottom.</li>
<li>doVertical: zone's children are arranged left-to-right.</li>
<li>doPages: zone's children are pages arranged left-to-right.</li>
</ul>
</descr>
<seealso>
<link id="TDockOrientation"/>
</seealso>
</element>

<element name="TDockZone.Parent">
<short>The parent zone in the DockTree.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.Top">
<short>The top coordinate for the dock zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.Tree">
<short>The dock tree of which this dock zone is a part.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.Visible">
<short>
A zone is visible if it contains a visible control, or if any child zone is 
visible.
</short>
<descr/>
<seealso>
<link id="TDockZone.VisibleChildCount"/>
</seealso>
</element>

<element name="TDockZone.VisibleChildCount">
<short>The number of visible child zones.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.Width">
<short>The width of this zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.NextSibling">
<short>The next sibling zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZone.PrevSibling">
<short>The preceding sibling zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockZoneClass">
<short>Class of <link id="TDockZone"/></short>
</element>

<element name="TForEachZoneProc">
<short>The type for a ForEachZone callback procedure, currently unused.
</short>
<descr/>
<seealso/>
</element>
<element name="TForEachZoneProc.Zone">
<short>The iterated zone.</short>
</element>

<element name="TDockTreeFlag">
<short>Represents flag values used in TDockTree.</short>
<descr/>
<seealso>
<link id="TDockTree"/>
</seealso>
</element>
<element name="TDockTreeFlag.dtfUpdateAllNeeded">
<short/>
</element>

<element name="TDockTreeFlags">
<short>
Set type used to store values from the TDockTreeFlag enumeration.
</short>
<descr/>
<seealso>
<link id="TDockTreeFlag"/>
</seealso>
</element>

<element name="TDockTree">
<short>
A tree of TDockZone instances where each docked window has one tree.
</short>
<descr>
<p>
<var>TDockTree</var> is a <var>TDockManager</var> descendant with a simple 
docking manager that allows docking a control into another using 
Align=alClient to fill the whole client area.
</p>
<p>
In this class, Docking means: Combining several windows into one. And, a 
window can be a TCustomForm instance, a floating (undocked) control, or a 
TDockForm instance. A window can be docked to another to the left, right, top, 
bottom, or "into". The source docking window will be resized to fit to the 
target docking window.
</p>
<p>
A docking manager supporting multiple controls per docksite (aka a layout) 
can be found in the <file>ldocktree.pas</file> unit.
</p>
<p>
TAnchorDockManager which supports multiple controls with a more flexible 
layout, store and restore, and more options can be found in the 
<file>anchordocking</file> package.
</p>
</descr>
<seealso>
<link id="TDockManager"/>
<link id="#lcl.ldocktree.TLazDockTree">TLazDockTree</link>
</seealso>
</element>

<element name="TDockTree.FBorderWidth">
<short>The width of the border around a dock zone.</short>
<descr/>
<seealso/>
</element>

<element name="TDockTree.FDockSite" link="#lcl.controls.TDockTree.DockSite"/>
<element name="TDockTree.FDockZoneClass" link="#lcl.controls.TDockTree.DockZoneClass"/>
<element name="TDockTree.FFlags"/>
<element name="TDockTree.FUpdateCount" link="#lcl.controls.TDockTree.BeginUpdate"/>

<element name="TDockTree.DeleteZone">
<short>Destroys the dock zone and its child zones.</short>
<descr/>
<seealso/>
</element>
<element name="TDockTree.DeleteZone.Zone">
<short/>
</element>

<element name="TDockTree.SetDockSite" link="#lcl.controls.TDockTree.DockSite"/>
<element name="TDockTree.SetDockSite.AValue"/>

<element name="TDockTree.FRootZone" link="#lcl.controls.TDockTree.RootZone"/>

<element name="TDockTree.HitTest">
<short>
Returns the control and the part of the dockzone at the given coordinates.
</short>
<descr/>
<seealso/>
</element>
<element name="TDockTree.HitTest.Result">
<short>The docked control.</short>
</element>
<element name="TDockTree.HitTest.MousePos">
<short>The client coordinates.</short>
</element>
<element name="TDockTree.HitTest.HTFlag">
<short>Returns the zone part at MousePos.</short>
</element>

<element name="TDockTree.PaintDockFrame">
<short>Paints the dock header of the zone containing AControl.</short>
<descr/>
<seealso/>
</element>
<element name="TDockTree.PaintDockFrame.ACanvas">
<short/>
</element>
<element name="TDockTree.PaintDockFrame.AControl">
<short/>
</element>
<element name="TDockTree.PaintDockFrame.ARect">
<short/>
</element>

<element name="TDockTree.UpdateAll">
<short>
Updates the internal TDockTreeFlags to reflect the update status for the 
control
</short>
<descr>
<p>
<var>UpdateAll</var> is a procedure used to update the internal 
<var>TDockTreeFlags</var> member to reflect the current update status for the 
control. UpdateAll checks an internal counter, incremented in 
<var>BeginUpdate</var>, to see if <var>dtfUpdateAllNeeded</var> needs to be 
included in or excluded from the set of flag values. It is included when the 
update count is greater than <b>0</b> (<b>zero</b>). Otherwise, it is 
excluded from the set.
</p>
<p>
UpdateAll is called from the <var>EndUpdate</var> method.
</p>
</descr>
<seealso>
<link id="TDockTree.BeginUpdate"/>
<link id="TDockTree.EndUpdate"/>
<link id="TDockTreeFlags"/>
<link id="TDockTreeFlag"/>
</seealso>
</element>

<element name="TDockTree.SetDockZoneClass" link="#lcl.controls.TDockTree.DockZoneClass"/>
<element name="TDockTree.SetDockZoneClass.AValue"/>

<element name="TDockTree.Create">
<short>Constructor for the class instance.</short>
<descr>
<p>
Create is the overridden constructor for the class instance. TheDockSite 
contains the windowed control handled in the docking tree. Create calls the 
inherited constructor using TheDockSite as the owner for the class instance.
</p>
<p>
Creates allocates resources needed for the RootZone property, and sets the 
value for its border width to 4.
</p>
</descr>
<seealso>
<link id="TDockTree.RootZone"/>
<link id="TDockManager"/>
</seealso>
</element>
<element name="TDockTree.Create.TheDockSite">
<short>The window control to be managed.</short>
</element>

<element name="TDockTree.Destroy">
<short>Destructor for the class instance.</short>
<descr>
<p>
Frees resources allocated to the RootZone property, and calls the inherited 
destructor.
</p>
</descr>
<seealso/>
</element>

<element name="TDockTree.BeginUpdate">
<short>Starts an update process for the class instance.</short>
<descr>
<p>
<var>BeginUpdate</var> is an overridden method in TDockTree. It increments 
the internal update counter for the class. It is used to consolidate calls to 
the UpdateAll method until the internal counter reaches zero (0).
</p>
</descr>
<seealso>
<link id="TDockManager.BeginUpdate"/>
<link id="TDockManager.EndUpdate"/>
<link id="TDockTree.UpdateAll"/>
</seealso>
</element>

<element name="TDockTree.EndUpdate">
<short>Finishes an update process for the class instance.</short>
<descr>
<p>
<var>EndUpdate</var> is an overridden method in TDockTree. BeginUpdate and 
EndUpdate are used to consolidate calls to the <var>UpdateAll</var> method. 
EndUpdate decrements the internal update counter, and when it reaches zero 
(0) calls UpdateAll to remove dtfUpdateAllNeeded from the docking tree flags.
</p>
</descr>
<seealso>
<link id="TDockManager.EndUpdate"/>
<link id="TDockManager.BeginUpdate"/>
<link id="TDockTree.UpdateAll"/>
<link id="TDockTreeFlags"/>
<link id="TDockTreeFlag"/>
</seealso>
</element>

<element name="TDockTree.AdjustDockRect">
<short>Adjusts the zone rectangle for AControl.</short>
<descr>
<p>
ARect initially describes the dockzone into which the control is docked. From 
that area the zone decoration is excluded, so that ARect describes the area 
reserved for the docked control.
</p>
<p>
AdjustDockRect is not part of the general docking model. It can implemented 
and used for any purpose in a dock tree manager. Most docking managers will 
replace it by a method with more arguments, that allow to identify the zone 
and its properties immediately.
</p>
</descr>
<seealso/>
</element>
<element name="TDockTree.AdjustDockRect.AControl">
<short/>
</element>
<element name="TDockTree.AdjustDockRect.ARect">
<short/>
</element>

<element name="TDockTree.GetControlBounds" link="#lcl.controls.TDockManager.GetControlBounds"/>
<element name="TDockTree.GetControlBounds.AControl"/>
<element name="TDockTree.GetControlBounds.ControlBounds"/>

<element name="TDockTree.InsertControl">
<short>
Positions <var>DropCtl</var> relative <var>Control</var>, using the alignment 
specified by <var>InsertAt</var>.
</short>
<descr>
<p>
<var>InsertControl</var> determines the layout and appearance of the just 
docked control, forcing a repaint of the container control if necessary.
</p>
<p>
When <var>SetReplacingControl</var> has been called with a non-<b>Nil</b> 
Control before, the dropped control only should replace that control.
</p>
<p>
A tree docking manager organizes the docksite into layers of horizontal or 
vertical orientation. As long as no more than one control is docked into a 
docksite, the tree has no orientation at all. The second docked control 
determines the orientation of the docksite and the dock tree. All further 
drops are either isogonal (in direction of the zone orientation) or 
orthogonal (opposite to the zone orientation). On an isogonal drop a new leaf 
zone is created for the dropped control, as a sibling of the already existing 
child zones. On an orthogonal drop the zone containing the DropControl 
becomes the root of another subtree, whose initial members are the leaf zones 
for <var>Control</var> and <var>DropCtl</var>.
</p>
<p>
One value of <var>InsertAt</var> (<var>alCustom</var>) is reserved for 
notebook docking, where <var>DropCtl</var> is replaced by a tabbed notebook, 
and <var>Control</var> and <var>DropCtl</var> are moved into pages of the 
notebook. The notebook is a docksite of its own, further drops into the 
notebook are handled by the notebook itself, the <var>DockManager</var> of 
the host docksite is not involved.
</p>
</descr>
<seealso>
<link id="TDockManager.RemoveControl"/>
</seealso>
</element>
<element name="TDockTree.InsertControl.AControl">
<short>The control beneath which to place DropControl.</short>
</element>
<element name="TDockTree.InsertControl.InsertAt">
<short>How to insert DropControl.</short>
</element>
<element name="TDockTree.InsertControl.DropControl">
<short>The control to add.</short>
</element>

<element name="TDockTree.LoadFromStream">
<short>Has an empty implementation in TDockTree.</short>
<descr/>
<seealso/>
</element>
<element name="TDockTree.LoadFromStream.SrcStream">
<short/>
</element>

<element name="TDockTree.MessageHandler">
<short>Has an empty implementation in TDockTree.</short>
<descr/>
<seealso/>
</element>
<element name="TDockTree.MessageHandler.Sender">
<short/>
</element>
<element name="TDockTree.MessageHandler.Message">
<short/>
</element>

<element name="TDockTree.PositionDockRect" link="#lcl.controls.TDockManager.PositionDockRect"/>
<element name="TDockTree.PositionDockRect.AClient"/>
<element name="TDockTree.PositionDockRect.DropCtl"/>
<element name="TDockTree.PositionDockRect.DropAlign"/>
<element name="TDockTree.PositionDockRect.DockRect"/>

<element name="TDockTree.RemoveControl" link="#lcl.controls.TDockManager.RemoveControl"/>
<element name="TDockTree.RemoveControl.AControl"/>

<element name="TDockTree.SaveToStream" link="#lcl.controls.TDockManager.SaveToStream"/>
<element name="TDockTree.SaveToStream.DestStream"/>

<element name="TDockTree.SetReplacingControl" link="#lcl.controls.TDockManager.SetReplacingControl"/>
<element name="TDockTree.SetReplacingControl.AControl"/>

<element name="TDockTree.ResetBounds" link="#lcl.controls.TDockManager.ResetBounds"/>
<element name="TDockTree.ResetBounds.Force"/>

<element name="TDockTree.PaintSite" link="#lcl.controls.TDockManager.PaintSite"/>
<element name="TDockTree.PaintSite.DC"/>

<element name="TDockTree.DumpLayout">
<short>Stores the layout in a file.</short>
</element>
<element name="TDockTree.DumpLayout.FileName">
<short/>
</element>

<element name="TDockTree.DockZoneClass">
<short>The class type for the dock zones in this tree.</short>
<descr/>
<seealso/>
</element>

<element name="TDockTree.DockSite">
<short>
The parent control whose docked clients are managed.
</short>
<descr/>
<seealso/>
</element>

<element name="TDockTree.RootZone">
<short>The root zone for the DockTree.</short>
<descr/>
<seealso/>
</element>

<element name="DockSplitterClass">
<short>
Class type used to create new splitter class instances.
</short>
<descr>
<p>
Normally contains a reference to the <var>TSplitter</var> class, as assigned 
in the initialization section for the <file>extctrls.pp</file> unit.
</p>
</descr>
<seealso>
<link id="#lcl.extctrls.TSplitter">TSplitter</link>
</seealso>
</element>

<element name="TMouse">
<short>Provides access to properties of the Mouse.</short>
<descr>
<p>
Contains information about the current mouse position, whether messages are 
captured by a window, whether it is dragging an object, and how far the mouse 
must move before a control starts dragging. TMouse is the type used for the 
Mouse global unit variable.
</p>
</descr>
<seealso>
<link id="Mouse"/>
</seealso>
</element>

<element name="TMouse.FWheelScrollLines"/>
<element name="TMouse.SetCapture" link="#lcl.controls.TMouse.Capture"/>
<element name="TMouse.SetCapture.Value"/>
<element name="TMouse.GetCapture" link="#lcl.controls.TMouse.Capture"/>
<element name="TMouse.GetCapture.Result"/>
<element name="TMouse.GetCursorPos" link="#lcl.controls.TMouse.CursorPos"/>
<element name="TMouse.GetCursorPos.Result"/>
<element name="TMouse.GetIsDragging" link="#lcl.controls.TMouse.IsDragging"/>
<element name="TMouse.GetIsDragging.Result"/>
<element name="TMouse.SetCursorPos" link="#lcl.controls.TMouse.CursorPos"/>
<element name="TMouse.SetCursorPos.AValue"/>
<element name="TMouse.GetWheelScrollLines" link="#lcl.controls.TMouse.WheelScrollLines"/>
<element name="TMouse.GetWheelScrollLines.Result"/>
<element name="TMouse.GetDragImmediate" link="#lcl.controls.TMouse.DragImmediate"/>
<element name="TMouse.GetDragImmediate.Result"/>
<element name="TMouse.SetDragImmediate" link="#lcl.controls.TMouse.DragImmediate"/>
<element name="TMouse.SetDragImmediate.AValue"/>
<element name="TMouse.GetDragThreshold" link="#lcl.controls.TMouse.DragThreshold"/>
<element name="TMouse.GetDragThreshold.Result"/>
<element name="TMouse.SetDragThreshold" link="#lcl.controls.TMouse.DragThreshold"/>
<element name="TMouse.SetDragThreshold.AValue"/>

<element name="TMouse.Capture">
<short>
Handle for the control with mouse capture.
</short>
<descr>
<p>
<var>Capture</var> is a <var>HWND</var> property which contains the handle for 
the control which has the mouse capture. Its value is read from the LCL 
interface (and ultimately the widgetset class instance).
</p>
<p>
Setting a new value for the property causes either SetCapture or 
ReleaseCapture to be called in the LCL interface (or widgetset class 
instance). When set to 0 (the unassigned handle value), ReleaseCapture is 
called. Otherwise, SetCapture is called to assign the new handle value to the 
widget.
</p>
<remark>
For the macOS Carbon widgetset, release capture is not supported.
</remark>
</descr>
</element>

<element name="TMouse.CursorPos">
<short>
The screen position for the mouse cursor.
</short>
<descr>
<p>
<var>CursorPos</var> is a <var>TPoint</var> property which contains the screen 
coordinates where the mouse pointer is located. The X and Y members in the 
TPoint type contain the horizontal and vertical screen coordinates, 
respectively, and are read from and written to the widgetset class instance.
</p>
<p>
When reading values in the property, the X and Y members may return 0 if the 
widgetset is unable to return a TPoint instance.
</p>
<remark>
For the macOS Carbon widgetset, changing the values in CursorPos does not 
triggering OnMoveMove events in a form or control.
</remark>
</descr>
</element>

<element name="TMouse.IsDragging">
<short><b>True</b> while dragging an object.</short>
<descr/>
<seealso/>
</element>

<element name="TMouse.WheelScrollLines">
<short>
The number of lines to scroll with every notch or unit on the mouse wheel
</short>
<descr/>
<seealso/>
</element>

<element name="TMouse.DragImmediate">
<short>
Does dragging start immediately (<b>True</b>), or only after a mouse move?
</short>
<descr/>
</element>

<element name="TMouse.DragThreshold">
<short>
The minimum distance the mouse must move before dragging starts (in delayed 
mode)
</short>
<descr>
<p>
The default value is 5 (pixels).
</p>
</descr>
</element>

<element name="AnchorAlign">
<short>Array with sets of anchors used for a given alignment option.</short>
<descr>
<p>
<var>AnchorAlign</var> is an array constant that contains elements with 
<var>TAnchors</var> set values. Values in AnchorAlign are indexed by 
<var>TAlign</var> enumeration values. This allows the TAlign value to 
retrieve the set of Anchors used for the specified align option.
</p>
<p>
For example:
</p>
<code>
AControl.Align := AnchorAlign[alRight]; // contains [akRight, akTop, akBottom]
</code>
</descr>
<seealso/>
</element>

<element name="MainAlignAnchor">
<short>
Used in the AnchorDocking package for the Lazarus IDE.
</short>
<descr/>
<seealso/>
</element>

<element name="OppositeAnchor">
<short>
Used in the AnchorDocking package for the Lazarus IDE.
</short>
<descr/>
<seealso/>
</element>

<element name="ClockwiseAnchor">
<short>
Used in the AnchorDocking package for the Lazarus IDE.
</short>
<descr/>
<seealso/>
</element>

<element name="DefaultSideForAnchorKind">
<short>
Provides adjacent edges where controls are aligned for a given anchor kind.
</short>
<descr>
<p>
<var>DefaultSideForAnchorKind</var> is an array type which contains 
TAnchorSideReference values, The values are accessed using the enumeration 
values in TAnchorKind, and indicate the edge on a control where an adjacent 
control is aligned for the anchor kind. For example:
</p>
<table>
<tr>
<td>
<b>Anchor Kind</b>
</td>
<td>
<b>Default Side</b>
</td>
</tr>
<tr>
<td>
akTop
</td>
<td>
asrBottom
</td>
</tr>
<tr>
<td>
akLeft
</td>
<td>
asrBottom
</td>
</tr>
<tr>
<td>
akRight
</td>
<td>
asrTop
</td>
</tr>
<tr>
<td>
akBottom
</td>
<td>
asrTop
</td>
</tr>
</table>
<p>
Used in the <file>ldocktree</file> unit and in the TControl.AnchorToNeighbour 
method.
</p>
</descr>
<seealso/>
</element>

<element name="AnchorReferenceSide">
<short>
Not used in the current LCL version.
</short>
<descr/>
<seealso/>
</element>

<element name="FindDragTarget">
<short>Gets the drag target at the specified screen position.</short>
<descr>
<p>
Disabled controls <b>should</b> be excluded, but are not due to an bug in 
<var>FindControlAtPosition</var>.
</p>
</descr>
<seealso>
<link id="FindControlAtPosition"/>
</seealso>
</element>
<element name="FindDragTarget.Result">
<short>The control at Position; <b>Nil</b> if none.</short>
</element>
<element name="FindDragTarget.Position">
<short>The screen position.</short>
</element>
<element name="FindDragTarget.AllowDisabled">
<short>Also finds disabled controls, if <b>True</b>.</short>
</element>

<element name="FindControlAtPosition">
<short>
Gets the control at the specified screen position.
</short>
<descr>
<p>
<var>FindControlAtPosition</var> is a <var>TControl</var> function used to 
get the control at the specified screen position. When 
<var>AllowDisabled</var> is <b>True</b>, a disabled control can also be 
located in the routine. In the current implementation, AllowDisabled is 
ignored (assumed to be <b>True</b>). First a window at the given screen 
position is searched, then a control within it.
</p>
</descr>
<seealso>
<link id="TControl"/>
<link id="FindLCLWindow"/>
<link id="TWinControl.ControlAtPos"/>
<link id="TControlAtPosFlag"/>
</seealso>
</element>
<element name="FindControlAtPosition.Result">
<short>
The control found at the specified Position; <b>Nil</b> when not found.
</short>
</element>
<element name="FindControlAtPosition.Position">
<short>The screen position examined in the routine.</short>
</element>
<element name="FindControlAtPosition.AllowDisabled">
<short>Finds disabled controls when <b>True</b>.</short>
</element>

<element name="FindLCLWindow">
<short>
Find the window and its owning control at the given screen coordinates.
</short>
<descr>
<p>
<var>FindLCLWindow</var> is a <var>TWinControl</var> function used to find 
the window (and its owner control) at the specified screen coordinates.
</p>
<p>
FindLCLWindow gets the Handle for the window and checks to ensure it is 
enabled. When it is not enabled, or <var>AllowDisabled</var> is <b>False</b>, 
parent handles are examined until a suitable window is located. 
FindOwnerControl is called for the handle to get the return value. The return 
value is <b>Nil</b> if a Window was not found at the specified position.
</p>
</descr>
<seealso/>
</element>
<element name="FindLCLWindow.Result">
<short>
The control that owns the window at the specified screen position; <b>Nil</b> 
when a window is not found.
</short>
</element>
<element name="FindLCLWindow.ScreenPos">
<short>TPoint with the screen coordinates examined in the routine.</short>
</element>
<element name="FindLCLWindow.AllowDisabled">
<short>Allows a disabled window to be returned.</short>
</element>

<element name="FindControl">
<short>Return the TWinControl for the given Handle.</short>
<descr>
<p>
The result is very interface specific; use FindOwnerControl when Handle may 
be a non-TWinControl handle. Handle can also be a child handle, and does not 
need to be the Handle property of the Result.
</p>
<p>
<b>Important</b>: In most cases, Result.Handle and the Handle parameter value 
are <b>not</b> the same.
</p>
</descr>
<seealso>
<link id="FindOwnerControl"/>
<link id="#lcl.lclintf.GetProp">GetProp</link>
</seealso>
</element>
<element name="FindControl.Result">
<short>
TWinControl with the specified handle, or <b>Nil</b> if the handle is not 
found.
</short>
</element>
<element name="FindControl.Handle">
<short>
Handle for the control (or child control) used to locate the control in the 
return value.
</short>
</element>

<element name="FindOwnerControl">
<short>
Returns the TWinControl for the given Handle; the parent control for a 
non-TWinControl Handle.
</short>
<descr>
<p>
Handle can also be a child handle (of a TControl), in which case the returned 
control is the parent of the desired control. Parent, not Owner as suggested 
by the function name!
</p>
<remark>
The function recursively tries GetParent(Handle), so the result depends on 
the implementation (meaning) of a parent handle.
</remark>
</descr>
</element>
<element name="FindOwnerControl.Result">
<short/>
</element>
<element name="FindOwnerControl.Handle">
<short/>
</element>

<element name="FindLCLControl">
<short>
Returns the TControl currently visible at the specified screen position.
</short>
<descr>
<p>
The result is not reliable during resizing.
</p>
</descr>
<seealso/>
</element>
<element name="FindLCLControl.Result">
<short>
Control visible at the specified screen coordinates. The active windowed 
control (or form) is returned if a control is not found at the specified 
position.
</short>
</element>
<element name="FindLCLControl.ScreenPos">
<short>
TPoint instance with the screen coordinates for the control located in the 
method.
</short>
</element>

<element name="SendAppMessage" link="#LCL.LCLProc.SendApplicationMessage"/>
<element name="SendAppMessage.Result"/>
<element name="SendAppMessage.Msg"/>
<element name="SendAppMessage.WParam"/>
<element name="SendAppMessage.LParam"/>

<element name="MoveWindowOrg">
<short>Moves the origin for a windowed control.</short>
<descr>
<p>
<var>MoveWindowOrg</var> is a procedure used to move the origin for a 
windowed control to the specified position. <var>dc</var> contains the device 
context for the Window handle used in the routine. <var>X</var> and 
<var>Y</var> contain the new coordinates in pixels used as the origin (Left 
and Top respectively) for canvas drawing operations.
</p>
</descr>
<seealso/>
</element>
<element name="MoveWindowOrg.dc">
<short>Device context updated in the routine.</short>
</element>
<element name="MoveWindowOrg.X">
<short>Left coordinate for the new window origin.</short>
</element>
<element name="MoveWindowOrg.Y">
<short>Top coordinate for the new window origin.</short>
</element>

<element name="RecreateWnd">
<short>
Creates (or recreates) the widgetset class instance for a TWinControl.
</short>
<descr>
<p>
This function was originally a member of TWinControl.
</p>
<p>
From a VCL point of view, that made perfectly sense since the VCL knows when 
a Win32 widget has to be recreated when properties have changed.
</p>
<p>
The LCL, however, does not know when properties values are changed. But the 
widgetset does. To avoid the old VCL behavior, and to provide a central 
function for use in the widgetset, it has been moved here.
</p>
</descr>
<seealso/>
</element>
<element name="RecreateWnd.AWinControl">
<short/>
</element>

<element name="DefaultDockManagerClass">
<short>
The default class used to create a DockManager in <link 
id="TWinControl.CreateDockManager"/>.
</short>
<seealso>
<link id="TDockManager"/>
</seealso>
</element>

<element name="CancelDrag">
<short>Cancels an active drag operation.</short>
<descr>
<p>
<var>CancelDrag</var> is a procedure used to cancel an active drag operation. 
<var>CancelDrag</var> calls the <var>DragStop</var> method in the currently 
active <var>DragManager</var>.
</p>
<remark>
No actions are performed in the routine when DragManager has not been 
assigned (contains <b>Nil</b>), or when DragManager returns <b>False</b> from 
its IsDragging method.
</remark>
</descr>
<seealso>
<link id="DragManager"/>
<link id="TDragManager.DragStop"/>
<link id="TDragManager.IsDragging"/>
</seealso>
</element>

<element name="SetCaptureControl">
<short>
Set the mouse capture to the specified control, or one of its children, at 
the given coordinates.
</short>
<descr>
<p>
<var>SetCaptureControl</var> is an overloaded procedure in 
<file>controls.pp</file>. It ensures that the CaptureControl variable 
maintained in the LCL is updated when an control receives or loses the mouse 
input focus.
</p>
<p>
The overloaded variants allow the new mouse capture control to be specified 
as either a TControl or a TWinControl instance. No actions are performed in 
the routine if the specified control is already the CaptureControl.
</p>
<p>
If the new capture control is unassigned (<b>Nil</b>), the value in 
CaptureControl is cleared and the ReleaseCapture routine is called. No 
additional actions are performed in the routine.
</p>
<p>
Otherwise, the control class is used to determine the actions needed. For a 
TWinControl instance, the ControlAtPos method is called determine if a child 
control is active at the specified position and the new capture control. For 
a TControl instance, which does not have a handle, the Parent control is 
used as the new capture control.
</p>
<p>
ReleaseCapture is called to remove mouse capture for the previous control. 
The SetCapture routine in the LCL interface is called to change the mouse 
capture to the control with the specified handle.
</p>
<p>
Use GetCaptureControl to retrieve the control which currently has the mouse 
capture.
</p>
</descr>
<seealso>
<link id="GetCaptureControl"/>
</seealso>
</element>
<element name="SetCaptureControl.Control">
<short>
TControl instance (or <b>Nil</b>) representing the control for the mouse 
capture.
</short>
</element>
<element name="SetCaptureControl.AWinControl">
<short>
TWinControl instance (or <b>Nil</b>) representing the windowed control for 
the mouse capture.
</short>
</element>
<element name="SetCaptureControl.Position">
<short>
TPoint instance with the coordinates for the mouse input.
</short>
</element>

<element name="GetCaptureControl">
<short>
Returns the TControl instance with mouse capture enabled.
</short>
<descr>
<p>
Please note: For the interface, only a Handle for TWinControl can capture the 
mouse. The LCL extends this to allow TControl to capture the mouse.
</p>
</descr>
<seealso/>
</element>
<element name="GetCaptureControl.Result">
<short>
The control with the mouse capture, or <b>Nil</b> when a capture control is 
not set for the widgetset class.
</short>
</element>

<element name="NewStyleControls">
<short>Used in SynEdit.</short>
<descr>
<var>NewStyleControls</var> is a <var>Boolean</var> variable. Currently used 
only by SynEdit in <file>synedit.pp</file>.
</descr>
<seealso/>
</element>

<element name="Mouse">
<short>The global TMouse instance for the unit.</short>
<descr>
<p>
<var>Mouse</var> is a <var>TMouse</var> variable with the singleton used to 
access mouse information in the application. This includes the handle for the 
capture control, the current pointer position, as well as drag and scroll 
settings used in an application.
</p>
<p>
The class instance is created in the initialization section for the unit, and 
freed in the finalization section.
</p>
</descr>
<seealso>
<link id="TMouse"/>
</seealso>
</element>

<element name="CursorToString">
<short>
Returns a string with the name for the cursor in the integer constant.
</short>
<descr>
<p>
Calls CursorToIdent to find correct entry in look-up table.
</p>
</descr>
<seealso>
<link id="CursorToIdent"/>
</seealso>
</element>
<element name="CursorToString.Result">
<short>
Returns a string with the name of the cursor type corresponding to the 
integer constant, or a value like '%-31' when Cursor is not found in the 
look-up table.
</short>
</element>
<element name="CursorToString.Cursor">
<short>
Numeric constant from the TCursor range converted to a string in the routine.
</short>
</element>

<element name="StringToCursor">
<short>
<var>StringToCursor</var> - returns the cursor value corresponding to the 
name supplied.
</short>
<descr>
<p>
<var>StringToCursor</var> - returns the cursor value corresponding to the 
name supplied.
</p>
<p>
Finds the numeric cursor value corresponding to the name <var>S</var> in the 
cursor look-up table.
</p>
</descr>
</element>
<element name="StringToCursor.Result">
<short>The numeric cursor value from the look-up table.</short>
</element>
<element name="StringToCursor.S">
<short>The name of the cursor for which the numeric value is sought.</short>
</element>

<element name="GetCursorValues">
<short>
Calls the specified procedure for each of the cursor identifiers.
</short>
<descr/>
<seealso/>
</element>
<element name="GetCursorValues.Proc">
<short>String procedure called in the routine. </short>
</element>

<element name="CursorToIdent">
<short>
Uses a look-up table to find the cursor identifier corresponding to an Integer 
cursor constant.
</short>
<descr>
<p>
<var>CursorToIdent</var> gets the identifier name for a cursor shape specified 
as an Integer value. Cursor contains one of the Integer constants which 
represent a value in the TCursor type. Ident is the String with the identifier 
name for the cursor shape.
</p>
<p>
For example:
</p>
<code>
// var CursorName: String; IsOk: Boolean;
CursorName := '';
IsOk := CursorToIdent(crHourGlass, CursorName); 
// CursorName returns 'crHourGlass'
</code>
<p>
CursorToIdent calls the IntToIdent routine in the RTL <file>Classes</file> 
unit to get both the return value and the value for the Ident argument. 
The CursorIdents implementation constant is used as the mapping table for the 
integer and string values.
</p>
<p>
If Cursor is not found in the CursorIdents constant, the return value is 
<b>False</b>. If the numeric constant is not found in the look-up 
table, the value in Ident is not specified (or changed).
</p>
<p>
Use IdentToCursor or StringToCursor to convert the identifier name value back 
to an Integer value.
</p>
<p>
CursorToIdent is used in the implementation of the CursorToString routine.
</p>
</descr>
<seealso>
<link id="IdentToCursor"/>
<link id="StringToCursor"/>
<link id="CursorToString"/>
<link id="TCursor"/>
<link id="#rtl.classes.IntToIdent">IntToIdent</link>
</seealso>
</element>
<element name="CursorToIdent.Result">
<short>
Returns <b>True</b> if a valid identifier is found in the look-up table.
</short>
</element>
<element name="CursorToIdent.Cursor">
<short>
Integer constant for the cursor shape (like crHourGlass).
</short>
</element>
<element name="CursorToIdent.Ident">
<short>
Returns the string with the identifier name for the specified cursor shape 
(like 'crHourGlass').
</short>
</element>

<element name="IdentToCursor">
<short>
Converts an identifier name for a cursor shape to its value as an Integer.
</short>
<descr>
<p>
<var>IdentToCursor</var> converts the identifier name for a cursor shape to 
its Integer equivalent.
</p>
<p>
Ident contains the name for the cursor shape. The Cursor argument contains the 
TCursor value for the specified identifier name.
</p>
<p>
The return value is <b>True</b> if Ident is found in the CursorIdents look-up 
table. The value in Cursor is unspecified (and unchanged) when the return 
value is <b>False</b>.
</p>
<p>
For example:
</p>
<code>
// var CursorVal: Integer; IsOk: Boolean;
CursorVal := crDefault;
IsOk := IdentToCursor('crHourGlass', CursorVal);
// CursorVal contains the crHourGlass constant
</code>
<p>
IdenttoCursor calls the IdentToInt routine in the RTL <file>Classes</file> 
unit to get both the return value and the value for the Cursor argument.
</p>
<p>
Use CursorToString or InttoIdent routines to return the Integer value to its 
string representation.
</p>
</descr>
<seealso>
<link id="CursorToString"/>
<link id="StringToCursor"/>
<link id="TCursor"/>
<link id="#rtl.classes.IntToIdent">IntToIdent</link>
<link id="#rtl.classes.IdentToInt">IdentToInt</link>
</seealso>
</element>
<element name="IdentToCursor.Result">
<short>
Returns <b>True</b> if a valid entry was found for the identifier name in the 
look-up table.
</short>
</element>
<element name="IdentToCursor.Ident">
<short>The identifier name for the cursor shape, like 'crHourGlass'.</short>
</element>
<element name="IdentToCursor.Cursor">
<short>The numeric value of the named cursor, like crHourGlass.</short>
</element>

<element name="CheckTransparentWindow">
<short>
Checks whether the handle for a windowed control (or a parent control) is 
transparent.
</short>
<descr>
<p>
<var>CheckTransparentWindow</var> is procedure used to check whether the 
handle for a windowed control (or a parent control) is transparent. 
CheckTransparentWindow uses the current mouse position to locate controls or 
forms under the mouse pointer. The LM_NCHITTEST message is performed for 
AWinControl to determine if the handle is drawn transparently. Additional 
Forms in the Z-Order are visited until an opaque windowed control is located. 
Parent controls are searched too (when needed).
</p>
<p>
CheckTransparentWindow updates the values in Handle and AWinControl to 
reflect the results from the search. When an overlayed control is not 
located, the value in Handle is set to 0, and AWinControl is set to 
<b>Nil</b>.
</p>
</descr>
<version>
Modified in LCL version 4.0 to use the TLCLHandle type instead of the 
deprecated THandle type for the Handle argument.
</version>
<seealso>
<link id="TControl.Parent"/>
<link id="TMouse.CursorPos"/>
<link id="#lcl.forms.TScreen.CustomFormZOrderCount">TScreen.CustomFormZOrderCount</link>
<link id="#lcl.lcltype.TLCLHandle">TLCLHandle</link>
</seealso>
</element>
<element name="CheckTransparentWindow.Handle">
<short>
Handle for the control (or parent) found for the specified windowed control.
</short>
</element>
<element name="CheckTransparentWindow.AWinControl">
<short>
Handle for the windowed control examined in the routine.
</short>
</element>

<element name="CheckMouseButtonDownUp">
<short>
Checks for mouse click events for the specified control.
</short>
<descr>
<p>
<var>CheckMouseButtonDownUp</var> is a <var>Cardinal</var> function used to 
check for mouse down or up events for the control represented by the handle in 
AWinHandle. The return value contains the Word value used in the Msg member in 
a TLMMouse mouse message.
</p>
<p>
The LastMouse parameter is updated with the most recent mouse event 
information examined and used in the method.
</p>
<p>
CheckMouseButtonDownUp consolidates mouse down events (single, double, triple, 
and quadruple) into a single value used in a mouse message, and updates 
LastMouse when needed.
</p>
<p>
AWinControl contains the control with the handle where the mouse event(s) 
occurred.
</p>
<p>
At run-time, multi-click events are adjusted to the ControlStyle specified in 
the control (or one of its children) including:
</p>
<ul>
<li>csDoubleClicks</li>
<li>csTripleClicks</li>
<li>csQuadClicks</li>
</ul>
<p>
If the target control does not allow one of the multi-click events, the click 
count in LastMouse is updated accordingly.
</p>
<p>
At design-time, only Single and Double click mouse events are handled.
</p>
<p>
CheckMouseButtonDownUp is used in the callback routine for a widgetset class 
when a mouse event message is created and passed to the class instance.
</p>
</descr>
<version>
Modified in LCL version 4.0 to use the TLCLHandle type instead of the 
deprecated THandle type in the AWinHandle argument.
</version>
<seealso/>
</element>
<element name="CheckMouseButtonDownUp.Result">
<short>
Value used as the Msg member in a mouse message.
</short>
</element>
<element name="CheckMouseButtonDownUp.AWinHandle">
<short>
Handle for the control where the mouse events were detected.
</short>
</element>
<element name="CheckMouseButtonDownUp.AWinControl">
<short>
Control with the specified handle.
</short>
</element>
<element name="CheckMouseButtonDownUp.LastMouse">
<short>
Mouse information for the mouse event examined in the routine.
</short>
</element>
<element name="CheckMouseButtonDownUp.AMousePos">
<short>
Position where the last mouse event occurred.
</short>
</element>
<element name="CheckMouseButtonDownUp.AButton">
<short>
Mouse button for the last mouse event.
</short>
</element>
<element name="CheckMouseButtonDownUp.AMouseDown">
<short>
<b>True</b> if the mouse event is a mouse down event. <b>False</b> for a mouse 
up event.
</short>
</element>

<element name="GetKeyShiftState">
<short>Gets a set of state values for current modifier keys.</short>
<descr>
<p>
<var>GetKeyShiftState</var> is a <var>TShiftState</var> function used to get 
a set with the current state values for modifier keys. GetKeyShiftState calls 
<var>GetKeyState</var> to capture the values in the set for the following 
virtual keyboard keys:
</p>
<dl>
<dt>VK_CONTROL</dt>
<dd>Includes ssCtrl when the Control key is pressed</dd>
<dt>VK_SHIFT</dt>
<dd>Includes ssShift when the Control key is pressed</dd>
<dt>VK_MENU</dt>
<dd>Includes ssAlt when the Alt key is pressed</dd>
<dt>VK_LWIN or VK_RWIN</dt>
<dd>Includes ssMeta when one of the WIN keys (or Alt+GR on Mac) is 
pressed</dd>
</dl>
<p>
The return value is an empty set (<b>[]</b>) when none of the virtual keys 
have a non-zero value.
</p>
</descr>
<seealso/>
</element>
<element name="GetKeyShiftState.Result">
<short>
Set of Shift state values active for the virtual keys, or an empty set when 
none of the keys are active.
</short>
</element>

<element name="AdjustBorderSpace">
<short>
Adjusts the border space around the control to the client rectangle.
</short>
<descr>
<p>
<var>AdjustBorderSpace</var> is an overloaded routine used to determine the 
space reserved for borders on the corresponding edges of a control. 
AdjustBorderSpace is called from methods in a widgetset class when the its 
bounds and constraints are realized and child controls are aligned to the new 
dimensions.
</p>
<p>
The overloaded variants allow the border spaces to be specified as individual 
Integer values or passed in a TRect instance.
</p>
</descr>
<seealso/>
</element>
<element name="AdjustBorderSpace.RemainingClientRect">
<short>
TRect instance with the unused client area in a control.
</short>
</element>
<element name="AdjustBorderSpace.CurBorderSpace">
<short>
TRect instance with the space reserved for borders on the corresponding 
edges of a control.
</short>
</element>
<element name="AdjustBorderSpace.Left">
<short>
Space reserved on the left edge of the client area.
</short>
</element>
<element name="AdjustBorderSpace.Top">
<short>
Space reserved on the top edge of the client area.
</short>
</element>
<element name="AdjustBorderSpace.Right">
<short>
Space reserved on the right edge of the client area.
</short>
</element>
<element name="AdjustBorderSpace.Bottom">
<short>
Space reserved on the bottom edge of the client area.
</short>
</element>
<element name="AdjustBorderSpace.Space">
<short>
TRect instance with the border space reserved on the corresponding edges of a 
control.
</short>
</element>

<element name="IsColorDefault">
<short>
Determines if the color for the control is the system default (GTK).
</short>
<descr>
<p>
Used by GTK-based widgetset classes to determine if the color in a control 
needs to be compared to the SYS_COLOR_BASE value used in the widgetset.
</p>
</descr>
<seealso/>
</element>
<element name="IsColorDefault.Result">
<short>
<b>True</b> if the specified control does not have an explicit value other 
than the default color value ($80000000).
</short>
</element>
<element name="IsColorDefault.AControl">
<short>
Control with the color value examined in the routine.
</short>
</element>

<element name="BidiFlipAlignment">
<short>Gets the inverse alignment value when BiDiMode is enabled.</short>
<descr>
<p>
Applies to TAlignment value taLeftJustify and taRightJustify. taCenter is 
always taCenter regardless of BidiMode.
</p>
</descr>
<seealso/>
</element>
<element name="BidiFlipAlignment.Result">
<short>
TAlignment value adjusted for the BidiAlignment in Flip.
</short>
</element>
<element name="BidiFlipAlignment.Alignment">
<short>TAlignment value converted in the method.</short>
</element>
<element name="BidiFlipAlignment.Flip">
<short>
<b>True</b> to flip the alignment value when BiDiMode is enabled.
</short>
</element>

<element name="BidiFlipAnchors">
<short>
Swaps left and right anchor side settings for the specified control when 
BiDiMode is enabled.
</short>
<descr/>
<seealso/>
</element>
<element name="BidiFlipAnchors.Result">
<short>
Set of TAnchor values for the control after the value in Flip has been applied.
</short>
</element>
<element name="BidiFlipAnchors.Control">
<short>
Control with the anchors adjusted in the routine.
</short>
</element>
<element name="BidiFlipAnchors.Flip">
<short>
<b>True</b> to flip the anchor values when BiDiMode is enabled.
</short>
</element>

<element name="BidiFlipRect">
<short>
Flips the left and right coordinates in a rectangle and makes it relative to 
the ParentRect when Flip is <b>True</b>.
</short>
<descr>
<p>
No actions are performed in the routine if Flip is set to False (the default 
value).
</p>
</descr>
<seealso>
<link id="#lcl.grids.TCustomGrid.FlipRect">TCustomGrid.FlipRect</link>
<link id="#lcl.colorbox.TCustomColorBox.DrawItem">TCustomColorBox.DrawItem</link>
</seealso>
</element>
<element name="BidiFlipRect.Result">
<short>
TRect instance with the converted / adjusted Left and Right coordinates 
calculated in the routine.
</short>
</element>
<element name="BidiFlipRect.Rect">
<short>
TRect instance with the original Left and Right values potentially modified 
in the routine.
</short>
</element>
<element name="BidiFlipRect.ParentRect">
<short>
TRect instance with the parent coordinates where the values in Rect are 
located.
</short>
</element>
<element name="BidiFlipRect.Flip">
<short>
<b>True</b> to flip the left and right values when BiDiMode is enabled.
</short></element>

<element name="ChangeBiDiModeAlignment">
<short>
Flips the value Alignment to reflect the value needed for BiDi mode.
</short>
<descr/>
<seealso/>
</element>
<element name="ChangeBiDiModeAlignment.Alignment">
<short>TAlignment value updated in the method.</short>
</element>

<element name="DbgS">
<short>
Converts items of several data types into strings, for debug output.
</short>
<descr/>
<errors>[The parameters should have unique names, for every type]</errors>
<seealso/>
</element>
<element name="DbgS.Result">
<short>The string representing the given parameter(s).</short>
</element>
<element name="DbgS.a">
<short>TAlign value converted in the routine.</short>
</element>
<element name="DbgS.Anchors">
<short>Set of TAnchorKind values converted in the routine.</short>
</element>
<element name="DbgS.Side">
<short>Anchor side enumeration value converted in the routine.</short>
</element>
<element name="DbgS.p">
<short>Auto-size phase converted in the routine.</short>
</element>
<element name="DbgS.Phases">
<short>
All elements in this set will be shown as a comma-separated list.
</short>
</element>
<element name="DbgS.cst">
<short>Control style flag converted in the routine.</short>
</element>
<element name="DbgS.cs">
<short>Set of control style flags converted in the routine.</short>
</element>
<element name="DbgS.fs">
<short>Form style value converted in the routine.</short>
</element>

<element name="assign(variant):TCaption">
<short>
Declares an assignment operator used to convert a Variant type to a TCaption 
type.
</short>
<descr>
<p>
Declares an assignment operator used to convert a TVariant value to a 
TCaption value during assignment. Casts the value in AVariant to a String 
type and assigns it as the return value for the operator. For example:
</p>
<code>
var
  AVariant: Variant;
  AControl: TControl;
  // ...
  AControl.Caption := AVariant;
</code>
</descr>
<seealso/>
</element>
<element name="Assign.Result">
<short>TCaption value for the assignment operator.</short>
</element>
<element name="Assign.Variant">
<short>
Variant value converted to a TCaption value prior to assignment.
</short>
</element>

<element name="CompareLazAccessibleObjectsByDataObject">
<short>
Compares the specified pointers containing a Lazarus accessibility object and 
a accessibility object data.
</short>
<descr/>
<seealso/>
</element>
<element name="CompareLazAccessibleObjectsByDataObject.Result">
<short/>
</element>
<element name="CompareLazAccessibleObjectsByDataObject.o1">
<short/>
</element>
<element name="CompareLazAccessibleObjectsByDataObject.o2">
<short/>
</element>

<element name="CompareDataObjectWithLazAccessibleObject">
<short>
Compares the specified pointers containing Lazarus accessibility object data 
and a accessibility object.
</short>
<descr/>
<seealso/>
</element>
<element name="CompareDataObjectWithLazAccessibleObject.Result">
<short/>
</element>
<element name="CompareDataObjectWithLazAccessibleObject.o">
<short/>
</element>
<element name="CompareDataObjectWithLazAccessibleObject.ao">
<short/>
</element>

<element name="Register">
<short>
Register the components provided by this unit or package, so that they can be 
instantiated.
</short>
<descr>
<p>
<var>Register</var> is a procedure used to register components in this unit 
in the Lazarus IDE. Register adds the <var>TImageList</var> component on the 
<b>Common Controls</b> tab. In addition, the <var>TCustomControl</var> and 
<var>TGraphicControl</var> components are registered without icons.
</p>
<p>
Register can also be used to register the controls required by an application.
</p>
</descr>
<seealso>
<link id="#rtl.classes.registercomponents">RegisterComponents</link>
</seealso>
</element>

<!--

TODO: For FPC 3.2.3+. Uncomment when FPC 3.3 docs are released.

<element name="dkDrag" link="#rtl.System.UITypes.dkDrag"/>
<element name="dkDock" link="#rtl.System.UITypes.dkDock"/>
<element name="dmManual" link="#rtl.System.UITypes.dmManual"/>
<element name="dmAutomatic" link="#rtl.System.UITypes.dmAutomatic"/>
<element name="dsDragEnter" link="#rtl.System.UITypes.dsDragEnter"/>
<element name="dsDragLeave" link="#rtl.System.UITypes.dsDragLeave"/>
<element name="dsDragMove" link="#rtl.System.UITypes.dsDragMove"/>
<element name="dmDragEnter" link="#rtl.System.UITypes.dmDragEnter"/>
<element name="dmDragLeave" link="#rtl.System.UITypes.dmDragLeave"/>
<element name="dmDragMove" link="#rtl.System.UITypes.dmDragMove"/>
<element name="dmDragDrop" link="#rtl.System.UITypes.dmDragDrop"/>
<element name="dmDragCancel" link="#rtl.System.UITypes.dmDragCancel"/>
<element name="dmFindTarget" link="#rtl.System.UITypes.dmFindTarget"/>

-->

<topic name="AutoSize">
<short>
<var>AutoSize</var> - boolean property that permits the size of a control to 
be adjusted automatically.
</short>
<descr>
<p>
<var>AutoSize</var> is a boolean property found in many classes; it permits 
the size of a control to be adjusted automatically to accommodate differences 
in the text or graphic contained therein, and allows most efficient use of 
available space
</p>
<p>
Many controls call <link 
id="#lcl.controls.TControl.DoAutoSize">TControl.DoAutoSize</link> to perform 
the actual auto-sizing.
</p>
<p>
IMPORTANT: Many Delphi controls override this method and many call this 
method directly after setting some properties.
</p>
<p>
During handle creation not all interfaces can create complete Device Contexts 
which are needed to calculate things like text size.
</p>
<p>
That's why you should always call <link 
id="#lcl.controls.TControl.AdjustSize">AdjustSize</link> instead of 
<var>DoAutoSize</var>.
</p>
<p>
<var>TControl.AdjustSize</var> calls <var>DoAutoSize</var> in a smart fashion.
</p>
<p>
During loading and handle creation the calls are delayed.
</p>
<p>
This method is essentially the same as <link 
id="#lcl.controls.TWinControl.DoAutoSize">TWinControl.DoAutoSize</link>. But 
since <var>DoAutoSize</var> is commonly overridden in descendent components, 
it is not useful to perform all tests, which can result in too much overhead. 
To reduce the overhead, the LCL calls <var>AdjustSize</var> instead.
</p>
<p>
When setting <var>AutoSize</var> to <b>True</b>, the LCL auto-sizes the width 
and height for the control. This is one of the most complex parts of the LCL, 
because the result depends on nearly a hundred properties. Let's start with a 
simple scenario:
</p>
<p>
The LCL will only auto-size the Width or Height if it is free to resize. In 
other words, the width is not auto-sized if:
</p>
<ul>
<li>
The left and right side is anchored. You can anchor the sides with the 
<var>Anchors</var> property or by setting the <var>Align</var> property to 
<var>alTop</var>, <var>alBottom</var> or <var>alClient</var>
</li>
<li>
The Width and Height are bound by the <var>Constraints</var> properties. The 
Constraints can also be overridden by the widgetset. For example the WinAPI 
does not allow resizing the height of a combo-box. And the gtk widgetset does 
not allow resizing the width of a vertical scrollbar.
</li>
</ul>
<p>
The new size is calculated by the protected method <link 
id="#lcl.controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>. 
This method asks the widgetset for an appropriate Width and Height. For 
example a <var>TButton</var> has preferred Width and Height. A 
<var>TComboBox</var> has only a preferred Height. The preferred Width is 
returned as 0 and so the LCL does not auto-size the Width - it keeps the 
width unaltered. Finally a <var>TMemo</var> has no preferred Width or Height. 
Therefore AutoSize has no effect on a TMemo.
</p>
<p>
Some controls override this method. For example the 
<var>TGraphicControl</var> descendants like <var>TLabel</var> have no window 
handle and so cannot query the widgetset. They must calculate their preferred 
Width and Height themselves.
</p>
<p>
The widgetsets must override the <var>GetPreferredSize</var> method for each 
widget class that has a preferred size (Width or Height or both).
</p>
<p><b>Parent.AutoSize</b></p>
<p>
The above described the simple explanation. The real algorithm provides far 
more possibilities and is therefore far more complex.
</p>
<p><b>Properties / Methods</b></p>
<p><b>Left and Top</b></p>
<p>
If <var>Parent</var> is not <b>Nil</b> then <var>Left, Top</var> are the 
pixel distance to the top, left pixel of the parent's client area (not 
scrolled). Remember the client area is always without the frame and 
scrollbars of the parent. For Delphi users, some VCL controls like TGroupbox 
define the client area as the whole control including the frame. Others do 
not. The LCL is more consistent, and therefore Delphi incompatible. Left and 
Top can be negative or bigger than the client area. Some widgetsets define a 
minimum, and maximum somewhere around 10,000 pixels or more.
</p>
<p>
When the client area is scrolled the Left and Top are kept unchanged.
</p>
<p>
During resizing, or when moving, the Left and Top coordinates are not always 
in sync with the coordinates for the Handle object.
</p>
<p>
When Parent is unassigned (contains <b>Nil</b>), Left and Top depend on the 
widgetset and the window manager. Until Lazarus 0.9.25, this is typically the 
screen coordinate of the left, top of the client area for the form. This is 
Delphi incompatible. It is planned to change this to the Left, Top of the 
window.
</p>
<p><b>Hint:</b></p>
<p>
Each time you change Left and Top, the LCL starts the movement instantly. If 
you want to change both Left and Top, use the following instead:
</p>
<code>
with Button1 do
    SetBounds(NewLeft,NewTop,Width,Height);
</code>
<p><b>Width and Height</b></p>
<p>
The Size in pixels must not be negative; most widgetsets do not allow Width 
and/or Height to be Zero (0). Some controls (on some platforms )define a 
larger minimum constraint. Instead of sizing a control to Width=0 and/or 
Height=0, set Visible to <b>False</b>. During resizing and moving, Width and 
Height are not always in sync with the size of the Handle object.
</p>
<p><b>BoundsRect</b></p>
<p>Same as Bounds(Left,Top,Width,Height).</p>
<p>Common newbie mistake:</p>
<code>
BoundsRect.Left:=3; // WRONG: common newbie mistake
</code>
<p>
This has no effect, because reading BoundsRect is a function. It creates a 
temporary TRect on the stack.
</p>
<p><b>ClientRect</b></p>
<p>
Left and Top are always 0,0. Width and Height are the visible size in pixels 
of the client area. Remember the client area is without the frame and without 
scrollbars. In a scrollable client area the logical client area can be bigger 
than the visible.
</p>
<p><b>ClientOrigin</b></p>
<p>
Returns the screen coordinate of the top left coordinate 0,0 of the client 
area. Note that this value is the position as stored in the interface and is 
not always in sync with the LCL. When a control is moved, the LCL sets the 
bounds to the desired position and sends a move message to the interface. It 
is up to the interface to handle moves instantly or queued.
</p>
<p><b>LCLIntf.GetClientBounds</b></p>
<p>
Returns the client bounds of a control. Like ClientRect, but Left and Top are 
the pixel distances to the control's left, top. For example on a TGroupBox 
the Left, Top are the width and height of the left and top frame border. 
Scrolling has no effect on GetClientBounds.
</p>
<p><b>LCLIntf.GetWindowRect</b></p>
<p>
After the call, ARect will be the control area in screen coordinates. That 
means, Left and Top will be the screen coordinate of the TopLeft pixel of the 
Handle object and Right and Bottom will be the screen coordinate of the 
BottomRight pixel.
</p>
<p><b>FBaseBoundsLock: integer</b></p>
<p>
Increased/Decreased by LockBaseBounds/UnlockBaseBounds. Used to keep 
FBaseBounds during SetBounds calls.
</p>
<p><b>FBaseParentClientSize: TPoint</b></p>
<p>
The Parent.ClientRect size valid for the FBaseBounds. FBaseBounds and 
FBaseParentClientSize are used to calculate the distance for akRight 
(akBottom). When the parent is resized, the LCL knows what distance to keep.
</p>
<p><b>FBoundsRectForNewParent: TRect</b></p>
<p>
When changing the Parent of a control the Handle is recreated and many things 
can happen. Especially for docking forms the process is too unreliable. 
Therefore the BoundsRect is saved. The VCL uses a similar mechanism.
</p>
<p><b>FLastDoChangeBounds: TRect</b></p>
<p>
Used to avoid calling OnChangeBounds with the same coordinates. This reduces 
user defined auto-sizing.
</p>
<p>
<b>FLastResizeClientHeight: integer</b> <br/>
<b>FLastResizeClientWidth: integer</b> <br/>
<b>FLastResizeHeight: integer</b> <br/>
<b>FLastResizeWidth: integer</b>
</p>
<p>
Used to avoid calling OnResize with the same coordinates. This reduces user
defined auto-sizing.
</p>
<p><b>FLoadedClientSize: TPoint</b></p>
<p>
During loading many things are delayed and many things are set and worse: in 
the wrong order. That's why SetClientWidth/SetClientHeight calls are stored 
and set at end of loading again. This way the LCL can restore the distances 
(e.g. akRight) used during designing.
</p>
<p><b>FReadBounds: TRect</b></p>
<p>
Same as FLoadedClientSize, but for SetLeft, SetTop, SetWidth, SetHeight.
</p>
<p><b>SetBoundsRectForNewParent(const AValue: TRect);</b></p>
<p>Used to set FBoundsRectForNewParent. See above.</p>
<p>
<b>procedure SetInitialBounds(aLeft, aTop, aWidth, aHeight: integer); 
virtual;</b>
</p>
<p>A smart version of SetBounds, reducing overhead during creation and 
loading.</p>
<p>
<b>
procedure UpdateBaseBounds(StoreBounds, StoreParentClientSize, 
UseLoadedValues: boolean); virtual;
</b>
</p>
<p>Commit current bounds to base bounds.</p>
<p>
<b>procedure SetClientHeight(Value: Integer);</b> <br/>
<b>procedure SetClientSize(Value: TPoint);</b> <br/>
<b>procedure SetClientWidth(Value: Integer);</b>
</p>
<p>
Exists for Delphi compatibility too. Resizes the control, to get the wanted 
ClientRect size.
</p>
<p>
<b>procedure ChangeBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</b>
</p>
<p>
This is the internal SetBounds. Applies constraints, updates base bounds, 
calls OnChangeBound, OnResize, locks bounds.
</p>
<p>
<b>procedure DoSetBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</b>
</p>
<p>This really sets the FLeft, FTop, FWidth, FHeight private variables.</p>
<p>
<b>procedure SetBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</b>
</p>
<p>
This is the standard procedure overridden by many Delphi controls. 
TWinControl overrides it too. Ignores calls when bounds are locked; lock the 
FBoundsRealized to avoid overhead to the interface during auto sizing. 
ChangeBounds is not locked this way.
</p>
<p>
<b>Function GetClientOrigin: TPoint; virtual;</b>
</p>
<p>Screen coordinate of Left, Top of client area.</p>
<p>
<b>Function GetClientRect: TRect; virtual;</b>
</p>
<p>Size of client area. (always Left=0, Top=0)</p>
<p>
<b>Function GetScrolledClientRect: TRect; virtual;</b>
</p>
<p>Visible client area in ClientRect.</p>
<p>
<b>function GetChildsRect(Scrolled: boolean): TRect; virtual;</b>
</p>
<p>
Returns the Client rectangle relative to the control's Left, Top. If Scrolled 
is <b>True</b>, the rectangle is moved by the current scrolling values (for 
an example see TScrollingWincontrol).
</p>
<p>
<b>function GetClientScrollOffset: TPoint; virtual;</b>
</p>
<p>Returns the scrolling offset of the client area.</p>
<p>
<b>function GetControlOrigin: TPoint; virtual;</b>
</p>
<p>
Returns the screen coordinate of the topleft coordinate 0,0 of the control 
area. (The topleft pixel of the control on the screen) Note that this value 
is the position as stored in the interface and is not always in sync with the 
LCL. When a control is moved, the LCL sets the bounds to the wanted position 
and sends a move message to the interface. It is up to the interface to 
handle moves instantly or queued.
</p>
</descr>
</topic>

<topic name="ControlCoordinates">
<short>
The coordinates of a control can be specified or retrieved in various ways
</short>
<descr>
<p>
The following description applies to members of TControl and TWinControl.
</p>
<p>
Every control has an origin (Top, Left) and extent (Width, Height). The 
origin is relative to its Parent control (client coordinates) or, for 
floating controls (forms) with Parent=Nil, relative to the screen.
</p>
<p>
The BoundsRect describes the TopLeft and BottomRight coordinates of the 
control, relative to its Parent.
</p>
<p>
The BoundsRectForNewParent holds the new coordinates, to be used when the 
Parent of the control is changed later.
</p>
<p>
The ClientRect describes the internal (client) area of a container control 
(TWinControl), excluding borders. Its Top and Left are always zero. In a 
TScrollingWinControl...
</p>
<p>
BaseBounds holds the designed Bounds, to be used e.g. when a scale factor is 
set later.
</p>
<p>
GetControlOrigin returns the origin in screen coordinates. These values are 
not always in sync with the <b>True</b> screen position, managed by the 
widgetset.
</p>
<p>
ScreenToClient returns the client coordinates of an point given in the screen 
coordinates, i.e. the coordinates relative to the control's client origin.
</p>
<p>
ClientToScreen returns the screen coordinates for an point in client 
coordinates.
</p>
</descr>
</topic>

<topic name="AnchoringControls">
<short>
How multiple controls can be aligned and resized together, at run-time.
</short>
<descr>
<p>
The tree-style layout of a form allows one to specify table-style areas, with 
a common width or height of all controls in the same area (using container 
controls like e.g. TPanel).
</p>
<p>
Delphi introduced control anchoring to the sides of the Parent control. This 
means when a control in a form has Anchors[akRight]=True, its right side 
keeps its distance from the right side of its Parent, when its Parent is 
resized.
</p>
<p>
The default anchors [akLeft,akTop] keep every control anchored to the origin 
(TopLeft) of their Parent control (of form). This will cause controls to 
disappear when the form is shrunken, or the user has to scroll through the 
form's client area.
</p>
<p>
When a control shall e.g. use the available space, left over to its right, 
Anchors=[akLeft,akRight] will result in a variable-width control.
</p>
<p>
The Align property allows one to stack controls at their Parent's sides, e.g. 
all controls with Align=alTop are stacked at the top of their Parent. The 
remaining space in the Parent can be occupied by a single control, of 
Align=alClient.
</p>
<p>
Both Anchors and Align are tightly coupled, changing one property will affect 
the other one. This is harmless in so far, as the IDE (form designer) keeps 
all adjustments in sync, free of conflicts.
</p>
<p>
Some people found this approved layout method too restrictive, and too 
complicated to use, and now LCL controls <b>also</b> can be anchored 
<b>freely</b> to each other. This layout management is traditionally referred 
to as "Anchor Docking", even if it is not related to docking at all.
</p>
<remark>
This freedom requires that the GUI designer is responsible for consistent 
anchor specifications, which do not result in unresolvable cyclic references 
or other contradictions.
</remark>
<p>
Anchor docking allows one to anchor every side of a control to an arbitrary 
side of another control, i.e. the left side of an Edit control can be 
anchored to the right side of its associated Label.
</p>
<p>
<b>Example1</b>
</p>
<p>
If you want to have the top of B the same as the top of C:
</p>
<pre>
+-----+  +-----+
|  B  |  |  C  |
|     |  +-----+
+-----+
</pre>
<p>
use:
</p>
<code>
B.AnchorSide[akTop].Control:=C;
B.AnchorSide[akTop].Side:=asrTop;
</code>
<p>
When you want to have a gap between both controls, set e.g. 
B.Borderspacing.Right to the desired amount. Setting C.Borderspacing.Left 
will have the same effect, and both can be used together; the resulting gap 
then reflects the maximum value of both properties.
</p>
<p>
BorderSpacing is in effect even for controls without special anchoring, when 
AutoSize is used.
</p>
<p>
Anchor docking also allows one to center a control relative to another 
control.
</p>
<p>
<b>Example2</b>
</p>
<p>
For centering A relative to B:
</p>
<pre>
+-------+
|       | +---+
|   B   | | A |
|       | +---+
+-------+
</pre>
<p>
use:
</p>
<code>
A.AnchorSide[akTop].Side:=asrCenter;
A.AnchorSide[akTop].Control:=B;
</code>
<p>
Or use this equivalent:
</p>
<code>
A.AnchorSide[akBottom].Side:=asrCenter;
A.AnchorSide[akBottom].Control:=B;
</code>
<p>
TControlChildSizing and TControlChildrenLayout offers additional means for 
aligning and separating controls.
</p>
</descr>
</topic>

</module>
<!-- Controls -->
</package>
</fpdoc-descriptions>
